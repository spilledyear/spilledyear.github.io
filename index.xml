<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>spilledyear</title>
    <link>https://www.spilledyear.cn/</link>
    <description>Recent content on spilledyear</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 20 Jul 2019 18:49:01 +0000</lastBuildDate>
    
        <atom:link href="https://www.spilledyear.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于我</title>
      <link>https://www.spilledyear.cn/%E5%85%B3%E4%BA%8E%E6%88%91/</link>
      <pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/%E5%85%B3%E4%BA%8E%E6%88%91/</guid>
      
        <description>&lt;p&gt;人生得意须尽欢
莫使金樽空对月&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Dubbo源码之SPI机制</title>
      <link>https://www.spilledyear.cn/post/dubbo%E6%BA%90%E7%A0%81%E4%B9%8Bspi%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 20 Jul 2019 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/dubbo%E6%BA%90%E7%A0%81%E4%B9%8Bspi%E6%9C%BA%E5%88%B6/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/049.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;SPI(Service Provider Interface)是一种服务提供发现机制,一个服务通常指的是已知的接口，服务提供方就是这个接口的实现类，然后按照SPI标准存放到资源路径META-INF/services目录下，文件的命名为该服务接口的全限定名。&lt;/p&gt;

&lt;p&gt;这里会介绍两种SPI机制：JDK默认提供的SPI机制 ServiceLoader；Dubbo的SPI机制  ExtensionLoader。ServiceLoader功能比较单一，不能依赖注入、不能根据扩展实现类标识符获取特定的扩展实现类实例；&lt;/p&gt;

&lt;h1 id=&#34;serviceloader&#34;&gt;ServiceLoader&lt;/h1&gt;

&lt;h3 id=&#34;测试案例&#34;&gt;测试案例&lt;/h3&gt;

&lt;p&gt;有一个服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.zto.sxy.helloworld;

public interface ISPI {
    void say();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现类SPITestA&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.zto.sxy.helloworld;

public class SPITestA implements ISPI{
    @Override
    public void say() {
        System.out.println(&amp;quot;SPI with implement testA&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现类SPITestB&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package com.zto.sxy.helloworld;
public class SPITestB implements ISPI{
    @Override
    public void say() {
        System.out.println(&amp;quot;SPI with implement testB&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在resources目录下添加META-INF/services文件夹，同时新建一个名为com.zto.sxy.helloworld.ISPI的文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;com.zto.sxy.helloworld.SPITestA
com.zto.sxy.helloworld.SPITestB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是测试类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TestSPI {
    @Test
    public void testWithNoSPI(){
        ISPI testA = new SPITestA();
        testA.say();

        ISPI testB = new SPITestB();
        testB.say();
    }
    
    @Test
    public void testWithSPI(){
        ServiceLoader services = ServiceLoader.load(ISPI.class);
        for (Iterator&amp;lt;ISPI&amp;gt; iterator = services.iterator(); iterator.hasNext(); ) {
            ISPI spi = iterator.next();
            spi.say();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行测试函数，发现两个输出结果一样，说明SPI生效了，输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SPI with implement testA
SPI with implement testB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实现原理&#34;&gt;实现原理&lt;/h3&gt;

&lt;p&gt;先看load方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service) {
    // 获取当前线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}

public static &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt; service,ClassLoader loader){
    return new ServiceLoader&amp;lt;&amp;gt;(service, loader);
}

private ServiceLoader(Class&amp;lt;S&amp;gt; svc, ClassLoader cl) {
    service = Objects.requireNonNull(svc, &amp;quot;Service interface cannot be null&amp;quot;);
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;

    // 清空缓存，确保会重新加载
    reload();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在调用的的时候，先通过调用iterator方法返回一个Iterator对象，然后遍历该Iterator对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Iterator&amp;lt;S&amp;gt; iterator() {
    return new Iterator&amp;lt;S&amp;gt;() {
        //     private LinkedHashMap&amp;lt;String,S&amp;gt; providers = new LinkedHashMap&amp;lt;&amp;gt;();
        Iterator&amp;lt;Map.Entry&amp;lt;String,S&amp;gt;&amp;gt; knownProviders
            = providers.entrySet().iterator();

        public boolean hasNext() {
            if (knownProviders.hasNext())
                return true;
            return lookupIterator.hasNext();
        }

        public S next() {
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用hasNext方法的时候，会调用lookupIterator.hasNext()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean hasNextService() {
    if (nextName != null) {
        return true;
    }
    if (configs == null) {
        try {
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
                configs = loader.getResources(fullName);
        } catch (IOException x) {
            fail(service, &amp;quot;Error locating configuration files&amp;quot;, x);
        }
    }
    while ((pending == null) || !pending.hasNext()) {
        if (!configs.hasMoreElements()) {
            return false;
        }

        // 获取所有类的全类名
        pending = parse(service, configs.nextElement());
    }
  
    nextName = pending.next();
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用next方法的时候&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&amp;lt;?&amp;gt; c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
                &amp;quot;Provider &amp;quot; + cn + &amp;quot; not found&amp;quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
                &amp;quot;Provider &amp;quot; + cn  + &amp;quot; not a subtype&amp;quot;);
    }
    try {
        // 实例化
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
                &amp;quot;Provider &amp;quot; + cn + &amp;quot; could not be instantiated&amp;quot;,
                x);
    }
    throw new Error();          // This cannot happen
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者并实例化，而是等其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。&lt;/p&gt;

&lt;h1 id=&#34;extensionloader&#34;&gt;ExtensionLoader&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/&#34;&gt;大佬博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;测试案例-1&#34;&gt;测试案例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;@Test
public void test() {
    ExtensionLoader loader = ExtensionLoader.getExtensionLoader(Protocol.class);

    Protocol protocol = (Protocol) loader.getExtension(&amp;quot;dubbo&amp;quot;);
}


/**
 * 1.  ExtensionLoader loder = ExtensionLoader.getExtensionLoader(Protocol.class); 返回 loader1
 *        1.1 创建一个ExtensionLoader实例(loader1)，此时 loader1 的 type=Protocol.class，在为 loader1 的 objectFactory 属性赋值的时候，触发 ExtensionFactory 对应的ExtensionLoader实例化；
 *
 *        1.2 创建一个ExtensionLoader实例(loader2)，此时 loader2 的 type=ExtensionFactory.class，objectFactory = null;
 *
 *        1.3 执行 loader2 的 getAdaptiveExtension() 方法， 生成一个 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive)，赋值给 loader1 的 objectFactory 属性；
 *                  1.3.1 先从缓存中找到，中不到就执行 loadExtensionClasses() 方法，该方法会从配置文件中加载 ExtensionFactory 所有实现类的class对象，同事可以将 adaptive 和 wrapper 类型的是实现类缓存起来
 *                  1.3.2 找到 ExtensionFactory 对应的 adaptive实现类是 AdaptiveExtensionFactory，然后通过反射创建 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive)；
 *                              1.3.2.1 在 AdaptiveExtensionFactory 构造函数中，通过 loader2.getSupportedExtensions() 方法找到 spi(1.2.1中缓存起来的), 然后调用 loader2.getExtension(&amp;quot;spi&amp;quot;);
 *                              1.3.2.2 在 loader2.getExtension(&amp;quot;spi&amp;quot;) 方法中通过反射生成一个 SpiExtensionFactory 实例(spiExtensionFactory);
 *                              1.3.2.3 将 1.2.2.2 中生成的 SpiExtensionFactory 实例(spiExtensionFactory)  保存到 extensionFactoryAdaptive的factories属性中；
 *
 *        1.4 将 1.3 中生成的 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive) 赋值给loader2的 objectFactory 属性，即 loader.objectFactory = extensionFactoryAdaptive;
 *
 *
 * 2. Protocol protocol = (Protocol) loder.getExtension(&amp;quot;dubbo&amp;quot;); 这里的 loader 对应上面的 loader1
 *        2.1  先从缓存中获取，如果缓存中没有，就获取dubbo对应实现类的class对象，然后通过通过反射创建实例并放入缓存；
 *
 *        2.2 执行 injectExtension 方法，这是依赖注入相关的方法，可以注入 spring里面的bean对象 和 SPI对象；
 *                  2.2.1 找到实例的 setter 方法；
 *                  2.2.2 执行 objectFactory.getExtension 方法，这里的 objectFactory 就是指 extensionFactoryAdaptive；
 *                  2.2.3 执行 extensionFactoryAdaptive.getExtension 方法，然后在 该方法内部调用 spiExtensionFactory.getExtension 方法；
 *                  2.2.4 在 spiExtensionFactory.getExtension 方法内部找到对应的adaptive实例；
 *                  
 *        2.3 执行 wrapper 操作，即给实例 一层一层的包装，类似于多层代理；
 *        
 *        2.4 返回最终的实例；
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实现原理-1&#34;&gt;实现原理&lt;/h3&gt;

&lt;p&gt;在此之前，先看看ExtensionLoader中一些属性的含义&lt;/p&gt;

&lt;h6 id=&#34;快速预览&#34;&gt;快速预览&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;private static final Logger logger = LoggerFactory.getLogger(ExtensionLoader.class);

private static final String SERVICES_DIRECTORY = &amp;quot;META-INF/services/&amp;quot;;

private static final String DUBBO_DIRECTORY = &amp;quot;META-INF/dubbo/&amp;quot;;

private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + &amp;quot;internal/&amp;quot;;

private static final Pattern NAME_SEPARATOR = Pattern.compile(&amp;quot;\\s*[,]+\\s*&amp;quot;);

// 所有ExtensionLoader实例共享，缓存 对应扩展接口：ExtensionLoader实例
private static final ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, ExtensionLoader&amp;lt;?&amp;gt;&amp;gt; EXTENSION_LOADERS = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 所有ExtensionLoader实例共享，缓存 对应实现类class对象：对应的实现类实例
private static final ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; EXTENSION_INSTANCES = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 扩展接口Class对象
private final Class&amp;lt;?&amp;gt; type;

private final ExtensionFactory objectFactory;

// 缓存 实现类Class对象：实现类标识
private final ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, String&amp;gt; cachedNames = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 缓存当前扩展下所有实现类的 Class对象
private final Holder&amp;lt;Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt;&amp;gt; cachedClasses = new Holder&amp;lt;&amp;gt;();

// 缓存带有@Active注解的实现类，实现类标识：实现类Class对象，@Active注解表示该扩展实现类的激活条件和时机
private final Map&amp;lt;String, Object&amp;gt; cachedActivates = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 缓存 实现类标识：Holder，因为种扩展都对应一个ExtensionLoader实例，所以通过实现类标识可以区分实现类
private final ConcurrentMap&amp;lt;String, Holder&amp;lt;Object&amp;gt;&amp;gt; cachedInstances = new ConcurrentHashMap&amp;lt;&amp;gt;();

// 缓存 带有@Adaptive注解的实现类的实例，因为每种扩展只能有一个实现类带有@Adaptive注解
private final Holder&amp;lt;Object&amp;gt; cachedAdaptiveInstance = new Holder&amp;lt;&amp;gt;();

// 缓存 带有@Adaptive注解的实现类Class对象，因为每种扩展只能有一个实现类带有@Adaptive注解
private volatile Class&amp;lt;?&amp;gt; cachedAdaptiveClass = null;

private String cachedDefaultName;
private volatile Throwable createAdaptiveInstanceError;

// 缓存 包装类 实现类里参数是接口类型的(如 com.alibaba.dubbo.rpc.Protocol类型，并且只有1个参数)的构造函数，表示它是个接口包装类
private Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; cachedWrapperClasses;

private Map&amp;lt;String, IllegalStateException&amp;gt; exceptions = new ConcurrentHashMap&amp;lt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;getextensionloader&#34;&gt;getExtensionLoader&lt;/h6&gt;

&lt;p&gt;getExtensionLoader是一个静态方法，用于获取一个ExtensionLoader实例，每种扩展对应一个ExtensionLoader实例，缓存在一个静态ConcurrentMap中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; getExtensionLoader(Class&amp;lt;T&amp;gt; type) {
    if (type == null)
        throw new IllegalArgumentException(&amp;quot;Extension type == null&amp;quot;);
    if (!type.isInterface()) {
        throw new IllegalArgumentException(&amp;quot;Extension type(&amp;quot; + type + &amp;quot;) is not interface!&amp;quot;);
    }

    // 检查是否有@SPI注解
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException(&amp;quot;Extension type(&amp;quot; + type +
                &amp;quot;) is not extension, because WITHOUT @&amp;quot; + SPI.class.getSimpleName() + &amp;quot; Annotation!&amp;quot;);
    }

    ExtensionLoader&amp;lt;T&amp;gt; loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&amp;lt;T&amp;gt;(type));
        loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);
    }
    return loader;
}

private ExtensionLoader(Class&amp;lt;?&amp;gt; type) {
    this.type = type;
    // 在创建ExtensionLoader实例的过程中，涉及到和ExtensionFactory扩展相关的操作，这个在下面会有详细介绍
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;getextension&#34;&gt;getExtension&lt;/h6&gt;

&lt;p&gt;每种扩展对应一个ExtensionLoader实例，每个ExtensionLoader实例中缓存了很多和当前扩展相关的信息，例如：该扩展的实现类、带有@Adaptive注解的扩展实现类、Wrapper实现类等等。getExtension主要是根据扩展实现类标识符获取对应的扩展实现类实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public T getExtension(String name) {
    if (name == null || name.length() == 0)
        throw new IllegalArgumentException(&amp;quot;Extension name == null&amp;quot;);
    if (&amp;quot;true&amp;quot;.equals(name)) {
        return getDefaultExtension();
    }
    Holder&amp;lt;Object&amp;gt; holder = cachedInstances.get(name);
    if (holder == null) {
        cachedInstances.putIfAbsent(name, new Holder&amp;lt;Object&amp;gt;());
        holder = cachedInstances.get(name);
    }
    Object instance = holder.get();
    // 双重校验
    if (instance == null) {
        synchronized (holder) {
            instance = holder.get();
            if (instance == null) {
                // 根据扩展名，获取具体扩展实例
                instance = createExtension(name);
                holder.set(instance);
            }
        }
    }
    return (T) instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;createextension&#34;&gt;createExtension&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;@SuppressWarnings(&amp;quot;unchecked&amp;quot;)
private T createExtension(String name) {
    // 先从当前ExtensionLoader实例中的缓存中获取Class对象，如果没有就加载SPI相关文件
    Class&amp;lt;?&amp;gt; clazz = getExtensionClasses().get(name);
    if (clazz == null) {
        throw findException(name);
    }
    try {
        // 同步到静态缓存
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        if (instance == null) {
            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
            instance = (T) EXTENSION_INSTANCES.get(clazz);
        }

        // 完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）
        injectExtension(instance);

        // 如果这些实现类有wrapper类，当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入；最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制
        Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses = cachedWrapperClasses;
        if (wrapperClasses != null &amp;amp;&amp;amp; !wrapperClasses.isEmpty()) {
            for (Class&amp;lt;?&amp;gt; wrapperClass : wrapperClasses) {
                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
            }
        }
        return instance;
    } catch (Throwable t) {
        throw new IllegalStateException(&amp;quot;Extension instance(name: &amp;quot; + name + &amp;quot;, class: &amp;quot; +
                type + &amp;quot;)  could not be instantiated: &amp;quot; + t.getMessage(), t);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;getextensionclasses&#34;&gt;getExtensionClasses&lt;/h6&gt;

&lt;p&gt;获取实现类的Class对象，在加载文件的过程中，会将相应的信息放入缓存中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; getExtensionClasses() {
    // 从缓存中获取
    Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; classes = cachedClasses.get();
    if (classes == null) {
        synchronized (cachedClasses) {
            classes = cachedClasses.get();
            if (classes == null) {
                // 加载SPI相关文件
                classes = loadExtensionClasses();
                cachedClasses.set(classes);
            }
        }
    }
    return classes;
}

// synchronized in getExtensionClasses
private Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; loadExtensionClasses() {
    final SPI defaultAnnotation = type.getAnnotation(SPI.class);
    // 判断是否有@SPI注解
    if (defaultAnnotation != null) {
        String value = defaultAnnotation.value();
        if ((value = value.trim()).length() &amp;gt; 0) {
            String[] names = NAME_SEPARATOR.split(value);
            // 只能有一个默认值：SPI(value=&amp;quot;xxx&amp;quot;)，默认实现xxx
            if (names.length &amp;gt; 1) {
                throw new IllegalStateException(&amp;quot;more than 1 default extension name on extension &amp;quot; + type.getName()
                        + &amp;quot;: &amp;quot; + Arrays.toString(names));
            }
            if (names.length == 1) cachedDefaultName = names[0];
        }
    }

    // 读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services
    Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; extensionClasses = new HashMap&amp;lt;&amp;gt;();
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(&amp;quot;org.apache&amp;quot;, &amp;quot;com.alibaba&amp;quot;));
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(&amp;quot;org.apache&amp;quot;, &amp;quot;com.alibaba&amp;quot;));
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(&amp;quot;org.apache&amp;quot;, &amp;quot;com.alibaba&amp;quot;));
    return extensionClasses;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h6&gt;

&lt;p&gt;在实例化扩展实现类的时候，该实现类可能会依赖一些其他的对象，主要有两种：一种是Spring容易中的Bean对象；另一种是其它的扩展实现类对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private T injectExtension(T instance) {
    try {
        if (objectFactory != null) {
            for (Method method : instance.getClass().getMethods()) {
                if (method.getName().startsWith(&amp;quot;set&amp;quot;)
                        &amp;amp;&amp;amp; method.getParameterTypes().length == 1
                        &amp;amp;&amp;amp; Modifier.isPublic(method.getModifiers())) {
                    // 获取所有public类型，并且只有一个参数的以set开头的方法

                    Class&amp;lt;?&amp;gt; pt = method.getParameterTypes()[0];
                    try {
                        // 构造驼峰命名法，得到该set方法的参数的类型，即：要注入的对应类型
                        String property = method.getName().length() &amp;gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &amp;quot;&amp;quot;;

                        // 获取要注入对应的实例
                        Object object = objectFactory.getExtension(pt, property);

                        if (object != null) {
                            // 执行set方法，完成注入
                            method.invoke(instance, object);
                        }
                    } catch (Exception e) {
                        logger.error(&amp;quot;fail to inject via method &amp;quot; + method.getName()
                                + &amp;quot; of interface &amp;quot; + type.getName() + &amp;quot;: &amp;quot; + e.getMessage(), e);
                    }
                }
            }
        }
    } catch (Exception e) {
        logger.error(e.getMessage(), e);
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;extensionfactory&#34;&gt;ExtensionFactory&lt;/h6&gt;

&lt;p&gt;有关于objectFactory对象，这里涉及到的内容比较多，在文章的开头已经提到过，这里详细解释一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ExtensionLoader(Class&amp;lt;?&amp;gt; type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}

public static &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; getExtensionLoader(Class&amp;lt;T&amp;gt; type) {
    if (type == null)
        throw new IllegalArgumentException(&amp;quot;Extension type == null&amp;quot;);
    if (!type.isInterface()) {
        throw new IllegalArgumentException(&amp;quot;Extension type(&amp;quot; + type + &amp;quot;) is not interface!&amp;quot;);
    }
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException(&amp;quot;Extension type(&amp;quot; + type +
                &amp;quot;) is not extension, because WITHOUT @&amp;quot; + SPI.class.getSimpleName() + &amp;quot; Annotation!&amp;quot;);
    }

    ExtensionLoader&amp;lt;T&amp;gt; loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&amp;lt;T&amp;gt;(type));
        loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);
    }
    return loader;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当执行以上语句的时候：
1. 先创建Protocol对应的ExtensionLoader实例对象
2. 在执行1的过程中，涉及到ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()操作，所以会先创建ExtensionFactory对应的ExtensionLoader实例对象，然后返回一个ExtensionFactory对象，赋值给Protocol对应的ExtensionLoader实例对象。&lt;/p&gt;

&lt;p&gt;ExtensionFactory其实也是一个扩展，并且它有一个带有@Adaptive注解的扩展实现类：AdaptiveExtensionFactory&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@SPI
public interface ExtensionFactory {

    /**
     * Get extension.
     *
     * @param type object type.
     * @param name object name.
     * @return object instance.
     */
    &amp;lt;T&amp;gt; T getExtension(Class&amp;lt;T&amp;gt; type, String name);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/6/11/16b469a1c885405d?w=1240&amp;amp;h=496&amp;amp;f=png&amp;amp;s=56774&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而根据getAdaptiveExtension()方法的名字也可以猜测出，这里应该是创建了一个AdaptiveExtensionFactory对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public T getAdaptiveExtension() {
    // 加载完SPI文件之后，如果有，就会放入缓存中
    Object instance = cachedAdaptiveInstance.get();
    if (instance == null) {
        if (createAdaptiveInstanceError == null) {
            synchronized (cachedAdaptiveInstance) {
                instance = cachedAdaptiveInstance.get();
                if (instance == null) {
                    try {
                        instance = createAdaptiveExtension();
                        cachedAdaptiveInstance.set(instance);
                    } catch (Throwable t) {
                        createAdaptiveInstanceError = t;
                        throw new IllegalStateException(&amp;quot;fail to create adaptive instance: &amp;quot; + t.toString(), t);
                    }
                }
            }
        } else {
            throw new IllegalStateException(&amp;quot;fail to create adaptive instance: &amp;quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);
        }
    }

    return (T) instance;
}

private T createAdaptiveExtension() {
    try {
        // 也需要处理依赖注入
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException(&amp;quot;Can not create adaptive extension &amp;quot; + type + &amp;quot;, cause: &amp;quot; + e.getMessage(), e);
    }
}

private Class&amp;lt;?&amp;gt; getAdaptiveExtensionClass() {
    // 这个方法有可能性触发SPI文件加载，当缓存中没有值得时候，就会加载SPI文件
    getExtensionClasses();
    if (cachedAdaptiveClass != null) {
        return cachedAdaptiveClass;
    }

    // 代表 @Adaptive注解添加在了方法上
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是AdaptiveExtensionFactory对应的源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Adaptive
public class AdaptiveExtensionFactory implements ExtensionFactory {

    private final List&amp;lt;ExtensionFactory&amp;gt; factories;

    public AdaptiveExtensionFactory() {
        ExtensionLoader&amp;lt;ExtensionFactory&amp;gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List&amp;lt;ExtensionFactory&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        // getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环
        for (String name : loader.getSupportedExtensions()) {
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    @Override
    public &amp;lt;T&amp;gt; T getExtension(Class&amp;lt;T&amp;gt; type, String name) {
        // 除AdaptiveExtensionFactory外，依次调用所有ExtensionFactory实现类的getExtension方法，如果找到了，就直接退出
        for (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            if (extension != null) {
                return extension;
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SpiExtensionFactory 用于注入扩展实现类(非包装类扩展，非Adaptive扩展)，SpringExtensionFactory用于注入Spring容器中的Bean。&lt;/p&gt;

&lt;h6 id=&#34;getadaptiveextension&#34;&gt;getAdaptiveExtension&lt;/h6&gt;

&lt;p&gt;上面已经提到了getAdaptiveExtension方法，这个方法用于获取自适应的扩展实现类，这方法真的非常非常重要，在dubbo到处用到了这个特性。有关于@Adaptive注解，这里再详细说明一下：
&lt;code&gt;@Adaptive用法有两种方式，一种在就配置在扩展实现类上，用于扩展实现类上时只能有一个；还有一种直接配置在方法上，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成&lt;/code&gt;
1. 在扩展实现类上加上@Adaptive注解，是最为明确的创建对应类型Adaptive类，优先级最高；
2. @SPI注解中的value是默认值，如果通过URL获取不到关于取哪个类作为Adaptive类的话，就使用这个默认值，当然如果URL中可以获取到，就用URL中的；
3. 可以在方法上增加@Adaptive注解，注解中的value与链接中的参数的key一致，链接中的key对应的value就是SPI中的name，获取相应的实现类；&lt;/p&gt;

&lt;p&gt;其实主要代码都在这里&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Class&amp;lt;?&amp;gt; getAdaptiveExtensionClass() {
    // 这个方法有可能性触发SPI文件加载，当缓存中没有值得时候，就会加载SPI文件
    getExtensionClasses();
    if (cachedAdaptiveClass != null) {
        return cachedAdaptiveClass;
    }

    // 动态生成
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}

// 动态生成源码，然后编译返回Class对象
private Class&amp;lt;?&amp;gt; createAdaptiveExtensionClass() {
    // 创建代码的字符串形式
    String code = createAdaptiveExtensionClassCode();
    ClassLoader classLoader = findClassLoader();
    // 通过SPI获取java 编译器
    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();

    // 编译源码返回Class对象
    return compiler.compile(code, classLoader);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下以Protocol为例进行讲解，因为Protocol对应的扩展实现类上都没有加@Adaptive注解，所以这里主要涉及到Protocol$Adaptive类的动态生成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@SPI(&amp;quot;dubbo&amp;quot;)
public interface Protocol {
    @Adaptive
    &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; export(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException;

    @Adaptive
    &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; refer(Class&amp;lt;T&amp;gt; type, URL url) throws RpcException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用的场景可能是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
Exporter&amp;lt;?&amp;gt; exporter = protocol.export(wrapperInvoker);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其动态生成的Protocol$Adaptive源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.apache.dubbo.rpc;
import org.apache.dubbo.common.extension.ExtensionLoader;

public class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol {
    private static final org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);
    private java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(0);

    public void destroy() {
        throw new UnsupportedOperationException(&amp;quot;method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&amp;quot;);
    }

    public int getDefaultPort() {
        throw new UnsupportedOperationException(&amp;quot;method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&amp;quot;);
    }

    public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {
        if (arg1 == null) throw new IllegalArgumentException(&amp;quot;url == null&amp;quot;);
        org.apache.dubbo.common.URL url = arg1;
        String extName = (url.getProtocol() == null ? &amp;quot;dubbo&amp;quot; : url.getProtocol());
        if (extName == null)
            throw new IllegalStateException(&amp;quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&amp;quot; + url.toString() + &amp;quot;) use keys([protocol])&amp;quot;);
        org.apache.dubbo.rpc.Protocol extension = null;
        try {
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
        } catch (Exception e) {
            if (count.incrementAndGet() == 1) {
                logger.warn(&amp;quot;Failed to find extension named &amp;quot; + extName + &amp;quot; for type org.apache.dubbo.rpc.Protocol, will use default extension dubbo instead.&amp;quot;, e);
            }
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(&amp;quot;dubbo&amp;quot;);
        }
        return extension.refer(arg0, arg1);
    }

    public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) throw new IllegalArgumentException(&amp;quot;org.apache.dubbo.rpc.Invoker argument == null&amp;quot;);
        if (arg0.getUrl() == null)
            throw new IllegalArgumentException(&amp;quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&amp;quot;);
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = (url.getProtocol() == null ? &amp;quot;dubbo&amp;quot; : url.getProtocol());
        if (extName == null)
            throw new IllegalStateException(&amp;quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&amp;quot; + url.toString() + &amp;quot;) use keys([protocol])&amp;quot;);
        org.apache.dubbo.rpc.Protocol extension = null;
        try {
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
        } catch (Exception e) {
            if (count.incrementAndGet() == 1) {
                logger.warn(&amp;quot;Failed to find extension named &amp;quot; + extName + &amp;quot; for type org.apache.dubbo.rpc.Protocol, will use default extension dubbo instead.&amp;quot;, e);
            }
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(&amp;quot;dubbo&amp;quot;);
        }
        return extension.export(arg0);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以export方法为例，从方法参数中Invoker获取信息， 如果没有，就取@SPI注解中的默认值：dubbo，如果都没有值，就抛出IllegalStateException异常&lt;/p&gt;

&lt;h6 id=&#34;wrapper处理&#34;&gt;Wrapper处理&lt;/h6&gt;

&lt;p&gt;在处理完一个扩展实现类的依赖注入问题之后，接下来需要处理的便是该扩展实现类的Wrapper问题。在dubbo中，扩展实现类里参数是接口类型的(如 com.alibaba.dubbo.rpc.Protocol类型，并且只有1个参数)的构造函数，表示它是个Wrapper类。为什么需要它的构造函数需要有一个接口类型的参数？主要是用于接收上层对应的扩展实现类，然后Wrapper类实现类接口，所以可以在方法中插入一些自己的逻辑，类似于代理模式。
以ProtocolFilterWrapper为例，主要在于给非Wrapper扩展实现类加强功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ProtocolFilterWrapper implements Protocol {

    private final Protocol protocol;

    public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException(&amp;quot;protocol == null&amp;quot;);
        }
        this.protocol = protocol;
    }

    @Override
    public &amp;lt;T&amp;gt; Exporter&amp;lt;T&amp;gt; export(Invoker&amp;lt;T&amp;gt; invoker) throws RpcException {
        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {
            return protocol.export(invoker);
        }
        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));
    }

    @Override
    public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; refer(Class&amp;lt;T&amp;gt; type, URL url) throws RpcException {
        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
            return protocol.refer(type, url);
        }
        return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而有关于通过Wrappe类加强的逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses = cachedWrapperClasses;
if (wrapperClasses != null &amp;amp;&amp;amp; !wrapperClasses.isEmpty()) {
    for (Class&amp;lt;?&amp;gt; wrapperClass : wrapperClasses) {
        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是将所有的Wrapper类包装在原始的扩展实现类上，在调用的时候，就会先执行所有Wrapper中对应的逻辑，然后再执行真正扩展实现类的逻辑。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://www.spilledyear.cn/post/mybatis/</link>
      <pubDate>Sun, 19 Aug 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/mybatis/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/089.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本文主要对Mybatis中启动流程、Mapper解析、Mapper代理、四大对象、SQL执行、缓存、插件、与Sprin整合等相关内容进行解析，文章较长，能力有限，有问题麻烦指出，谢谢。关于调试方面，可以直接从Github上下载Mybatis源码，里面包含很多测试代码，下载下来安装依赖就可以直接运行，当然也可以直接通过IDEA关联源码，也比较方便。原创文章，转载请标明出处！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网上找到的一张Mybatis架构图：
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-5104f4e812fe7621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Mybatis&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;启动&#34;&gt;启动&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;public class Application {
    public static void main(String[] args) throws Exception{
        // 1、加载配置文件
        InputStream is = Resources.getResourceAsStream(&amp;quot;application.xml&amp;quot;);

        // 2、构建SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

        // 3、获取SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User user = mapper.selectByUserName(&amp;quot;admin&amp;quot;);
        System.err.println(user);
        sqlSession.commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从xml配置文件中读取配置，然后通过SqlSessionFactoryBuilder构建SqlSessionFactory实例(建造者模式)。&lt;strong&gt;SqlSessionFactory是Mybatis的关键对象，它是个单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory是创建SqlSession的工厂，每一个Mybatis的应用程序都以一个SqlSessionFactory对象的实例为核心，同时SqlSessionFactory也是线程安全的，SqlSessionFactory一旦被创建，在应用执行期间都存在。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有关于SqlSessionFactoryBuilder的build方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
  try {

    XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&amp;quot;Error building SqlSession.&amp;quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      reader.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}
public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}

public XMLConfigBuilder(Reader reader, String environment, Properties props) {
  // 在创建XMLConfigBuilder对象之前，创建了一个XPathParser对象，XPathParser用来解析xml文件。即：在构建XMLConfigBuilder之后，即完成了xml文件到dcument对象的转化
  this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props);
}
private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {
  // 创建Configuration对象
  super(new Configuration());
  ErrorContext.instance().resource(&amp;quot;SQL Mapper Configuration&amp;quot;);
  this.configuration.setVariables(props);
  this.parsed = false;
  this.environment = environment;
  this.parser = parser;
}

public XPathParser(Reader reader, boolean validation, Properties variables, EntityResolver entityResolver) {
  commonConstructor(validation, variables, entityResolver);
  // 创建document对象
  this.document = createDocument(new InputSource(reader));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的代码中，我们重点关注两个东西：一个是XPathParser对象，在创建XPathParser对象的时候会将xml文件转换成document对象；两外一个是Configuration对象，在XMLConfigBuilder对象的构造方法内创建了Configuration对象。
Configuration对象是Myatis中非常非常重要的一个概念，它的作用就相当于是servlet中的ServletContext、spring中的容器，它就是Mybatis的中的Boss，Mybatis的运行就是依赖于这个对象。我们在xml文件中的一些配置，解析之后的mappedStatement等等等等，都维护在这个对像中，非常非常重要的一个对象。所以，有必要对这个对象有个简单的了解：&lt;/p&gt;

&lt;p&gt;可以看到，Configuration有非常多的属性，每个属性都很重要，有关于每个属性的具体用途，这里没办法具体介绍，在接下来的源码解析中会慢慢接触到。可以看出，它的构造方法主要是设置了一些别名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Environment environment;

protected boolean safeRowBoundsEnabled;
protected boolean safeResultHandlerEnabled = true;
protected boolean mapUnderscoreToCamelCase;
protected boolean aggressiveLazyLoading;
protected boolean multipleResultSetsEnabled = true;
protected boolean useGeneratedKeys;
protected boolean useColumnLabel = true;
protected boolean cacheEnabled = true;
protected boolean callSettersOnNulls;
protected boolean useActualParamName = true;
protected boolean returnInstanceForEmptyRow;

protected String logPrefix;
protected Class &amp;lt;? extends Log&amp;gt; logImpl;
protected Class &amp;lt;? extends VFS&amp;gt; vfsImpl;
protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;
protected JdbcType jdbcTypeForNull = JdbcType.OTHER;
protected Set&amp;lt;String&amp;gt; lazyLoadTriggerMethods = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(new String[] { &amp;quot;equals&amp;quot;, &amp;quot;clone&amp;quot;, &amp;quot;hashCode&amp;quot;, &amp;quot;toString&amp;quot; }));
protected Integer defaultStatementTimeout;
protected Integer defaultFetchSize;
protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;
protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;
protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;

protected Properties variables = new Properties();
protected ReflectorFactory reflectorFactory = new DefaultReflectorFactory();
protected ObjectFactory objectFactory = new DefaultObjectFactory();
protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();

protected boolean lazyLoadingEnabled = false;
protected ProxyFactory proxyFactory = new JavassistProxyFactory(); // #224 Using internal Javassist instead of OGNL

protected String databaseId;
protected Class&amp;lt;?&amp;gt; configurationFactory;

// 用于注册mapper，这个对象中缓存了所有mapper接口的代理对象
protected final MapperRegistry mapperRegistry = new MapperRegistry(this);

// 拦截器链
protected final InterceptorChain interceptorChain = new InterceptorChain();

protected final TypeHandlerRegistry typeHandlerRegistry = new TypeHandlerRegistry();
protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();
protected final LanguageDriverRegistry languageRegistry = new LanguageDriverRegistry();

// mapper.xml 中的每个方法对应一个 MappedStatement，重点关注
protected final Map&amp;lt;String, MappedStatement&amp;gt; mappedStatements = new StrictMap&amp;lt;MappedStatement&amp;gt;(&amp;quot;Mapped Statements collection&amp;quot;);

protected final Map&amp;lt;String, Cache&amp;gt; caches = new StrictMap&amp;lt;Cache&amp;gt;(&amp;quot;Caches collection&amp;quot;);
protected final Map&amp;lt;String, ResultMap&amp;gt; resultMaps = new StrictMap&amp;lt;ResultMap&amp;gt;(&amp;quot;Result Maps collection&amp;quot;);
protected final Map&amp;lt;String, ParameterMap&amp;gt; parameterMaps = new StrictMap&amp;lt;ParameterMap&amp;gt;(&amp;quot;Parameter Maps collection&amp;quot;);
protected final Map&amp;lt;String, KeyGenerator&amp;gt; keyGenerators = new StrictMap&amp;lt;KeyGenerator&amp;gt;(&amp;quot;Key Generators collection&amp;quot;);

protected final Set&amp;lt;String&amp;gt; loadedResources = new HashSet&amp;lt;String&amp;gt;();
protected final Map&amp;lt;String, XNode&amp;gt; sqlFragments = new StrictMap&amp;lt;XNode&amp;gt;(&amp;quot;XML fragments parsed from previous mappers&amp;quot;);

protected final Collection&amp;lt;XMLStatementBuilder&amp;gt; incompleteStatements = new LinkedList&amp;lt;XMLStatementBuilder&amp;gt;();
protected final Collection&amp;lt;CacheRefResolver&amp;gt; incompleteCacheRefs = new LinkedList&amp;lt;CacheRefResolver&amp;gt;();
protected final Collection&amp;lt;ResultMapResolver&amp;gt; incompleteResultMaps = new LinkedList&amp;lt;ResultMapResolver&amp;gt;();
protected final Collection&amp;lt;MethodResolver&amp;gt; incompleteMethods = new LinkedList&amp;lt;MethodResolver&amp;gt;();


public Configuration() {
  typeAliasRegistry.registerAlias(&amp;quot;JDBC&amp;quot;, JdbcTransactionFactory.class);
  typeAliasRegistry.registerAlias(&amp;quot;MANAGED&amp;quot;, ManagedTransactionFactory.class);

  typeAliasRegistry.registerAlias(&amp;quot;JNDI&amp;quot;, JndiDataSourceFactory.class);
  typeAliasRegistry.registerAlias(&amp;quot;POOLED&amp;quot;, PooledDataSourceFactory.class);
  typeAliasRegistry.registerAlias(&amp;quot;UNPOOLED&amp;quot;, UnpooledDataSourceFactory.class);

  typeAliasRegistry.registerAlias(&amp;quot;PERPETUAL&amp;quot;, PerpetualCache.class);
  typeAliasRegistry.registerAlias(&amp;quot;FIFO&amp;quot;, FifoCache.class);
  typeAliasRegistry.registerAlias(&amp;quot;LRU&amp;quot;, LruCache.class);
  typeAliasRegistry.registerAlias(&amp;quot;SOFT&amp;quot;, SoftCache.class);
  typeAliasRegistry.registerAlias(&amp;quot;WEAK&amp;quot;, WeakCache.class);

  typeAliasRegistry.registerAlias(&amp;quot;DB_VENDOR&amp;quot;, VendorDatabaseIdProvider.class);

  typeAliasRegistry.registerAlias(&amp;quot;XML&amp;quot;, XMLLanguageDriver.class);
  typeAliasRegistry.registerAlias(&amp;quot;RAW&amp;quot;, RawLanguageDriver.class);

  typeAliasRegistry.registerAlias(&amp;quot;SLF4J&amp;quot;, Slf4jImpl.class);
  typeAliasRegistry.registerAlias(&amp;quot;COMMONS_LOGGING&amp;quot;, JakartaCommonsLoggingImpl.class);
  typeAliasRegistry.registerAlias(&amp;quot;LOG4J&amp;quot;, Log4jImpl.class);
  typeAliasRegistry.registerAlias(&amp;quot;LOG4J2&amp;quot;, Log4j2Impl.class);
  typeAliasRegistry.registerAlias(&amp;quot;JDK_LOGGING&amp;quot;, Jdk14LoggingImpl.class);
  typeAliasRegistry.registerAlias(&amp;quot;STDOUT_LOGGING&amp;quot;, StdOutImpl.class);
  typeAliasRegistry.registerAlias(&amp;quot;NO_LOGGING&amp;quot;, NoLoggingImpl.class);

  typeAliasRegistry.registerAlias(&amp;quot;CGLIB&amp;quot;, CglibProxyFactory.class);
  typeAliasRegistry.registerAlias(&amp;quot;JAVASSIST&amp;quot;, JavassistProxyFactory.class);

  languageRegistry.setDefaultDriverClass(XMLLanguageDriver.class);
  languageRegistry.register(RawLanguageDriver.class);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;配置文件&#34;&gt;配置文件&lt;/h1&gt;

&lt;p&gt;构建document对象之后就是对document对象进行解析，在解析之前，我们很必要了解一下Mybatis中的配置文件。相对于Spring这个大家伙来说，Mybatis的配置文件简单太多了，就10来个，很好理解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mybatis详细配置：http://www.mybatis.org/mybatis-3/zh/configuration.html

1、properties
有两种方式配置，一种是通过\&amp;lt;property&amp;gt;标签；还有一种是通过properties配置文件。
  &amp;lt;!-- 方法一： 从外部指定properties配置文件, 除了使用resource属性指定外，还可通过url属性指定url--&amp;gt;
  &amp;lt;properties resource=&amp;quot;application.properties&amp;quot; &amp;gt;&amp;lt;/properties&amp;gt;

  &amp;lt;!-- 方法二： 直接配置为xml --&amp;gt;
  &amp;lt;properties&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;/&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;jdbc:mysql://localhost:3306/vue?characterEncoding=utf&amp;amp;autoReconnect=true&amp;amp;useSSL=false&amp;quot;/&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;--&amp;gt;
      &amp;lt;!--&amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;root&amp;quot;/&amp;gt;--&amp;gt;
  &amp;lt;!--&amp;lt;/properties&amp;gt;

然后其中的属性就可以在整个配置文件中被用来替换需要动态配置的属性值。比如:
  &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
  &amp;lt;/dataSource&amp;gt;
  



2、settings
这是MyBatis中极为重要的调整设置，它们会改变MyBatis的运行时行为。其实这个主要就是改变Configuration对象中属性的值
  &amp;lt;settings&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;lazyLoadingEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;multipleResultSetsEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;useColumnLabel&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;useGeneratedKeys&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;autoMappingBehavior&amp;quot; value=&amp;quot;PARTIAL&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;autoMappingUnknownColumnBehavior&amp;quot; value=&amp;quot;WARNING&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;defaultExecutorType&amp;quot; value=&amp;quot;SIMPLE&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;defaultStatementTimeout&amp;quot; value=&amp;quot;25&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;defaultFetchSize&amp;quot; value=&amp;quot;100&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;safeRowBoundsEnabled&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;mapUnderscoreToCamelCase&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;localCacheScope&amp;quot; value=&amp;quot;SESSION&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;jdbcTypeForNull&amp;quot; value=&amp;quot;OTHER&amp;quot;/&amp;gt;
    &amp;lt;setting name=&amp;quot;lazyLoadTriggerMethods&amp;quot; value=&amp;quot;equals,clone,hashCode,toString&amp;quot;/&amp;gt;
  &amp;lt;/settings&amp;gt;




3、typeAliases
类型别名是为Java类型设置一个短的名字，比如我们在mapper.xml文件中返回一个类型com.hand.sxy.Student，这么长一大串，这时候就可以为 &amp;quot;com.hand.sxy.Student&amp;quot;设置一个别名，比如student，当这样配置后，student可以用在任何使用com.hand.sxy.Student的地方，主要是为了方便
  &amp;lt;typeAliases&amp;gt;
    &amp;lt;typeAlias alias=&amp;quot;student&amp;quot; type=&amp;quot;com.hand.sxy.Student&amp;quot;/&amp;gt;
  &amp;lt;/typeAliases&amp;gt;

也可以为一个包下面的类一起设置别名，这时候别名的名称就 将类名的首字母变小写
  &amp;lt;typeAliases&amp;gt;
    &amp;lt;package name=&amp;quot;com.hand.sxy.Student&amp;quot;/&amp;gt;
  &amp;lt;/typeAliases&amp;gt;

同时，还可以使用注解为其设置别名
  @Alias(&amp;quot;student&amp;quot;)
  public class Student {
      ...
  }
Mybatis总默认配置了很多别名




4、typeHandlers
无论是MyBatis在预处理语句(PreparedStatement)中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成Java类型，Mybatis中也预置了一些映射关系。可以重写类型处理器或创建类型处理器来处理不支持的或非标准的类型, 具体做法为：实现 org.apache.ibatis.type.TypeHandler接口，或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler，然后可以选择性地将它映射到一个JDBC类型，比如：
  @MappedJdbcTypes(JdbcType.VARCHAR)
  public class ExampleTypeHandler extends BaseTypeHandler&amp;lt;String&amp;gt; {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
      ps.setString(i, parameter);
    }

    @Override
    public String getNullableResult(ResultSet rs, String columnName) throws SQLException {
      return rs.getString(columnName);
    }

    @Override
    public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
      return rs.getString(columnIndex);
    }

    @Override
    public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
      return cs.getString(columnIndex);
    }
  }




5、对象工厂(objectFactory)
MyBatis每次创建结果对象的新实例时，它都会使用一个对象工厂(ObjectFactory)实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现
  public class ExampleObjectFactory extends DefaultObjectFactory {
    public Object create(Class type) {
      return super.create(type);
    }
    public Object create(Class type, List&amp;lt;Class&amp;gt; constructorArgTypes, List&amp;lt;Object&amp;gt; constructorArgs) {
      return super.create(type, constructorArgTypes, constructorArgs);
    }
    public void setProperties(Properties properties) {
      super.setProperties(properties);
    }
    public &amp;lt;T&amp;gt; boolean isCollection(Class&amp;lt;T&amp;gt; type) {
      return Collection.class.isAssignableFrom(type);
    }
  }
  &amp;lt;objectFactory type=&amp;quot;org.mybatis.example.ExampleObjectFactory&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;someProperty&amp;quot; value=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/objectFactory&amp;gt;
ObjectFactory接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。最后，setProperties方法可以被用来配置ObjectFactory，在初始化你的 ObjectFactory实例后， objectFactory元素体中定义的属性会被传递给setProperties方法。




6、插件(plugins)
Mybatis允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，Mybatis允许使用插件来拦截的方法调用包括：
  Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
  ParameterHandler (getParameterObject, setParameters)
  ResultSetHandler (handleResultSets, handleOutputParameters)
  StatementHandler (prepare, parameterize, batch, update, query)
有关于插件的使用，不过多说明，之后会详细介绍和插件相关的内容。




7、配置环境(environments)
可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中。不过要记住：尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一，所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个；而如果是三个数据库，就需要三个SqlSessionFactory实例。
  &amp;lt;environments default=&amp;quot;development&amp;quot;&amp;gt;
    &amp;lt;environment id=&amp;quot;development&amp;quot;&amp;gt;
      &amp;lt;transactionManager type=&amp;quot;JDBC&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;...&amp;quot; value=&amp;quot;...&amp;quot;/&amp;gt;
      &amp;lt;/transactionManager&amp;gt;
      &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
      &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
  &amp;lt;/environments&amp;gt;




8、事务管理器(transactionManager)
在Mybatis中有两种类型的事务管理器(也就是 type=&amp;quot;[JDBC|MANAGED]&amp;quot;)：
JDBC：这个配置就是直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。
MANAGED：这个配置几乎没做什么，它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期(比如 JEE 应用服务器的上下文)。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection属性设置为false 来阻止它默认的关闭行为。例如:
  &amp;lt;transactionManager type=&amp;quot;MANAGED&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;closeConnection&amp;quot; value=&amp;quot;false&amp;quot;/&amp;gt;
  &amp;lt;/transactionManager&amp;gt;
如果你正在使用Spring + Mybatis，则没有必要配置事务管理器， 因为 Spring 模块会使用自带的管理器来覆盖前面的配置




9、数据源(dataSource)
dataSource 元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源，有三种内建的数据源类型（也就是 type=&amp;quot;[UNPOOLED|POOLED|JNDI]&amp;quot;）：
UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接,即不使用连接池。
POOLED：使用连接池，这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。
JNDI：这个数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用。
  &amp;lt;dataSource type=&amp;quot;POOLED&amp;quot;&amp;gt;
      &amp;lt;!-- 上面指定了数据库配置文件， 配置文件里面也是对应的这四个属性 --&amp;gt;
      &amp;lt;property name=&amp;quot;driver&amp;quot; value=&amp;quot;${driver}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${url}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${username}&amp;quot;/&amp;gt;
      &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${password}&amp;quot;/&amp;gt;
  &amp;lt;/dataSource&amp;gt;
有关于三种数据源的具体介绍，可以在上文给出的链接中查看。  



10、databaseIdProvider
Mybatis可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId属性。MyBatis会加载不带databaseId属性和带有匹配当前数据库databaseId属性的所有语句，如果同时找到带有databaseId和不带databaseId的相同语句，则后者会被舍弃
  &amp;lt;databaseIdProvider type=&amp;quot;DB_VENDOR&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;SQL Server&amp;quot; value=&amp;quot;sqlserver&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;DB2&amp;quot; value=&amp;quot;db2&amp;quot;/&amp;gt;        
    &amp;lt;property name=&amp;quot;Oracle&amp;quot; value=&amp;quot;oracle&amp;quot; /&amp;gt;
  &amp;lt;/databaseIdProvider&amp;gt;




11、映射器(mappers)
告诉Mybatis去哪里查找SQL映射语句，可以告诉xml文件位置，也可以告诉mapper接口位置
  &amp;lt;!-- 使用相对于类路径的资源引用 --&amp;gt;
  &amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/AuthorMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/BlogMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;mapper resource=&amp;quot;org/mybatis/builder/PostMapper.xml&amp;quot;/&amp;gt;
  &amp;lt;/mappers&amp;gt;
对于xml文件，也可以使用url属性
  &amp;lt;!-- 使用完全限定资源定位符（URL）， --&amp;gt;
  &amp;lt;mappers&amp;gt;
    &amp;lt;mapper url=&amp;quot;file:///var/mappers/AuthorMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;mapper url=&amp;quot;file:///var/mappers/BlogMapper.xml&amp;quot;/&amp;gt;
    &amp;lt;mapper url=&amp;quot;file:///var/mappers/PostMapper.xml&amp;quot;/&amp;gt;
  &amp;lt;/mappers&amp;gt;

  &amp;lt;!-- 使用映射器接口实现类的完全限定类名 --&amp;gt;
  &amp;lt;mappers&amp;gt;
    &amp;lt;mapper class=&amp;quot;org.mybatis.builder.AuthorMapper&amp;quot;/&amp;gt;
    &amp;lt;mapper class=&amp;quot;org.mybatis.builder.BlogMapper&amp;quot;/&amp;gt;
    &amp;lt;mapper class=&amp;quot;org.mybatis.builder.PostMapper&amp;quot;/&amp;gt;
  &amp;lt;/mappers&amp;gt;

注意，下面这种方式定义一个包名，该包内的所有接口都会注册为映射器，但是这有一个要求，那就是项目经过编译之后，xml文件和mapper接口必须同名，且在同一个目录下
  &amp;lt;!-- 将包内的映射器接口实现全部注册为映射器 --&amp;gt;
  &amp;lt;mappers&amp;gt;
    &amp;lt;package name=&amp;quot;org.mybatis.builder&amp;quot;/&amp;gt;
  &amp;lt;/mappers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面我们简单的了解了一下Mybatis配置文件，接下来就是对该配置文件的解析过程了，也就是上面代码中的parser.parse()方法，这算是一个比较复杂的过程，在执行该方法之后，就构造了Mybatis中最为重要的Configuration对象，下面着重分析这个方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Configuration parse() {
  // 只需要解析一次
  if (parsed) {
    throw new BuilderException(&amp;quot;Each XMLConfigBuilder can only be used once.&amp;quot;);
  }
  parsed = true;
  // 获取到xml文件中&amp;lt;configuration&amp;gt;&amp;lt;/configuration&amp;gt;中的所有内容
  parseConfiguration(parser.evalNode(&amp;quot;/configuration&amp;quot;));
  return configuration;
}

// 各个标签的解析，可以很直接的看出来每个标签对应的解析方法
private void parseConfiguration(XNode root) {
  try {
    propertiesElement(root.evalNode(&amp;quot;properties&amp;quot;));
    Properties settings = settingsAsProperties(root.evalNode(&amp;quot;settings&amp;quot;));
    loadCustomVfs(settings);
    typeAliasesElement(root.evalNode(&amp;quot;typeAliases&amp;quot;));
    pluginElement(root.evalNode(&amp;quot;plugins&amp;quot;));
    objectFactoryElement(root.evalNode(&amp;quot;objectFactory&amp;quot;));
    objectWrapperFactoryElement(root.evalNode(&amp;quot;objectWrapperFactory&amp;quot;));
    reflectorFactoryElement(root.evalNode(&amp;quot;reflectorFactory&amp;quot;));
    settingsElement(settings);
    environmentsElement(root.evalNode(&amp;quot;environments&amp;quot;));
    databaseIdProviderElement(root.evalNode(&amp;quot;databaseIdProvider&amp;quot;));
    typeHandlerElement(root.evalNode(&amp;quot;typeHandlers&amp;quot;));
    mapperElement(root.evalNode(&amp;quot;mappers&amp;quot;));
  } catch (Exception e) {
    throw new BuilderException(&amp;quot;Error parsing SQL Mapper Configuration. Cause: &amp;quot; + e, e);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在我们实际工作中，和Mapper打交道最多，接下来就将工作重心放到Mapper的解析上吧。&lt;/p&gt;

&lt;h1 id=&#34;mapper解析&#34;&gt;Mapper解析&lt;/h1&gt;

&lt;p&gt;XMLConfigBuilder # mapperElement&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void mapperElement(XNode parent) throws Exception {
  if (parent != null) {
    for (XNode child : parent.getChildren()) {
      // 如果配置文件中的mapper是以package的形式指定的，这里主要分析这种方式
      if (&amp;quot;package&amp;quot;.equals(child.getName())) {
        // 获取到包名
        String mapperPackage = child.getStringAttribute(&amp;quot;name&amp;quot;);
        configuration.addMappers(mapperPackage);
      } else {
        // 非package方式，说明指明了具体的mapper接口或者xml文件
        String resource = child.getStringAttribute(&amp;quot;resource&amp;quot;);
        String url = child.getStringAttribute(&amp;quot;url&amp;quot;);
        String mapperClass = child.getStringAttribute(&amp;quot;class&amp;quot;);
        if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(resource);
          InputStream inputStream = Resources.getResourceAsStream(resource);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
          mapperParser.parse();
        } else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
          ErrorContext.instance().resource(url);
          InputStream inputStream = Resources.getUrlAsStream(url);
          XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
          mapperParser.parse();
        } else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
          Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
          configuration.addMapper(mapperInterface);
        } else {
          throw new BuilderException(&amp;quot;A mapper element may only specify a url, resource or class, but not more than one.&amp;quot;);
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里其实涉及到Mapper的配置方式，可以通过package的形式配置一个包下的所有接口，或者不以package的形式指明具体的mapper接口。我们在工作中主要是通过package的方式指明接口的位置，所以重点关注configuration.addMappers(mapperPackage)方法：&lt;/p&gt;

&lt;p&gt;Configuration # addMappers&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final MapperRegistry mapperRegistry = new MapperRegistry(this);

public void addMappers(String packageName) {
  mapperRegistry.addMappers(packageName);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以发现，这里引出了一个新对象：MapperRegistry，这是一个挺重要的对象，以下是其源码，非核心代码我已删除&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperRegistry {
  private final Configuration config;

  // 缓存，每个Mapper接口对应一个 MapperProxyFactory
  private final Map&amp;lt;Class&amp;lt;?&amp;gt;, MapperProxyFactory&amp;lt;?&amp;gt;&amp;gt; knownMappers = new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, MapperProxyFactory&amp;lt;?&amp;gt;&amp;gt;();

  public MapperRegistry(Configuration config) {
    this.config = config;
  }

  @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
  public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
    final MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;) knownMappers.get(type);
    if (mapperProxyFactory == null) {
      throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is not known to the MapperRegistry.&amp;quot;);
    }
    try {
      return mapperProxyFactory.newInstance(sqlSession);
    } catch (Exception e) {
      throw new BindingException(&amp;quot;Error getting mapper instance. Cause: &amp;quot; + e, e);
    }
  }
  
  public &amp;lt;T&amp;gt; boolean hasMapper(Class&amp;lt;T&amp;gt; type) {
    return knownMappers.containsKey(type);
  }

  public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) {
    if (type.isInterface()) {
      if (hasMapper(type)) {
        throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is already known to the MapperRegistry.&amp;quot;);
      }
      boolean loadCompleted = false;
      try {
        knownMappers.put(type, new MapperProxyFactory&amp;lt;T&amp;gt;(type));
        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
        parser.parse();
        loadCompleted = true;
      } finally {
        if (!loadCompleted) {
          knownMappers.remove(type);
        }
      }
    }
  }

  public Collection&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; getMappers() {
    return Collections.unmodifiableCollection(knownMappers.keySet());
  }

  public void addMappers(String packageName, Class&amp;lt;?&amp;gt; superType) {
    ResolverUtil&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; resolverUtil = new ResolverUtil&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set&amp;lt;Class&amp;lt;? extends Class&amp;lt;?&amp;gt;&amp;gt;&amp;gt; mapperSet = resolverUtil.getClasses();
    for (Class&amp;lt;?&amp;gt; mapperClass : mapperSet) {
      addMapper(mapperClass);
    }
  }

  public void addMappers(String packageName) {
    addMappers(packageName, Object.class);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用Mybatis这个框架的时候，我们往往只是定义了一些Mapper接口和一些XML文件，并没有写实现类，却可以直接调用方法，很明显是Mybatis为我们生成了代理。在上面的代码中，我们注意到上面的代码中MapperProxyFactory这么一个类，根据名字也可以猜测的到这是一个工厂类，用来创建Mapper接口的代理类。事实就是这样，可以看看MapperProxyFactory的源码&lt;/p&gt;

&lt;p&gt;很明显newInstance方法中使用了JDK动态代理创建代理类，除此之外，这里还引如了一个MapperProxy对象，我们大概可以猜测到MapperProxy实现了InvocationHandler接口并重写了invoke方法，有关于这一块内容我们等下再来验证，目前可以确定的MapperProxyFactory是创建代理类的工厂，MapperProxy是创建代理类的关键,它是实现了InvocationHandler接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperProxyFactory&amp;lt;T&amp;gt; {
  private final Class&amp;lt;T&amp;gt; mapperInterface;
  private final Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = new ConcurrentHashMap&amp;lt;Method, MapperMethod&amp;gt;();

  public MapperProxyFactory(Class&amp;lt;T&amp;gt; mapperInterface) {
    this.mapperInterface = mapperInterface;
  }

  public Class&amp;lt;T&amp;gt; getMapperInterface() {
    return mapperInterface;
  }

  public Map&amp;lt;Method, MapperMethod&amp;gt; getMethodCache() {
    return methodCache;
  }

  // JDK动态代理，MapperProxy类实现了InvocationHandler接口
  @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
  protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
  }

  public T newInstance(SqlSession sqlSession) {
    final MapperProxy&amp;lt;T&amp;gt; mapperProxy = new MapperProxy&amp;lt;T&amp;gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，综合我们对这两个类的观察，MapperRegistry类用于Mapper接口注册，当我们调用它的addMapperf方法的时候，会为该Mapper接口创建一个MapperProxyFactory对象，并缓存在一个Map中。而MapperProxyFactory主要用于创建代理对象，在创建代理对象的时候，用到了MapperProxy这个类，它是是实现了InvocationHandler接口，所以可以推断出，在调用Mapper方法时候，实际上是调用MapperProxy的invoke方法。
在了解了MapperRegistry类的大体流程之后，我们继续回到MapperRegistry的addMapper方法，该方法大概做了两件事情，一个是创建MapperProxyFactory对象并缓存起来；另一个就是执行Mapper解析。这里调用了MapperAnnotationBuilder的parse方法，根据名字应该可以猜测的到这是和注解的解析相关&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;T&amp;gt; void addMapper(Class&amp;lt;T&amp;gt; type) {
  if (type.isInterface()) {
    if (hasMapper(type)) {
      throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is already known to the MapperRegistry.&amp;quot;);
    }
    boolean loadCompleted = false;
    try {
      // 添加到缓存，每个Mapper接口对应一个 MapperProxyFactory
      knownMappers.put(type, new MapperProxyFactory&amp;lt;T&amp;gt;(type));

      // 下面两行代码是对Mapper的解析
      // It&#39;s important that the type is added before the parser is run
      // otherwise the binding may automatically be attempted by the
      // mapper parser. If the type is already known, it won&#39;t try.
      MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);
      parser.parse();

      loadCompleted = true;
    } finally {
      if (!loadCompleted) {
        knownMappers.remove(type);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;事实上，MapperAnnotationBuilder的作用就是解析Mapper接口中定义的注解，并生成Cache、ResultMap、MappedStatement三种类型对象。在创建一个的时候，会关联一个MapperBuilderAssistant对象，这是一个构建助理，实际上，真正将接口中的方法转换成MappedStatement对象就是通过MapperBuilderAssistant对象完成的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public MapperAnnotationBuilder(Configuration configuration, Class&amp;lt;?&amp;gt; type) {
  String resource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &amp;quot;.java (best guess)&amp;quot;;

  // MapperBuilderAssistant类执行真正的解析操作
  this.assistant = new MapperBuilderAssistant(configuration, resource);
  this.configuration = configuration;
  this.type = type;

  // 下面就是Mybatis中的常见注解，下面那4个可用于实现通用Mapper
  sqlAnnotationTypes.add(Select.class);
  sqlAnnotationTypes.add(Insert.class);
  sqlAnnotationTypes.add(Update.class);
  sqlAnnotationTypes.add(Delete.class);

  sqlProviderAnnotationTypes.add(SelectProvider.class);
  sqlProviderAnnotationTypes.add(InsertProvider.class);
  sqlProviderAnnotationTypes.add(UpdateProvider.class);
  sqlProviderAnnotationTypes.add(DeleteProvider.class);
}

public void parse() {
  // 例：resource = &amp;quot;interface com.hand.sxy.mapper.UserMapper&amp;quot;
  String resource = type.toString();

  // loadedResources是configuration对象中的一个属性，是一个Set集合，用于缓存已解析过的Mapper
  if (!configuration.isResourceLoaded(resource)) {

    // 先对 Mapper.xml 文件进行解析
    loadXmlResource();

    // 添加到loadedResources缓存，Key为class对应的全类名
    configuration.addLoadedResource(resource);

    // 设置MapperBuilderAssistant的命名空间 
    assistant.setCurrentNamespace(type.getName());

    // 解析缓存对象
    parseCache();

    // 解析缓存引用
    parseCacheRef();
    Method[] methods = type.getMethods();
    for (Method method : methods) {
      try {
        // 这里涉及到桥接方法，关系到Java的泛型擦除，具体参考 https://www.zhihu.com/question/54895701/answer/141623158
        if (!method.isBridge()) {

          // 解析MappedStatement和ResultMap
          parseStatement(method);
        }
      } catch (IncompleteElementException e) {
        configuration.addIncompleteMethod(new MethodResolver(this, method));
      }
    }
  }

  // 遍历configuration的IncompleteMethods集合，重新解析MethodResolver
  parsePendingMethods();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面涉及到的内容还挺多，接下里一个个解释一下吧&lt;/p&gt;

&lt;h3 id=&#34;loadxmlresource&#34;&gt;loadXmlResource&lt;/h3&gt;

&lt;p&gt;这个方法主要就是解析Mapper.xml文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void loadXmlResource() {
  // Spring may not know the real resource name so we check a flag
  // to prevent loading again a resource twice
  // this flag is set at XMLMapperBuilder#bindMapperForNamespace
  // 对于已解析过的Mapper.xml文件，会缓存起来。这里为什么要通过 namespace: + 全类名的 方式来缓存呢？因为namespace指定的是一个具体的Mapper接口，而在每个Mapper.xml文件解析之后，会将该对应的
  // 内容缓存起来，如：configuration.addLoadedResource(&amp;quot;namespace:&amp;quot; + namespace)、configuration.addMapper(boundType)。可以认为&amp;quot;namespace:&amp;quot; + namespace标识着一个Mapper.xml文件，即每解析完一个Mapper.xml文件，都会缓存起该Mapper.xml文件和namespace对应的接口
  if (!configuration.isResourceLoaded(&amp;quot;namespace:&amp;quot; + type.getName())) {
    // 通过对全类名中的 . 替换成 / 得到下 Maper.xml 文件路径，所以这也就要求 使用package的方式时， Mapper.xml 文件 和 Mapper接口名必须相同且在相同目录
    // xmlResource = &amp;quot;com/hand/sxy/mapper/UserMapper.xml&amp;quot;
    String xmlResource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &amp;quot;.xml&amp;quot;;

    InputStream inputStream = null;
    try {
      // 获取到xml文件输入流
      inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);
    } catch (IOException e) {
      // ignore, resource is not required
    }
    if (inputStream != null) {
      XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());

      // 通过XMLMapperBuilder进行解析，如果是不是通过package而是直接配置Mapper.xml文件的方式，就会直接执行下面XMLMapperBuilder的parse方法
      xmlParser.parse();
    }
  }
}

public void parse() {
  // 例：resource =  &amp;quot;com/hand/sxy/mapper/UserMapper.xml&amp;quot;，为什么这里又要判断一次，因为当不是通过package或者不是配置Mapper接口的方式，而是配置Mapper.xml文件的方式，会直接执行这个方法
  if (!configuration.isResourceLoaded(resource)) {
    // 真正的解析逻辑
    configurationElement(parser.evalNode(&amp;quot;/mapper&amp;quot;));

    // 添加到缓存
    configuration.addLoadedResource(resource);

    // 将已经解析完的Mapper.xml文件标识和对应对应的Mapper接口标识缓存起来，Mapper.xml文件用&amp;quot;namespace:&amp;quot; + namespace表示；Mapper接口用全类名表示。
    bindMapperForNamespace();
  }

  // 残缺不全的重新解析一遍？不太懂这里是为了处理什么情况
  parsePendingResultMaps();
  parsePendingCacheRefs();
  parsePendingStatements();
}

private void configurationElement(XNode context) {
  try {
    // 获取命名空间， 即全类名
    String namespace = context.getStringAttribute(&amp;quot;namespace&amp;quot;);
    if (namespace == null || namespace.equals(&amp;quot;&amp;quot;)) {
      throw new BuilderException(&amp;quot;Mapper&#39;s namespace cannot be empty&amp;quot;);
    }
    // 设置当前namespace
    builderAssistant.setCurrentNamespace(namespace);

    /** 以下用于处理各个标签的解析，详情请看：http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html#*/

    // 用于启用本xml对应的namespace的二级缓存  &amp;lt;cache-ref namespace=&amp;quot;com.someone.application.data.SomeMapper&amp;quot;/&amp;gt;
    cacheRefElement(context.evalNode(&amp;quot;cache-ref&amp;quot;));

    // 共享指定namespace的二级缓存  &amp;lt;cache  eviction=&amp;quot;FIFO&amp;quot;  flushInterval=&amp;quot;60000&amp;quot;  size=&amp;quot;512&amp;quot;  readOnly=&amp;quot;true&amp;quot;/&amp;gt;
    cacheElement(context.evalNode(&amp;quot;cache&amp;quot;));

    parameterMapElement(context.evalNodes(&amp;quot;/mapper/parameterMap&amp;quot;));

    // 进行数据库列和返回Java对象的属性之间的映射 
    resultMapElements(context.evalNodes(&amp;quot;/mapper/resultMap&amp;quot;));

    // 可被其他语句引用的可重用sql语句块
    sqlElement(context.evalNodes(&amp;quot;/mapper/sql&amp;quot;));

    // 增删改查映射语句
    buildStatementFromContext(context.evalNodes(&amp;quot;select|insert|update|delete&amp;quot;));
  } catch (Exception e) {
    throw new BuilderException(&amp;quot;Error parsing Mapper XML. Cause: &amp;quot; + e, e);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分别对应Mapper.xml文件中的不同标签，很多都是我们常见的，比如：resultMap、sql、select 等等。每个标签的解析对应不同的方法，虽然这些都是XMLStatementBuilder类中的方法，&lt;strong&gt;但实际上将各个标签解析为Mybatis中对应的类时，都是通过MapperBuilderAssistant这个助理解析类来完成的&lt;/strong&gt;。这里就简单分析一下resultMapElements 和 buildStatementFromContext 这个两个方法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;resultMapElements&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void resultMapElements(List&amp;lt;XNode&amp;gt; list) throws Exception {
  // 每个XNode就代表一个 &amp;lt;resultMap&amp;gt;， &amp;lt;resultMap&amp;gt;可以有多个
  for (XNode resultMapNode : list) {
    try {
      resultMapElement(resultMapNode);
    } catch (IncompleteElementException e) {
      // ignore, it will be retried
    }
  }
}

private ResultMap resultMapElement(XNode resultMapNode) throws Exception {
  // 每次解析一个 &amp;lt;resultMap&amp;gt; 的时候，都传一个空集合，在解析的过程中再往里面填充
  return resultMapElement(resultMapNode, Collections.&amp;lt;ResultMapping&amp;gt; emptyList());
}

private ResultMap resultMapElement(XNode resultMapNode, List&amp;lt;ResultMapping&amp;gt; additionalResultMappings) throws Exception {
  ErrorContext.instance().activity(&amp;quot;processing &amp;quot; + resultMapNode.getValueBasedIdentifier());
  
  // 获取id
  String id = resultMapNode.getStringAttribute(&amp;quot;id&amp;quot;,
      resultMapNode.getValueBasedIdentifier());

  // 获取 dto 全类名    
  String type = resultMapNode.getStringAttribute(&amp;quot;type&amp;quot;,
      resultMapNode.getStringAttribute(&amp;quot;ofType&amp;quot;,
          resultMapNode.getStringAttribute(&amp;quot;resultType&amp;quot;,
              resultMapNode.getStringAttribute(&amp;quot;javaType&amp;quot;))));

  // 获取extend属性值            
  String extend = resultMapNode.getStringAttribute(&amp;quot;extends&amp;quot;);

 // 获取autoMapping属性值  
  Boolean autoMapping = resultMapNode.getBooleanAttribute(&amp;quot;autoMapping&amp;quot;);

  Class&amp;lt;?&amp;gt; typeClass = resolveClass(type);
  Discriminator discriminator = null;
  List&amp;lt;ResultMapping&amp;gt; resultMappings = new ArrayList&amp;lt;ResultMapping&amp;gt;();
  resultMappings.addAll(additionalResultMappings);

  // 获取到该&amp;lt;resultMap&amp;gt;标签下每个 数据库字段 和 dto字段对应关系
  List&amp;lt;XNode&amp;gt; resultChildren = resultMapNode.getChildren();
  for (XNode resultChild : resultChildren) {
    if (&amp;quot;constructor&amp;quot;.equals(resultChild.getName())) {
      processConstructorElement(resultChild, typeClass, resultMappings);
    } else if (&amp;quot;discriminator&amp;quot;.equals(resultChild.getName())) {
      discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);
    } else {
      List&amp;lt;ResultFlag&amp;gt; flags = new ArrayList&amp;lt;ResultFlag&amp;gt;();

      // 代表主键
      if (&amp;quot;id&amp;quot;.equals(resultChild.getName())) {
        flags.add(ResultFlag.ID);
      }

      // buildResultMappingFromContext用于将&amp;lt;resultMap&amp;gt;标签下的每行对应关系维护成一个ResultMapping对象，其实该方法内最终也是调用了MapperBuilderAssistant类的buildResultMapping方法来完成这个操作
      resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));
    }
  }
  ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);
  try {
    // 内部通过MapperBuilderAssistant类的addResultMap方法，构建一个ResultMap对象，并缓存到configuration的resultMaps属性中，以 Mapper全类名 + id 为key，如： com.hand.sxy.mapper.UserMapper.BaseResultMap
    return resultMapResolver.resolve();
  } catch (IncompleteElementException  e) {
    configuration.addIncompleteResultMap(resultMapResolver);
    throw e;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看看buildResultMappingFromContext方法的返回结果，也就是ResultMapping对象
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-7070b4c9fde25cfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;ResultMapping&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此，有关于&lt;resultMap&gt;这个标签的解析到此结束，接下来看看buildStatementFromContext方法，&lt;strong&gt;这个方法主要时解析 select|insert|update|delete 这个四种情况，最后转换成一个MappedStatement对象，然后缓存在configuration的mappedStatements属性中，以 Mapper全类名 + id 为key，如： com.hand.sxy.mapper.UserMapper.selectByUserName&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;buildStatementFromContext&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  private void buildStatementFromContext(List&amp;lt;XNode&amp;gt; list) {
    // 这里是为了处理 在Mybatis配置文件中配置了databaseId的情况
    if (configuration.getDatabaseId() != null) {
      buildStatementFromContext(list, configuration.getDatabaseId());
    }
    buildStatementFromContext(list, null);
  }

private void buildStatementFromContext(List&amp;lt;XNode&amp;gt; list, String requiredDatabaseId) {
  // 每个 select|insert|update|delet 就是一个XNode
  for (XNode context : list) {
    final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);
    try {
      statementParser.parseStatementNode();
    } catch (IncompleteElementException e) {
      configuration.addIncompleteStatement(statementParser);
    }
  }
}

public void parseStatementNode() {

  /** 各个属性 */

  String id = context.getStringAttribute(&amp;quot;id&amp;quot;);
  String databaseId = context.getStringAttribute(&amp;quot;databaseId&amp;quot;);

  if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {
    return;
  }

  Integer fetchSize = context.getIntAttribute(&amp;quot;fetchSize&amp;quot;);
  Integer timeout = context.getIntAttribute(&amp;quot;timeout&amp;quot;);
  String parameterMap = context.getStringAttribute(&amp;quot;parameterMap&amp;quot;);
  String parameterType = context.getStringAttribute(&amp;quot;parameterType&amp;quot;);
  Class&amp;lt;?&amp;gt; parameterTypeClass = resolveClass(parameterType);

  // 返回类型
  String resultMap = context.getStringAttribute(&amp;quot;resultMap&amp;quot;);
  String resultType = context.getStringAttribute(&amp;quot;resultType&amp;quot;);
  String lang = context.getStringAttribute(&amp;quot;lang&amp;quot;);
  LanguageDriver langDriver = getLanguageDriver(lang);

  Class&amp;lt;?&amp;gt; resultTypeClass = resolveClass(resultType);
  String resultSetType = context.getStringAttribute(&amp;quot;resultSetType&amp;quot;);
  StatementType statementType = StatementType.valueOf(context.getStringAttribute(&amp;quot;statementType&amp;quot;, StatementType.PREPARED.toString()));
  ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);

  // 获取到该标签的名称，即时 select|insert|update|delet 中的哪一种
  String nodeName = context.getNode().getNodeName();

  // SqlCommandType 是个枚举类型,包括    UNKNOWN,INSERT,UPDATE,DELETE,SELECT,FLUSH 这几个值
  SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));
  boolean isSelect = sqlCommandType == SqlCommandType.SELECT;

  boolean flushCache = context.getBooleanAttribute(&amp;quot;flushCache&amp;quot;, !isSelect);
  boolean useCache = context.getBooleanAttribute(&amp;quot;useCache&amp;quot;, isSelect);
  boolean resultOrdered = context.getBooleanAttribute(&amp;quot;resultOrdered&amp;quot;, false);

  // 在解析SQL之前，处理SQL中的 &amp;lt;include&amp;gt; 标签，即引用了一段SQL
  XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);
  includeParser.applyIncludes(context.getNode());

  // 解析selectKey，SelectKey在Mybatis中是为了解决Insert数据时不支持主键自动生成的问题
  processSelectKeyNodes(id, parameterTypeClass, langDriver);
  
  // 正式开始解析SQL，这时候的SQL中的&amp;lt;selectKey&amp;gt; 和 &amp;lt;include&amp;gt; 已经解析好了并且替换成正常的sql语句了。
  // SqlSource非常重要，是用来处理SQL语句的。它有一个getBoundSql(Object parameterObject)方法，就是用来返回最终的SQL的
  // Parse the SQL (pre: &amp;lt;selectKey&amp;gt; and &amp;lt;include&amp;gt; were parsed and removed)
  SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);

  String resultSets = context.getStringAttribute(&amp;quot;resultSets&amp;quot;);
  String keyProperty = context.getStringAttribute(&amp;quot;keyProperty&amp;quot;);
  String keyColumn = context.getStringAttribute(&amp;quot;keyColumn&amp;quot;);
  KeyGenerator keyGenerator;

  // query!selectKey
  String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;

  // com.hand.sxy.mapper.UserMapper.query!selectKey
  keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);

  if (configuration.hasKeyGenerator(keyStatementId)) {
    keyGenerator = configuration.getKeyGenerator(keyStatementId);
  } else {
    keyGenerator = context.getBooleanAttribute(&amp;quot;useGeneratedKeys&amp;quot;,
        configuration.isUseGeneratedKeys() &amp;amp;&amp;amp; SqlCommandType.INSERT.equals(sqlCommandType))
        ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
  }

  // MapperBuilderAssistant#addMappedStatement生成一个MappedStatement对象，并缓存在configuration的mappedStatements对象中，以Mapper全类名 + id 为key，如： com.hand.sxy.mapper.UserMapper.selectByUserName 
  builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,
      fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,
      resultSetTypeEnum, flushCache, useCache, resultOrdered, 
      keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看看buildStatementFromContext方法的返回结果，也就是MappedStatement对象
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-2ccbda663d504304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;MappedStatement&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解析完之后，还有一个方法需要执行，即bindMapperForNamespace，绑定命名空间，就是将已解析的内容缓存起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void bindMapperForNamespace() {
  String namespace = builderAssistant.getCurrentNamespace();
  if (namespace != null) {
    Class&amp;lt;?&amp;gt; boundType = null;
    try {
      boundType = Resources.classForName(namespace);
    } catch (ClassNotFoundException e) {
      //ignore, bound type is not required
    }
    if (boundType != null) {
      if (!configuration.hasMapper(boundType)) {
        // Spring may not know the real resource name so we set a flag
        // to prevent loading again this resource from the mapper interface
        // look at MapperAnnotationBuilder#loadXmlResource
        configuration.addLoadedResource(&amp;quot;namespace:&amp;quot; + namespace);
        configuration.addMapper(boundType);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于Mapper.xml文件的解析暂时就分析到这里，可以发现一个规律，就是将一类类标签解析成各种类，然后缓存到configuration对象的各个属性中。&lt;/p&gt;

&lt;p&gt;前面讲解的loadXmlResource方法内容有点多，这里再将主流程的代码贴一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void parse() {
  String resource = type.toString();
  if (!configuration.isResourceLoaded(resource)) {
    // 解析Mapper.xml
    loadXmlResource();
    configuration.addLoadedResource(resource);
    assistant.setCurrentNamespace(type.getName());

    // 解析@CacheNamespace注解，也就是对应Mapper.xml中的&amp;lt;cache&amp;gt;标签，因为在loadXmlResource方法中已经解析过&amp;lt;cache&amp;gt;标签了，所以这里只要解析@CacheNamespace注解
    parseCache();

    // 解析CacheNamespaceRef注解，也就是对应Mapper.xml中的&amp;lt;cache-ref&amp;gt;标签，与上面类似
    parseCacheRef();

    Method[] methods = type.getMethods();
    for (Method method : methods) {
      try {
        // 排除桥接方法，关系到Java的泛型擦除，具体参考 https://www.zhihu.com/question/54895701/answer/141623158
        if (!method.isBridge()) {
          // 解析方法上的注解，例：@Options、@ResultMap 等注解
          parseStatement(method);
        }
      } catch (IncompleteElementException e) {
        configuration.addIncompleteMethod(new MethodResolver(this, method));
      }
    }
  }

  // 重新解析残缺的method？不太清楚什么情况下会产生残缺的方法
  parsePendingMethods();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parsestatement&#34;&gt;parseStatement&lt;/h3&gt;

&lt;p&gt;这个方法主要是解析Mapper接口方法上的一些注解，例：@Options、 @Inser、@Select、@Update、@SelectProvider、@InsertProvider、@UpdateProvider、@DeleteProvider 等注解，有关于我们常用这几个注解，还是很有必要解释一下。那几个Provider注解，允许我们自己在方法里面写生成SQL的逻辑，可以通过他们在开发通用Mapper组件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void parseStatement(Method method) {
  Class&amp;lt;?&amp;gt; parameterTypeClass = getParameterType(method);
  LanguageDriver languageDriver = getLanguageDriver(method);

  // 获取 @Inser、@Select、@Update、@SelectProvider、@InsertProvider、@UpdateProvider、@DeleteProvider 注解上对应的 SqlSource
  SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);

  if (sqlSource != null) {
    // @Options 注解
    Options options = method.getAnnotation(Options.class);
    final String mappedStatementId = type.getName() + &amp;quot;.&amp;quot; + method.getName();
    Integer fetchSize = null;
    Integer timeout = null;
    StatementType statementType = StatementType.PREPARED;
    ResultSetType resultSetType = ResultSetType.FORWARD_ONLY;
    SqlCommandType sqlCommandType = getSqlCommandType(method);
    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;
    boolean flushCache = !isSelect;
    boolean useCache = isSelect;

    KeyGenerator keyGenerator;
    String keyProperty = &amp;quot;id&amp;quot;;
    String keyColumn = null;
    if (SqlCommandType.INSERT.equals(sqlCommandType) || SqlCommandType.UPDATE.equals(sqlCommandType)) {
      // first check for SelectKey annotation - that overrides everything else
      SelectKey selectKey = method.getAnnotation(SelectKey.class);
      if (selectKey != null) {
        keyGenerator = handleSelectKeyAnnotation(selectKey, mappedStatementId, getParameterType(method), languageDriver);
        keyProperty = selectKey.keyProperty();
      } else if (options == null) {
        keyGenerator = configuration.isUseGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
      } else {
        keyGenerator = options.useGeneratedKeys() ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;
        keyProperty = options.keyProperty();
        keyColumn = options.keyColumn();
      }
    } else {
      keyGenerator = NoKeyGenerator.INSTANCE;
    }

    if (options != null) {
      if (FlushCachePolicy.TRUE.equals(options.flushCache())) {
        flushCache = true;
      } else if (FlushCachePolicy.FALSE.equals(options.flushCache())) {
        flushCache = false;
      }
      useCache = options.useCache();
      fetchSize = options.fetchSize() &amp;gt; -1 || options.fetchSize() == Integer.MIN_VALUE ? options.fetchSize() : null; //issue #348
      timeout = options.timeout() &amp;gt; -1 ? options.timeout() : null;
      statementType = options.statementType();
      resultSetType = options.resultSetType();
    }

    String resultMapId = null;
    // @ResultMap 注解
    ResultMap resultMapAnnotation = method.getAnnotation(ResultMap.class);
    if (resultMapAnnotation != null) {
      String[] resultMaps = resultMapAnnotation.value();
      StringBuilder sb = new StringBuilder();
      for (String resultMap : resultMaps) {
        if (sb.length() &amp;gt; 0) {
          sb.append(&amp;quot;,&amp;quot;);
        }
        sb.append(resultMap);
      }
      resultMapId = sb.toString();
    } else if (isSelect) {
      resultMapId = parseResultMap(method);
    }

    // 可以发现，最终也是生成一个MappedStatement对象
    assistant.addMappedStatement(
        mappedStatementId,
        sqlSource,
        statementType,
        sqlCommandType,
        fetchSize,
        timeout,
        // ParameterMapID
        null,
        parameterTypeClass,
        resultMapId,
        getReturnType(method),
        resultSetType,
        flushCache,
        useCache,
        // TODO gcode issue #577
        false,
        keyGenerator,
        keyProperty,
        keyColumn,
        // DatabaseID
        null,
        languageDriver,
        // ResultSets
        options != null ? nullOrEmpty(options.resultSets()) : null);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重点看看这部分内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SqlSource sqlSource = getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);

// 先聊来SqlSource这个接口，它只有一个getBoundSql，就是根据参数计算出实际的可执行SQL，这个可执行SQL在Mybatis中用BoundSql表示，这里就时根据注解获取它对应的SqlSource
private SqlSource getSqlSourceFromAnnotations(Method method, Class&amp;lt;?&amp;gt; parameterType, LanguageDriver languageDriver) {
  try {
    //  @Inser、@Select、@Update、@Delete 其中一个
    Class&amp;lt;? extends Annotation&amp;gt; sqlAnnotationType = getSqlAnnotationType(method);

    // @SelectProvider、@InsertProvider、@UpdateProvider、@DeleteProvider 其中一个
    Class&amp;lt;? extends Annotation&amp;gt; sqlProviderAnnotationType = getSqlProviderAnnotationType(method);

    // 这两种注解不能同时出现，如果你了解@xxprovider的用法就知道了
    if (sqlAnnotationType != null) {
      if (sqlProviderAnnotationType != null) {
        throw new BindingException(&amp;quot;You cannot supply both a static SQL and SqlProvider to method named &amp;quot; + method.getName());
      }

      Annotation sqlAnnotation = method.getAnnotation(sqlAnnotationType);
      // 获取该注解上的SQL
      final String[] strings = (String[]) sqlAnnotation.getClass().getMethod(&amp;quot;value&amp;quot;).invoke(sqlAnnotation);

      // 根据SLQ 创建一个SqlSource 
      return buildSqlSourceFromStrings(strings, parameterType, languageDriver);

    // 如果是Provider类型注解，返回ProviderSqlSource。需要注意的是，@xxxProvider注解可以指定类和方法，然后自己在指定的方法里面写SQL的生成逻辑，也就是动态SQL
    } else if (sqlProviderAnnotationType != null) {
      Annotation sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);
      return new ProviderSqlSource(assistant.getConfiguration(), sqlProviderAnnotation, type, method);
    }
    return null;
  } catch (Exception e) {
    throw new BuilderException(&amp;quot;Could not find value method on SQL annotation.  Cause: &amp;quot; + e, e);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一小部分内容主要需要注意的是：@xxxProvider注解可以指定类和方法，然后自己在指定的方法里面写SQL的生成逻辑，也就是动态SQL。&lt;/p&gt;

&lt;p&gt;可以看看SqlSource的继承结构图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-1f6239cff187f486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有关去解析这部分内容，也就是XMLConfigBuilder的parse()方法，暂时就介绍到这里，主要是讲解了Mapper这部分的解析逻辑。下面再次回到SqlSessionFactoryBuilder中的build方法上来。&lt;/p&gt;

&lt;h1 id=&#34;构建sqlsessionfactory&#34;&gt;构建SqlSessionFactory&lt;/h1&gt;

&lt;p&gt;在构建好configuration对象后，接下来的逻辑比较简单，在XMLConfigBuilder的parse方法执行完之后，就已经构建了一个完整的configuration对象，剩下的只是新建一个DefaultSqlSessionFactory对象，并将已构建好的configuration对象作为DefaultSqlSessionFactory对象的一个熟属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
  try {
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
  } catch (Exception e) {
    throw ExceptionFactory.wrapException(&amp;quot;Error building SqlSession.&amp;quot;, e);
  } finally {
    ErrorContext.instance().reset();
    try {
      inputStream.close();
    } catch (IOException e) {
      // Intentionally ignore. Prefer previous error.
    }
  }
}

// 创建了一个SqlSessionFactory，默认实现类 DefaultSqlSessionFactory
public SqlSessionFactory build(Configuration config) {
  return new DefaultSqlSessionFactory(config);
}

public DefaultSqlSessionFactory(Configuration configuration) {
  this.configuration = configuration;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于接口中的方法，我们也简单了解一下，主要是和SqlSession相关，具体内容在接下来的章节介绍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface SqlSessionFactory {

  SqlSession openSession();

  SqlSession openSession(boolean autoCommit);
  SqlSession openSession(Connection connection);
  SqlSession openSession(TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType);
  SqlSession openSession(ExecutorType execType, boolean autoCommit);
  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);
  SqlSession openSession(ExecutorType execType, Connection connection);

  Configuration getConfiguration();

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，有关于Mybatis这个框架的初始化操作已经完成了，现在可以正常使用了，接下来需要了解的就是这个框架的执行流程了。&lt;/p&gt;

&lt;h1 id=&#34;四大核心组件&#34;&gt;四大核心组件&lt;/h1&gt;

&lt;p&gt;我们如果使用Mybatis，一般是和SqlSession打交道比较多，那为什么不先介绍SqlSession而要先介绍四大对象呢？因为SqlSession只是一个高级接口，真正干实事的就是它们几个，它们负责数据库连接到返回包装后的结果集的整个过程。四大对象主要是&lt;strong&gt;Executor、StatementHandler、ParameterHandler、ResultSetHandler&lt;/strong&gt;，那么它们之间是什么关系呢？Executor是执行器，相当于是给SqlSession提供的最外层接口，SqlSession直接与Executor交互，而在Executor方法内部，则是负责创建与数据库交互(底层还是通过JDBC交互)的环境，比如创建Statement对象，而在创建Statement的过程中，需要依赖其它两个组件StatementHandler、ParameterHandler。StatementHandler用于创建Statement对象，PreparedStatementHandler用于设置参数，即给PreparedStatement对象设置参数，当实例化StatementHandler对象的时候，就会实例化ParameterHandler和ResultSetHandler，这个过程实在抽象类BaseStatementHandler的构造方法中完成的。当执行StatementHandler的prepare方法之后，会执行StatementHandle的parameterize方法，在该方法内部，根据StatementType的值，委托不同的对象来执行参数设置，而在委托对象方法内，又调用了ParameterHandler来执行真正的参数设置。接下来逐个解析&lt;/p&gt;

&lt;h3 id=&#34;executor&#34;&gt;Executor&lt;/h3&gt;

&lt;p&gt;先来看看Executor接口的继承关系图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-7fcc944021a60ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;Executor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;主要就4个实现类，分别继承自BaseExecutor抽象类。CachingExecutor和缓存处理有关，这里先不介绍，其实它内部的逻辑也是通过委托Executor来完成。四个实现类分别处理不同的场景：
1. SimpleExecutor，这是Executor接口的默认实现，其源码也比较简单
2. ReuseExecutor，它的实现其实和SimpleExecutor的类似，只不过内部维护了一个map来缓存statement。但是不同的sqlSession肯定有不同的executor，所以不同的executor即使有map缓存也没有作用。所以只有在同一个sqlSession的时候ReuseExecutor才有作用(在spring事务中可以使用，因为事务中是用的同一个sqlSession)，其他时候使用和SimpleExecutor无差别。
3. BatchExecutor，主要是把不同的Statement以及参数值缓存起来，在调用了sqlSession.commit()或带有@Flush注解的方法时，会调用 doFlushStatements 方法把数据批量刷新到表中。
4. ClosedExecutor，这里ResultLoaderMap里面的一个内部类，应该是为ResultLoaderMap服务的吧，不太清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么，是什么时候生成Executor对象？在获取SqlSession的时候！这个过程我会在下面又详细的介绍，因为这里涉及到Mybatis中一个非常重要的概念：插件！所以，先将四大对象的作用搞清楚，接下来再来看那个流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里我们就简单看一下SimpleExecutor，因为它是默认的Executor。前面已经说了，Executor是为SqlSession服务的，即SqlSession是一个更高级的接口，方便大家使用，内部调用了Executor接口中方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class SimpleExecutor extends BaseExecutor {

  public SimpleExecutor(Configuration configuration, Transaction transaction) {
    super(configuration, transaction);
  }

  // 更新
  @Override
  public int doUpdate(MappedStatement ms, Object parameter) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(this, ms, parameter, RowBounds.DEFAULT, null, null);
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.update(stmt);
    } finally {
      closeStatement(stmt);
    }
  }


  // 查询
  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);
      stmt = prepareStatement(handler, ms.getStatementLog());
      return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }

  @Override
  protected &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException {
    Configuration configuration = ms.getConfiguration();
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, null, boundSql);
    Statement stmt = prepareStatement(handler, ms.getStatementLog());
    return handler.&amp;lt;E&amp;gt;queryCursor(stmt);
  }

  @Override
  public List&amp;lt;BatchResult&amp;gt; doFlushStatements(boolean isRollback) throws SQLException {
    return Collections.emptyList();
  }

  // 生成Statement对象并设置参数
  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    Connection connection = getConnection(statementLog);
    stmt = handler.prepare(connection, transaction.getTimeout());
    handler.parameterize(stmt);
    return stmt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;statementhandler&#34;&gt;StatementHandler&lt;/h3&gt;

&lt;p&gt;StatementHandler用于创建并配置好Statement对象，其中就包括参数这些，然后提供接口供Executor调用，在其接口方法内部，通过配置好的Statement对象执行SQL语句。先看看StatementHandler接口的继承关系图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-e957ab94eb72427f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;StatementHandler&#34; /&gt;&lt;/p&gt;

&lt;p&gt;BaseStatementHandler是一个抽象类，它有3个实现类：SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler。从业务逻辑上来讲，RoutingStatementHandler的作用和CachingExecutor的作用好像，它们内部都是通过委托类来完成实际的操作的，其实它的作用也就这么多了。
1. SimpleStatementHandler，这个很简单，就是对应我们JDBC中常用的Statement接口，用于简单SQL的处理；
2. PreparedStatementHandler，这个对应JDBC中的PreparedStatement，预编译SQL的接口；
3. CallableStatementHandler，这个对应JDBC中CallableStatement，用于执行存储过程相关的接口；
4. RoutingStatementHandler，内部持有一个StatementHandler引用，根据不同的StatementType，创建类型的StatementHandler对象。&lt;/p&gt;

&lt;p&gt;先简单看看的逻辑RoutingStatementHandler的逻辑，省略了一些非关键代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class RoutingStatementHandler implements StatementHandler {

  private final StatementHandler delegate;

  public RoutingStatementHandler(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    // StatementType标记使用什么的对象操作SQL语句，这是一个枚举类型
    switch (ms.getStatementType()) {
      // 直接操作sql，直接进行的字符串拼接，不进行预编译获取数据，比如我们的 ${} 操作    Statement 
      case STATEMENT:
        delegate = new SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;

      // 预处理，参数，进行预编译，获取数据，比如我们的 #{} 操作，默认就是这个    PreparedStatement
      case PREPARED:
        delegate = new PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;

      // 执行存储过程，CallableStatement  
      case CALLABLE:
        delegate = new CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);
        break;
      default:
        throw new ExecutorException(&amp;quot;Unknown statement type: &amp;quot; + ms.getStatementType());
    }

  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们以它的SimpleExecutor对象中的doQuery方法为切入点，简单分析一下PreparedStatementHandler，&lt;strong&gt;这里以PreparedStatementHandler来分析，所以下面的注释中我都会用这个类，实际执行过程中是要根据MappedStatement来判断的，这里要注意一下&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  Statement stmt = null;
  try {
    Configuration configuration = ms.getConfiguration();
    // 返回了一个RoutingStatementHandler对象，调用该对象方法的时候，实际上调用的是委托对象的方法
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);

    stmt = prepareStatement(handler, ms.getStatementLog());
    return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
  } finally {
    closeStatement(stmt);
  }
}

private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
  Statement stmt;
  Connection connection = getConnection(statementLog);
  // prepare在父类BaseStatementHandler中是实现了，然后又在里面调用了子类的instantiateStatement方法
  stmt = handler.prepare(connection, transaction.getTimeout());

  // 调用了RoutingStatementHandler中的parameterize方法，RoutingStatementHandler中的委托类是PreparedStatementHandler，所以调用了PreparedStatementHandler的parameterize方法
  handler.parameterize(stmt);
  return stmt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是PreparedStatementHandler源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PreparedStatementHandler extends BaseStatementHandler {

  public PreparedStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    super(executor, mappedStatement, parameter, rowBounds, resultHandler, boundSql);
  }

  @Override
  public int update(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    int rows = ps.getUpdateCount();
    Object parameterObject = boundSql.getParameterObject();
    KeyGenerator keyGenerator = mappedStatement.getKeyGenerator();
    keyGenerator.processAfter(executor, mappedStatement, ps, parameterObject);
    return rows;
  }

  @Override
  public void batch(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.addBatch();
  }

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps);
  }

  @Override
  public &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; queryCursor(Statement statement) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();
    return resultSetHandler.&amp;lt;E&amp;gt; handleCursorResultSets(ps);
  }

  // 返回一个PrepareStatement，设置预处理SQL
  @Override
  protected Statement instantiateStatement(Connection connection) throws SQLException {
    String sql = boundSql.getSql();
    if (mappedStatement.getKeyGenerator() instanceof Jdbc3KeyGenerator) {
      String[] keyColumnNames = mappedStatement.getKeyColumns();
      if (keyColumnNames == null) {
        return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
      } else {
        return connection.prepareStatement(sql, keyColumnNames);
      }
    } else if (mappedStatement.getResultSetType() != null) {
      return connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);
    } else {
      return connection.prepareStatement(sql);
    }
  }

  @Override
  public void parameterize(Statement statement) throws SQLException {
    // 调用了ParameterHandler中的setParameters方法，parameterHandler在父类BaseStatementHandler中，用于设置参数的
    parameterHandler.setParameters((PreparedStatement) statement);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parameterhandler&#34;&gt;ParameterHandler&lt;/h3&gt;

&lt;p&gt;ParameterHandler接口比较简单，用来设置SQL参数，只有一个默认实现类，以下是其结构关系图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-cc8ea104a12a9871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;ParameterHandler&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ParameterHandler接口中，最核心的就是setParameters方法，即设置参数，有关于这里面的具体逻辑就不过多说明了，有兴趣的可以自己看一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class DefaultParameterHandler implements ParameterHandler {

  private final TypeHandlerRegistry typeHandlerRegistry;

  private final MappedStatement mappedStatement;
  private final Object parameterObject;
  private final BoundSql boundSql;
  private final Configuration configuration;

  public DefaultParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
    this.mappedStatement = mappedStatement;
    this.configuration = mappedStatement.getConfiguration();
    this.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();
    this.parameterObject = parameterObject;
    this.boundSql = boundSql;
  }

  @Override
  public Object getParameterObject() {
    return parameterObject;
  }

  @Override
  public void setParameters(PreparedStatement ps) {
    ErrorContext.instance().activity(&amp;quot;setting parameters&amp;quot;).object(mappedStatement.getParameterMap().getId());
    List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings();
    if (parameterMappings != null) {
      for (int i = 0; i &amp;lt; parameterMappings.size(); i++) {
        ParameterMapping parameterMapping = parameterMappings.get(i);
        if (parameterMapping.getMode() != ParameterMode.OUT) {
          Object value;
          String propertyName = parameterMapping.getProperty();
          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params
            value = boundSql.getAdditionalParameter(propertyName);
          } else if (parameterObject == null) {
            value = null;
          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
            value = parameterObject;
          } else {
            MetaObject metaObject = configuration.newMetaObject(parameterObject);
            value = metaObject.getValue(propertyName);
          }
          TypeHandler typeHandler = parameterMapping.getTypeHandler();
          JdbcType jdbcType = parameterMapping.getJdbcType();
          if (value == null &amp;amp;&amp;amp; jdbcType == null) {
            jdbcType = configuration.getJdbcTypeForNull();
          }
          try {
            typeHandler.setParameter(ps, i + 1, value, jdbcType);
          } catch (TypeException e) {
            throw new TypeException(&amp;quot;Could not set parameters for mapping: &amp;quot; + parameterMapping + &amp;quot;. Cause: &amp;quot; + e, e);
          } catch (SQLException e) {
            throw new TypeException(&amp;quot;Could not set parameters for mapping: &amp;quot; + parameterMapping + &amp;quot;. Cause: &amp;quot; + e, e);
          }
        }
      }
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;resultsethandler&#34;&gt;ResultSetHandler&lt;/h3&gt;

&lt;p&gt;ResultSetHandler也接口比较简单，用于包装结果集，只有一个默认实现类，以下是其结构关系图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-8d924f0f5a7dae45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;ResultSetHandler&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个实现类中的代码比较多，就不贴代码了，直接看看ResultSetHandler接口中的方法吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ResultSetHandler {

  &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; handleResultSets(Statement stmt) throws SQLException;

  &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; handleCursorResultSets(Statement stmt) throws SQLException;

  void handleOutputParameters(CallableStatement cs) throws SQLException;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;executor流程&#34;&gt;Executor流程&lt;/h3&gt;

&lt;p&gt;前面已经简单介绍了4大对象，接下来就讲SimpleExecutor类中的doQuery方法整个流程简单介绍一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
  Statement stmt = null;
  try {
    Configuration configuration = ms.getConfiguration();
    // 返回RoutingStatementHandler对象，该对象中持有一个StatementHandler对象，根据StatementType类型创建对应的StatementHandler
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);

    // 设置参数，返回Statement， 即该方法执行之后，即返回了一个完整可用的Statement对象
    stmt = prepareStatement(handler, ms.getStatementLog());

    // 执行SQL并返回结果集
    return handler.&amp;lt;E&amp;gt;query(stmt, resultHandler);
  } finally {
    closeStatement(stmt);
  }
}

// 还是以PreparedStatementHandler为例子，分析其query方法
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
  PreparedStatement ps = (PreparedStatement) statement;
  // 执行SQL语句
  ps.execute();

  // 包装结果集
  return resultSetHandler.&amp;lt;E&amp;gt; handleResultSets(ps);
}

// 包装结果集的逻辑主要就在这里面了，有兴趣可以简单看看，精力有限，就不做过多说明了
public List&amp;lt;Object&amp;gt; handleResultSets(Statement stmt) throws SQLException {
  ErrorContext.instance().activity(&amp;quot;handling results&amp;quot;).object(mappedStatement.getId());

  final List&amp;lt;Object&amp;gt; multipleResults = new ArrayList&amp;lt;Object&amp;gt;();

  int resultSetCount = 0;
  ResultSetWrapper rsw = getFirstResultSet(stmt);

  List&amp;lt;ResultMap&amp;gt; resultMaps = mappedStatement.getResultMaps();
  int resultMapCount = resultMaps.size();
  validateResultMapsCount(rsw, resultMapCount);
  while (rsw != null &amp;amp;&amp;amp; resultMapCount &amp;gt; resultSetCount) {
    ResultMap resultMap = resultMaps.get(resultSetCount);
    handleResultSet(rsw, resultMap, multipleResults, null);
    rsw = getNextResultSet(stmt);
    cleanUpAfterHandlingResultSet();
    resultSetCount++;
  }

  String[] resultSets = mappedStatement.getResultSets();
  if (resultSets != null) {
    while (rsw != null &amp;amp;&amp;amp; resultSetCount &amp;lt; resultSets.length) {
      ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);
      if (parentMapping != null) {
        String nestedResultMapId = parentMapping.getNestedResultMapId();
        ResultMap resultMap = configuration.getResultMap(nestedResultMapId);
        handleResultSet(rsw, resultMap, null, parentMapping);
      }
      rsw = getNextResultSet(stmt);
      cleanUpAfterHandlingResultSet();
      resultSetCount++;
    }
  }

  return collapseSingleResultList(multipleResults);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;获取sqlsession&#34;&gt;获取SqlSession&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;SqlSession是Mybatis的关键对象，是执行持久化操作的独享，类似于JDBC中的Connection。SqlSession对象完全包含以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行被映射的SQL语句.每个线程都应该有它自己的SqlSession实例.SqlSession的实例不能被共享，同时SqlSession也是线程不安全的，绝对不能将SqlSeesion实例的引用放在一个类的静态字段甚至是实例字段中.也绝不能将SqlSession实例的引用放在任何类型的管理范围中，比如Servlet当中的HttpSession对象中.使用完SqlSeesion之后关闭Session很重要，应该确保使用finally块来关闭它。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们通过sqlSessionFactory获取SqlSession对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 3、获取SqlSession
SqlSession sqlSession = sqlSessionFactory.openSession();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体逻辑在DefaultSqlSessionFactory类中，可以看出，每次openSession的时候都是创建了一个新的DefaultSqlSession，并且，每次都创建了一个新的Executor，所以从这里可以看出，Executor时依赖于SqlSession而存活的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public SqlSession openSession() {
  return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;
  try {
    final Environment environment = configuration.getEnvironment();
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);

    // 创建Executor
    final Executor executor = configuration.newExecutor(tx, execType);

    return new DefaultSqlSession(configuration, executor, autoCommit);
  } catch (Exception e) {
    closeTransaction(tx); // may have fetched a connection so lets call close()
    throw ExceptionFactory.wrapException(&amp;quot;Error opening session.  Cause: &amp;quot; + e, e);
  } finally {
    ErrorContext.instance().reset();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看看DefaultSqlSession中的代码，该类的代码太长，这里只列出片段。观察它的selectOne方法，发现最终就是调用了Executor的query方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class DefaultSqlSession implements SqlSession {

  private final Configuration configuration;
  private final Executor executor;

  private final boolean autoCommit;
  private boolean dirty;
  private List&amp;lt;Cursor&amp;lt;?&amp;gt;&amp;gt; cursorList;

  public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) {
    this.configuration = configuration;
    this.executor = executor;
    this.dirty = false;
    this.autoCommit = autoCommit;
  }

  @Override
  public &amp;lt;T&amp;gt; T selectOne(String statement) {
    return this.&amp;lt;T&amp;gt;selectOne(statement, null);
  }
  @Override
  public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
    // Popular vote was to return null on 0 results and throw exception on too many.
    List&amp;lt;T&amp;gt; list = this.&amp;lt;T&amp;gt;selectList(statement, parameter);
    if (list.size() == 1) {
      return list.get(0);
    } else if (list.size() &amp;gt; 1) {
      throw new TooManyResultsException(&amp;quot;Expected one result (or null) to be returned by selectOne(), but found: &amp;quot; + list.size());
    } else {
      return null;
    }
  }
  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter) {
    return this.selectList(statement, parameter, RowBounds.DEFAULT);
  }

  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    try {
      MappedStatement ms = configuration.getMappedStatement(statement);
      // 最终就是调用了Executor的query方法
      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&amp;quot;Error querying database.  Cause: &amp;quot; + e, e);
    } finally {
      ErrorContext.instance().reset();
    }
  }
......

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在本章节中，隐藏了Mybatis中非常重要的一块内容，插件！final Executor executor = configuration.newExecutor(tx, execType) 这里先不过多介绍，留个悬念，下面再详细介绍，让大家有个印象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有关于获取SqlSession相关的内容就介绍到这里了，通过前面的内容，我们可以知道，实际执行SQL并包装结果集返回的是四大对象，但是我们平时在使用的时候，基本不会和那四大对象打交道，而是通过SqlSession获取Mapper,然后直接调用Mapper方法，甚至在整合了Spring之后，SqlSession都省略了，直接和Mapper打交道。那么，它们内部是怎么做到的呢？有关于和Spring整合的内容放到最后面，先讲解 SqlSession &amp;ndash;&amp;gt; Mapper 这一套。&lt;/p&gt;

&lt;h1 id=&#34;mapper代理&#34;&gt;Mapper代理&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;// 获取代理对象
UserMapper mapper = sqlSession.getMapper(UserMapper.class);

// 通过代理对象执行方法调用
User user = mapper.selectByUserName(&amp;quot;admin&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分内容可以很容易猜到适合动态代理相关了，其实我们在上面也有提到过一点：MapperRegistry、MapperProxyFactory、MapperProxy，有印象了吗？没关系，我们现在完整讲一讲整个代理过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// DefaultSqlSession#getMapper
public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type) {
  return configuration.&amp;lt;T&amp;gt;getMapper(type, this);
}


// Configuration#getMapper
public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
  return mapperRegistry.getMapper(type, sqlSession);
}


// MapperRegistry#getMapper，最终调用了MapperRegistry的getMapper方法
public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
  // 从缓存获取
  final MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory&amp;lt;T&amp;gt;) knownMappers.get(type);
  if (mapperProxyFactory == null) {
    throw new BindingException(&amp;quot;Type &amp;quot; + type + &amp;quot; is not known to the MapperRegistry.&amp;quot;);
  }
  try {
    // 创建代理对象
    return mapperProxyFactory.newInstance(sqlSession);
  } catch (Exception e) {
    throw new BindingException(&amp;quot;Error getting mapper instance. Cause: &amp;quot; + e, e);
  }
}


// MapperProxyFactory#newInstance
public T newInstance(SqlSession sqlSession) {
  // 创建MapperProxy对象，该类实现了InvocationHandler接口，即：代理对象执行方法的时候，会执行该类的invoke方法
  final MapperProxy&amp;lt;T&amp;gt; mapperProxy = new MapperProxy&amp;lt;T&amp;gt;(sqlSession, mapperInterface, methodCache);
  return newInstance(mapperProxy);
}
// MapperProxyFactory#newInstance
protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
  // 通过JDK动态代理创建代理对象
  return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不懂动态代理，大家可以去了解以下，这里就过多介绍了。可以看出，这里就是创建了一个代理对象，代理对象执行方法时，真正的逻辑就在MapperProxy的invoke方法中。有关于MapperProxy的源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperProxy&amp;lt;T&amp;gt; implements InvocationHandler, Serializable {

  private static final long serialVersionUID = -6424540398559729838L;
  private final SqlSession sqlSession;
  private final Class&amp;lt;T&amp;gt; mapperInterface;
  private final Map&amp;lt;Method, MapperMethod&amp;gt; methodCache;

  public MapperProxy(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt; methodCache) {
    this.sqlSession = sqlSession;
    this.mapperInterface = mapperInterface;
    this.methodCache = methodCache;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      
      // 如果是Object类型？
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, args);
      } else if (isDefaultMethod(method)) {
        return invokeDefaultMethod(proxy, method, args);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }

    // 上面主要是判断一下是不是默认方法啥的，关系不大，我们需要关注的是下面两行代码，这才是核心
    final MapperMethod mapperMethod = cachedMapperMethod(method);

    // 该方法内部就是通过 SqlSession 和数据库交互 
    return mapperMethod.execute(sqlSession, args);
  }

  private MapperMethod cachedMapperMethod(Method method) {
    // 如果该Mapper的方法没有执行过，则缓存中没有，需要创建，执行之后就会放到缓存中，下次执行不用重新创建，前提是在一次SqlSession的会话中，如果SqlSession关了，下次getMapper的时候又是重新创建一个代理类
    MapperMethod mapperMethod = methodCache.get(method);
    if (mapperMethod == null) {
      // 创建
      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      // 缓存
      methodCache.put(method, mapperMethod);
    }
    return mapperMethod;
  }

  @UsesJava7
  private Object invokeDefaultMethod(Object proxy, Method method, Object[] args)
      throws Throwable {
    final Constructor&amp;lt;MethodHandles.Lookup&amp;gt; constructor = MethodHandles.Lookup.class
        .getDeclaredConstructor(Class.class, int.class);
    if (!constructor.isAccessible()) {
      constructor.setAccessible(true);
    }
    final Class&amp;lt;?&amp;gt; declaringClass = method.getDeclaringClass();
    return constructor
        .newInstance(declaringClass,
            MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED
                | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)
        .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);
  }

  /**
   * Backport of java.lang.reflect.Method#isDefault()
   */
  private boolean isDefaultMethod(Method method) {
    return ((method.getModifiers()
        &amp;amp; (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) == Modifier.PUBLIC)
        &amp;amp;&amp;amp; method.getDeclaringClass().isInterface();
  }
}


// MapperMethod#execute
public Object execute(SqlSession sqlSession, Object[] args) {
  Object result;
  switch (command.getType()) {
    case INSERT: {
    Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
      break;
    }
    case UPDATE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.update(command.getName(), param));
      break;
    }
    case DELETE: {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.delete(command.getName(), param));
      break;
    }
    case SELECT:
      if (method.returnsVoid() &amp;amp;&amp;amp; method.hasResultHandler()) {
        executeWithResultHandler(sqlSession, args);
        result = null;
      } else if (method.returnsMany()) {
        result = executeForMany(sqlSession, args);
      } else if (method.returnsMap()) {
        result = executeForMap(sqlSession, args);
      } else if (method.returnsCursor()) {
        result = executeForCursor(sqlSession, args);
      } else {
        Object param = method.convertArgsToSqlCommandParam(args);
        result = sqlSession.selectOne(command.getName(), param);
      }
      break;
    case FLUSH:
      result = sqlSession.flushStatements();
      break;
    default:
      throw new BindingException(&amp;quot;Unknown execution method for: &amp;quot; + command.getName());
  }
  if (result == null &amp;amp;&amp;amp; method.getReturnType().isPrimitive() &amp;amp;&amp;amp; !method.returnsVoid()) {
    throw new BindingException(&amp;quot;Mapper method &#39;&amp;quot; + command.getName() 
        + &amp;quot; attempted to return null from a method with a primitive return type (&amp;quot; + method.getReturnType() + &amp;quot;).&amp;quot;);
  }
  return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，有关于创建代理对象，并通过代理对象调用方法的整个过程讲解完毕。&lt;/p&gt;

&lt;h1 id=&#34;插件&#34;&gt;插件&lt;/h1&gt;

&lt;p&gt;插件是Mybatis中非常重要的一个功能，在讲解它的实现原理之前，先简单了解一下Mybatis中插件的使用。
MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：
1. Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)
2. ParameterHandler (getParameterObject, setParameters)
3. ResultSetHandler (handleResultSets, handleOutputParameters)
4. StatementHandler (prepare, parameterize, batch, update, query)&lt;/p&gt;

&lt;p&gt;这不就是四大对象吗！&lt;/p&gt;

&lt;p&gt;下面演示一个简单的插件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.hand.sxy.plugin;


import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;

import java.util.Properties;

// 下面的注解表示在执行Executor的update或者query方法前，会执行插件逻辑；即：会执行intercept方法。要实现插件，必须使用此注解
@Intercepts({
        @Signature(type = Executor.class, method = &amp;quot;update&amp;quot;, args = {MappedStatement.class, Object.class}),
        @Signature(type = Executor.class, method = &amp;quot;query&amp;quot;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})
})
public class MyBatisPlugin implements Interceptor {
    private String name;

    public Object intercept(Invocation invocation) throws Throwable {
        String name = invocation.getMethod().getName();
        System.err.println(&amp;quot;拦截的方法名是：&amp;quot; + name);

        // 继续执行下一个拦截器
        return invocation.proceed();
    }

    public Object plugin(Object target) {
        //System.err.println(&amp;quot;代理的对象是：&amp;quot; + target);
        return Plugin.wrap(target, this);
    }

    public void setProperties(Properties properties) {
        Object name = properties.getProperty(&amp;quot;name&amp;quot;);
        System.err.println(name);
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;写好插件逻辑之后，在配置文件中添加该插件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin interceptor=&amp;quot;com.hand.sxy.plugin.MyBatisPlugin&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; value=&amp;quot;你好&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看效果
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-316bbe70e877bfdf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;plugin&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有关于Mybatis插件的使用就结束到这里，接下来结束一下它的实现原理。&lt;/p&gt;

&lt;p&gt;还记不记得我在上面提到插件，在执行openSession方法的时候，并且标明了一行代码？不记得也没关系，即：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// DefaultSqlSessionFactory#openSessionFromConnection
final Executor executor = configuration.newExecutor(tx, execType);

// Configuration#newExecutor
public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
  executorType = executorType == null ? defaultExecutorType : executorType;
  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
  Executor executor;
  if (ExecutorType.BATCH == executorType) {
    executor = new BatchExecutor(this, transaction);
  } else if (ExecutorType.REUSE == executorType) {
    executor = new ReuseExecutor(this, transaction);
  } else {
    executor = new SimpleExecutor(this, transaction);
  }
  if (cacheEnabled) {
    executor = new CachingExecutor(executor);
  }
  
  // 插件相关代码，这里其实是通过动态代理生成了一个拦截器链
  executor = (Executor) interceptorChain.pluginAll(executor);

  return executor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;根据我们前面对Mybatis插件的介绍，对可以四大对象上的方法进行拦截，也就是说，这四大对象，对应四种插件类型，每种插件类型的插件个数不限。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这句话非常重要，所以对应，创建其它三大对象的时候，我们都可以看到相关的代码，都在Configuration类中，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
  return parameterHandler;
}

public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,
    ResultHandler resultHandler, BoundSql boundSql) {
  ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
  return resultSetHandler;
}

public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
  return statementHandler;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;interceptorChain.pluginAll相当于是对插件的注册。前面有说过，四大对象分别对应四种插件类型，每种插件类型个数不限。执行interceptorChain.pluginAll方法之后，每种插件类型中的所有插件会被组装成一条拦截器链，这里组织的不太好。也就是说，每种插件类型，对应一条拦截器链，该拦截器链是对这种插件类型下所有插件的组装。四种类型，最终就会形成四条拦截器链。而Mybatis中插件的拦截操作，是通过拦截器链来调用的。&lt;/strong&gt;组织的不太好，希望大家可以明白这段话&lt;/p&gt;

&lt;p&gt;也就是说，插件的相关的内容就是以interceptorChain.pluginAll(executor)为入口，这里以Executor类型插件为例进行讲解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class InterceptorChain {

  // 在应用启动的时候，会找到所有的插件并
  private final List&amp;lt;Interceptor&amp;gt; interceptors = new ArrayList&amp;lt;Interceptor&amp;gt;();

  // 在最开始的时候，即执行 (Executor) interceptorChain.pluginAll(executor) 的时候，这个参数是在newExecutor方法创建的executor对象
  public Object pluginAll(Object target) {
    for (Interceptor interceptor : interceptors) {
      // 这段代理很巧妙， 可以认为interceptor.plugin产生了一个代理对象， 又赋值给了target， 每次调用这个方法都相当于是包装了一层
      target = interceptor.plugin(target);
    }
    return target;
  }

  public void addInterceptor(Interceptor interceptor) {
    interceptors.add(interceptor);
  }
  
  public List&amp;lt;Interceptor&amp;gt; getInterceptors() {
    return Collections.unmodifiableList(interceptors);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来重点看看interceptor.plugin(target)方法，这个方法可以自己实现，Mybatis也提供了默认实现的接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Object plugin(Object target) {
//  System.err.println(&amp;quot;代理的对象是：&amp;quot; + target);
    return Plugin.wrap(target, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实现了InvocationHandler接口，那估计和JDK动态代理有关了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Plugin implements InvocationHandler {

  private final Object target;
  private final Interceptor interceptor;
  private final Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap;

  private Plugin(Object target, Interceptor interceptor, Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap) {
    this.target = target;
    this.interceptor = interceptor;
    this.signatureMap = signatureMap;
  }

  public static Object wrap(Object target, Interceptor interceptor) {
    // 这里以Executor为例，假如每次调用都会生成代理对象：
    // 当第一次执行该方法的时候，target是原生的Executor对象，即newExecutor方法种创建的那个对象，这时候它不是一个代理对象。
    // 当第二次执行该方法的时候，target不是原生的Executor对象，因为第一次执行的时候返回了一个代理对象，这时候的target是第一次调用此方法时返回的代理对象
    // 当第三次执行该方法的时候，target不是原生的Executor对象，因为第二次执行的时候返回了一个代理对象，这时候的target是第二次调用此方法时返回的代理对象
    // .....以此类推，即 target是前一次调用产生的代理对象。如果是第一次调用，就是原生的Executor对象


    // 以四大对象类型为key， 方法集合为值缓存起来的Map
    Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap = getSignatureMap(interceptor);

    // 四大对象中的一种
    Class&amp;lt;?&amp;gt; type = target.getClass();

    // 判断该种对象有接口
    Class&amp;lt;?&amp;gt;[] interfaces = getAllInterfaces(type, signatureMap);
    if (interfaces.length &amp;gt; 0) {

      // 创建并返回代理对象
      return Proxy.newProxyInstance(
          type.getClassLoader(),
          interfaces,
          new Plugin(target, interceptor, signatureMap));
    }
    return target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    try {
      // 需要拦截方法的缓存，以四大对象类型为key，方法集合为值
      Set&amp;lt;Method&amp;gt; methods = signatureMap.get(method.getDeclaringClass());
      // 入如果是需要拦截的方法
      if (methods != null &amp;amp;&amp;amp; methods.contains(method)) {
        return interceptor.intercept(new Invocation(target, method, args));
      }

      // 如果不是需要拦截的方法，执行正常的逻辑
      return method.invoke(target, args);
    } catch (Exception e) {
      throw ExceptionUtil.unwrapThrowable(e);
    }
  }

  private static Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; getSignatureMap(Interceptor interceptor) {
    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);
    // issue #251
    if (interceptsAnnotation == null) {
      throw new PluginException(&amp;quot;No @Intercepts annotation was found in interceptor &amp;quot; + interceptor.getClass().getName());      
    }
    Signature[] sigs = interceptsAnnotation.value();
    Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap = new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt;();
    for (Signature sig : sigs) {
      Set&amp;lt;Method&amp;gt; methods = signatureMap.get(sig.type());
      if (methods == null) {
        methods = new HashSet&amp;lt;Method&amp;gt;();
        // tyle 即代表四大对象， methods是一个set集合。即 以四大对象类型为key， 方法集合为值缓存起来 
        signatureMap.put(sig.type(), methods);
      }
      try {
        Method method = sig.type().getMethod(sig.method(), sig.args());
        methods.add(method);
      } catch (NoSuchMethodException e) {
        throw new PluginException(&amp;quot;Could not find method on &amp;quot; + sig.type() + &amp;quot; named &amp;quot; + sig.method() + &amp;quot;. Cause: &amp;quot; + e, e);
      }
    }
    return signatureMap;
  }

  private static Class&amp;lt;?&amp;gt;[] getAllInterfaces(Class&amp;lt;?&amp;gt; type, Map&amp;lt;Class&amp;lt;?&amp;gt;, Set&amp;lt;Method&amp;gt;&amp;gt; signatureMap) {
    Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; interfaces = new HashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;();
    while (type != null) {
      for (Class&amp;lt;?&amp;gt; c : type.getInterfaces()) {
        if (signatureMap.containsKey(c)) {
          interfaces.add(c);
        }
      }
      type = type.getSuperclass();
    }
    return interfaces.toArray(new Class&amp;lt;?&amp;gt;[interfaces.size()]);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是关注wrap方法和invoke方法。先解释wrap方法，该方法每执行一次就会包装一次，signatureMap，以四大对象类型为key，方法集合为值 缓存起来的Map。
这里以Executor为例，假如每次调用都会生成代理对象：
当第一次执行该方法的时候，target是原生的Executor对象，即newExecutor方法种创建的那个对象，这时候它不是一个代理对象。
当第二次执行该方法的时候，target不是原生的Executor对象，因为第一次执行的时候返回了一个代理对象，这时候的target是第一次调用此方法时返回的代理对象
当第三次执行该方法的时候，target不是原生的Executor对象，因为第二次执行的时候返回了一个代理对象，这时候的target是第二次调用此方法时返回的代理对象
以此类推，即target是前一次调用产生的代理对象。如果是第一次调用，就是原生的Executor对象。&lt;/p&gt;

&lt;p&gt;invoke方法即使它的执行逻辑，可以看看，最主要的逻辑就在interceptor.intercept(new Invocation(target, method, args))方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
  try {
    // 需要拦截方法的缓存，以四大对象类型为key，方法集合为值
    Set&amp;lt;Method&amp;gt; methods = signatureMap.get(method.getDeclaringClass());
    // 入如果是需要拦截的方法
    if (methods != null &amp;amp;&amp;amp; methods.contains(method)) {
      return interceptor.intercept(new Invocation(target, method, args));
    }

    // 如果不是需要拦截的方法，执行正常的逻辑
    return method.invoke(target, args);
  } catch (Exception e) {
    throw ExceptionUtil.unwrapThrowable(e);
  }
}

public Object intercept(Invocation invocation) throws Throwable {
    String name = invocation.getMethod().getName();
    System.err.println(&amp;quot;拦截的方法名是：&amp;quot; + name);

    // 继续执行下一个拦截器，其实那个拦截器比当前这个拦截器先执行了plugin方法
    return invocation.proceed();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invocation在构造函数中接收代理对象的targer属性，而在intercept方法中，总是会调用Invocation的proceed，用于触发下一个拦截器执行。直到所有拦截器执行完毕，并且，最后一个执行的，一定是原生对象的方法，即Executor对象方法的真正逻辑。这就是Mybatis插件的核心&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Invocation {

  private final Object target;
  private final Method method;
  private final Object[] args;

  public Invocation(Object target, Method method, Object[] args) {
    this.target = target;
    this.method = method;
    this.args = args;
  }

  public Object getTarget() {
    return target;
  }

  public Method getMethod() {
    return method;
  }

  public Object[] getArgs() {
    return args;
  }

  public Object proceed() throws InvocationTargetException, IllegalAccessException {
    // 
    return method.invoke(target, args);
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**在执行InterceptorChain的pluginAll方法的时候，会为每一个Interceptor生成一个代理对象，例如@Signature(type = Executor.class, method = &amp;ldquo;query&amp;rdquo;)则：为第一个Interceptor生成的代理对象x1，x1中的targer是Executor原生对象；为第二个Interceptor生成的代理对象x2，x2中的targer是x1&amp;hellip;&amp;hellip;最终返回一个包装好的拦截器链。&lt;/p&gt;

&lt;p&gt;那么在调用的时候是什么情况？每次通过sqlSession执行增删该查的时候，都会先调用Configuration 中的newXX方法，也就是说返回了一个如executor，这其实就相当于是返回的x10， 敲黑板，注意是返回的 &amp;ldquo;代理对象x10&amp;rdquo;，然后执行x10的invoke方法。 在这个方法里面，先调用x10对应的Interceptor的intercept方法，然后以x10中的target=x9构建一个 Invocation， 然后在intercept里面再调用 x9的invoke方法，然后一直这样下去。在执行完最后一个插件的intercept方法方法之后，即调用原生Executor对象的对应方法，比如query、update等。**&lt;/p&gt;

&lt;h1 id=&#34;缓存&#34;&gt;缓存&lt;/h1&gt;

&lt;p&gt;Mybatis中分为一级缓存和二级缓存，一级缓存在Mybatis中默认开启，是SqlSession级别的缓存，即在一个SqlSession生命周期内，如果使用了相同的查询，第一次和数据库交互获取数据，之后是在缓存中获取数据。但请注意这里所说的相同的查询，表示执行查询的SQL完全一致，包括参数的值也是一样的。
二级缓存在Mybatis中默认没有开启，需要手动开启。二级缓存是Namespace级别的缓存，即Mapper级别的缓存，因为一般一个Mapper对应一个Namespace，多个SqlSession去操作同一个Mapper的sql语句的时候，各个SqlSession操作数据库得到数据会存在二级缓存区域，这些SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。&lt;/p&gt;

&lt;h3 id=&#34;一级缓存&#34;&gt;一级缓存&lt;/h3&gt;

&lt;p&gt;Mybatis一级缓存默认开启，一级缓存是SqlSession级别的缓存，即在一个SqlSession生命周期内，如果使用了相同的查询，第一次和数据库交互获取数据，之后是在缓存中获取数据。为了演示一下一级缓存和二级缓存，这里对测试代码做了一些修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Application {
    private static SqlSessionFactory sqlSessionFactory;

    public static void main(String[] args) throws Exception {
        // 1、加载配置文件
        InputStream is = Resources.getResourceAsStream(&amp;quot;application.xml&amp;quot;);

        // 2、构建SqlSessionFactory
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

        // 测试一级缓存
        levelOneCache();
    }

    /**
     * 测试一级缓存
     */
    public static void levelOneCache() {
        // 获取SqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        // 第一次不会使用缓存，BaseExecutor#queryFromDatabase
        User user = mapper.selectByUserName(&amp;quot;admin&amp;quot;);
        System.err.println(user);

        // 使用缓存，以完整SQL作为参数(包括参数值)，BaseExecutor#handleLocallyCachedOutputParameters
        User user2 = mapper.selectByUserName(&amp;quot;admin&amp;quot;);
        System.err.println(user2);

        // 执行commit会清空当前SqlSession的缓存
        sqlSession.commit();

        // commit之后不使用用缓存，BaseExecutor#queryFromDatabase
        User user3 = mapper.selectByUserName(&amp;quot;admin&amp;quot;);
        System.err.println(user3);

        sqlSession.close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一级缓存比较好理解，就是在执行查询方法的时候，先从缓存中看看有没有数据，有就从缓存中拿，没有就从数据库中拿，并且它是默认开启的。有些同学在写代码的时候，如果不知道这个特性自己将数据缓存到一个Map里面，不过感觉这个用到的应该不多吧。还有需要注意的一点是，执行SqlSession.commit()方法之后，一级缓存会被清空。当然，SqlSession.close()方法执行之后，那一级缓存必然是不存在了，因为每次查询我们都会新开一个SqlSession，而一级缓存是依赖于当前SqlSession的，这个很好理解。&lt;/p&gt;

&lt;p&gt;第一次查询，缓存为空
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-bf1cf1c7b15da6e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第二次查询，直接从缓存中获取数据
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-a1814386de179ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第三次查询，执行SqlSession.commit()之后再次查询，缓存被清空，直接从数据库获取。这个很好理解，commit一般就意味着增删改，这时候数据库里面的数据可能就变了，这时候再使用缓存肯定不合适，因为可能拿到的九四脏数据了
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-278fa38f4ea7ba4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看看SqlSession的commi方法，其内部调用了Executor的commit
BaseExecutor#commit&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected PerpetualCache localCache;
protected PerpetualCache localOutputParameterCache;
public void commit(boolean required) throws SQLException {
    if (closed) {
        throw new ExecutorException(&amp;quot;Cannot commit, transaction is already closed&amp;quot;);
    }
    clearLocalCache();
    flushStatements();
    if (required) {
        transaction.commit();
    }
}
public void clearLocalCache() {
    if (!closed) {
        // 清空缓存的key
        localCache.clear();
        localOutputParameterCache.clear();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;二级缓存&#34;&gt;二级缓存&lt;/h3&gt;

&lt;p&gt;二级缓存在Mybatis中默认没有开启，需要手动开启。二级缓存是Namespace级别的缓存，即Mapper级别的缓存，因为一般一个Mapper对应一个Namespace，多个SqlSession去操作同一个Mapper的sql语句的时候，各个SqlSession操作数据库得到数据会存在二级缓存区域，这些SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。以下是测试代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.hand.sxy;

import com.hand.sxy.domain.User;
import com.hand.sxy.mapper.UserMapper;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class Application {
    private static SqlSessionFactory sqlSessionFactory;

    public static void main(String[] args) throws Exception {
        // 1、加载配置文件
        InputStream is = Resources.getResourceAsStream(&amp;quot;application.xml&amp;quot;);

        // 2、构建SqlSessionFactory
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);

        // 测试二级缓存
        levelTwoCache();
    }


    /**
     * 测试二级缓存
     */
    public static void levelTwoCache(){
        SqlSession sqlSession1 = sqlSessionFactory.openSession();
        SqlSession sqlSession2 = sqlSessionFactory.openSession();
        SqlSession sqlSession3 = sqlSessionFactory.openSession();

        // 第一个SqlSession，首次针对该Mapper的查询，没有缓存，执行之后刷新到一级缓存和二级缓存
        UserMapper mapper = sqlSession1.getMapper(UserMapper.class);
        mapper.selectByUserName(&amp;quot;admin&amp;quot;);
        // 一级缓存被清空，二级缓存没有被清空
        sqlSession1.close();


        // 第二个SqlSession，第二次针对该Mapper的查询，直接从二级缓存中获取数据
        UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);
        mapper2.selectByUserName(&amp;quot;admin&amp;quot;);
        // 一级缓存和二级缓存都被清空
        sqlSession2.commit();

        // 第三个SqlSession，第三次针对该Mapper的查询，因为在第二个SqlSession执行了commit方法，二级缓存被清空了
        UserMapper mapper3 = sqlSession3.getMapper(UserMapper.class);
        mapper3.selectByUserName(&amp;quot;admin&amp;quot;);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用Mybatis需要手动开启，即修改配置文件，不过这个在Configuration中默认就是true，不配置应该也关系吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;settings&amp;gt;
    &amp;lt;!-- 开启全局二级缓存，不过cacheEnabled的值在Configuration中默认就是true，所以这里不配置也没关系吧 --&amp;gt;
    &amp;lt;setting name=&amp;quot;cacheEnabled&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，需要在Mapper.xml文件中开启二级缓存，我觉得最关键还是在这里，即添加&amp;lt;cache&amp;gt;标签，该标签上还有一些属性，有兴趣可以了解一下。前面那个配置好像默认就是true，感觉没啥用欸？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;mapper namespace=&amp;quot;com.hand.sxy.mapper.UserMapper&amp;quot;&amp;gt;
    &amp;lt;resultMap id=&amp;quot;BaseResultMap&amp;quot; type=&amp;quot;com.hand.sxy.domain.User&amp;quot;&amp;gt;
        &amp;lt;id column=&amp;quot;USER_ID&amp;quot; property=&amp;quot;userId&amp;quot; jdbcType=&amp;quot;DECIMAL&amp;quot;/&amp;gt;
        &amp;lt;result column=&amp;quot;USERNAME&amp;quot; property=&amp;quot;username&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot;/&amp;gt;
        &amp;lt;result column=&amp;quot;PASSWORD&amp;quot; property=&amp;quot;password&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot;/&amp;gt;
        &amp;lt;result column=&amp;quot;PHONE&amp;quot; property=&amp;quot;phone&amp;quot; jdbcType=&amp;quot;VARCHAR&amp;quot;/&amp;gt;
        &amp;lt;result column=&amp;quot;BIRTH_DATE&amp;quot; property=&amp;quot;birthDate&amp;quot; jdbcType=&amp;quot;DATE&amp;quot;/&amp;gt;
        &amp;lt;result column=&amp;quot;AGE&amp;quot; property=&amp;quot;age&amp;quot; jdbcType=&amp;quot;DECIMAL&amp;quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;!-- 开启本namespace的二级缓存 --&amp;gt;.
    &amp;lt;cache&amp;gt;&amp;lt;/cache&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置之后，就可已经开启了Mybatis的二级缓存，下面测试一下。前面已经说过，SqlSession主要是通过调用Executor来于数据库交互的。下面再复习一下Executor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
    executorType = executorType == null ? defaultExecutorType : executorType;
    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
    Executor executor;
    if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
    } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
    } else {
      executor = new SimpleExecutor(this, transaction);
    }
    
    // 默认为 true
    if (cacheEnabled) {
      // 上面创建的executor作为CachingExecutor中的一个委托类
      executor = new CachingExecutor(executor);
    }
    executor = (Executor) interceptorChain.pluginAll(executor);
    return executor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上上面可以看出，如果我们没有在配置文件中将cacheEnabled设置为false，默认就会创建两个Executor对象，一个是BatchExecutor|ReuseExecutor|ReuseExecutor，另一个是CachingExecutor，前者作为后者的委托类，所以主要还是看看CachingExecutor类中是如何进行调用的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CachingExecutor implements Executor {

  private final Executor delegate;
  private final TransactionalCacheManager tcm = new TransactionalCacheManager();

  public CachingExecutor(Executor delegate) {
    this.delegate = delegate;
    delegate.setExecutorWrapper(this);
  }

  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    Cache cache = ms.getCache();

    // 如果开启了二级缓存，即Mapper.xml文件中有&amp;lt;cache&amp;gt;标签
    if (cache != null) {
      // &amp;lt;select&amp;gt;上的flushCache属性，默认为false。如果设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空
      flushCacheIfRequired(ms);

      // &amp;lt;select&amp;gt;上的useCache属性，默认为true。表示该条语句的结果被二级缓存
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, parameterObject, boundSql);
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
        // 从缓存中拿
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key);

        //  如果缓存中没有，调用委托类的方法，先看一级缓存有没有，没有就从数据库拿
        if (list == null) {
          list = delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
          tcm.putObject(cache, key, list); // issue #578 and #116
        }
        return list;
      }
    }

    //  调用委托类的方法，即上面讲到的一级缓存的那一段逻辑。从这里可以看出，如果开启了二级缓存，会先使用二级缓存
    return delegate.&amp;lt;E&amp;gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }


  private void ensureNoOutParams(MappedStatement ms, Object parameter, BoundSql boundSql) {
    if (ms.getStatementType() == StatementType.CALLABLE) {
      for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {
        if (parameterMapping.getMode() != ParameterMode.IN) {
          throw new ExecutorException(&amp;quot;Caching stored procedures with OUT params is not supported.  Please configure useCache=false in &amp;quot; + ms.getId() + &amp;quot; statement.&amp;quot;);
        }
      }
    }
  }

  // 刷新，即清空缓存，然后从数据库中拿到最新的数据放到缓存中，这里主要是清空缓存，因为这会影响query方法中该行代码之下的逻辑
  private void flushCacheIfRequired(MappedStatement ms) {
    Cache cache = ms.getCache();
    if (cache != null &amp;amp;&amp;amp; ms.isFlushCacheRequired()) {      
      tcm.clear(cache);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要想更深刻的理解缓存，select标签上的一些属性还是非常有必要了解的
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-035dfb93311019b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有关于cache标签的几个属性，也可以看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;cache
  eviction=&amp;quot;FIFO&amp;quot;
  flushInterval=&amp;quot;60000&amp;quot;
  size=&amp;quot;512&amp;quot;
  readOnly=&amp;quot;true&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;eviction 可收回策略。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我觉得二级缓存的作用不大，因为它的限制太多。首先，你要保证针对某个表的更新操作都在一个Mapper.xml文件中，因为二级缓存是针对Mapper来讲的，如果你在别的Mapper中更新这张表的数据，但它原Mapper中的缓存不会更新，这样就产生了脏数据；其次，二级缓存是针对单表的，也就是说，如果你再select中使用了关联查询，这时候使用二级缓存是会出问题的，想想也是可以理解，如果你的SQL中涉及到多个表，在非本Mapper对应的表更新数据时，就不会刷新该缓存。&lt;/p&gt;

&lt;h1 id=&#34;mybatis-spring&#34;&gt;Mybatis-Spring&lt;/h1&gt;

&lt;p&gt;Mybatis只是一个独立的框架，并没有提供与Spring整合的方法，为了在Spring中方便的使用Mybatis，社区提供了一个Mybatis-Spring这个组件。
上面已经说过了：&lt;strong&gt;在Mybatis的所有操作都是基于SqlSession的，而SqlSession是由SqlSessionFactory来产生的，SqlSessionFactory又是由SqlSessionFactoryBuilder来生成的&lt;/strong&gt;。
但是Mybatis-Spring是基于SqlSessionFactoryBean这个类的，这是Mybatis-Spring为我们封装的一个类，不过在这个类里面还是通过SqlSessionFactoryBuilder来建立对应的SqlSessionFactory，进而获取到对应的SqlSession，我们可以通过对SqlSessionFactoryBean指定一些属性来提供Mybatis的一些配置信息。
所以在SSM项目中经常可以在配置文件中看到以下的配置信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;dataSource&amp;quot; class=&amp;quot;org.springframework.jndi.JndiObjectFactoryBean&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;jndiName&amp;quot; value=&amp;quot;java:comp/env/jdbc/hap35&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id=&amp;quot;sqlSessionFactory&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionFactoryBean&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;mapperLocations&amp;quot; value=&amp;quot;classpath*:/**/*Mapper.xml&amp;quot;/&amp;gt;
    // 配置插件
    &amp;lt;property name=&amp;quot;plugins&amp;quot;&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.RequestContextInterceptor&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.MultiLanguageInterceptor&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.SecurityTokenInterceptor&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.OvnInterceptor&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.AuditInterceptor&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.github.pagehelper.PageHelper&amp;quot;/&amp;gt;
            &amp;lt;bean class=&amp;quot;com.hand.hap.core.interceptor.CacheJoinInterceptor&amp;quot;&amp;gt;
                &amp;lt;property name=&amp;quot;cacheJoinType&amp;quot; ref=&amp;quot;cacheJoinType&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/array&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath:mybatis-configuration.xml&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在定义SqlSessionFactoryBean的时候，dataSource属性是必须指定的，它表示用于连接数据库的数据源。当然，我们也可以指定一些其他的属性，下面简单列举几个：
 - &lt;strong&gt;mapperLocations&lt;/strong&gt;
它表示我们的Mapper文件存放的位置，当我们的Mapper文件跟对应的Mapper接口处于同一位置的时候可以不用指定该属性的值。
- &lt;strong&gt;configLocation&lt;/strong&gt;
用于指定Mybatis的配置文件位置。如果指定了该属性，那么会以该配置文件的内容作为配置信息构建对应的SqlSessionFactoryBuilder，但是后续属性指定的内容会覆盖该配置文件里面指定的对应内容。
- &lt;strong&gt;plugins&lt;/strong&gt;
插件，用来指定Mybatis的Interceptor。&lt;/p&gt;

&lt;h4 id=&#34;mapperfactorybean&#34;&gt;MapperFactoryBean&lt;/h4&gt;

&lt;p&gt;用来和Spring做整合用的，它实现了Spring中的FactoryBean接口。有关于FactoryBean接口，这里说明一下：我们知道，我们将Spring容器管理的对象叫做Bean。实现了FactoryBean接口的对象本身也是一个Bean，但它们又很不一样，Spring针对实现了FactoryBean接口的对象做了特殊处理，当我们从Spring容器中获取Bean的时候，一般返回的就是我们需要的那个Bean，但如果你的Bean实现了FactoryBean接口，它返回的不是FactoryBean本身，而是FactoryBean创建的一个Bean。举个例子说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 没有实现FactoryBean接口的Bean，IOC容器中获取该Bean时，返回的是Apple对象
pubic class Apple{
  ......
}


// 实现了FactoryBean接口的Bean，IOC容器中获取该Bean时，实际上返回的是一个 Banana 对象，而不是 Apple
public class Apple implements FactoryBean&amp;lt;T&amp;gt; {

    public T getObject() throws Exception {
        return new Banana();
    }

    public Class&amp;lt;T&amp;gt; getObjectType() {
        return xxx
    }

    public boolean isSingleton() {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，是实现了FactoryBean接口的Bean，实际上返回的是Bean是由它的getObject方法决定的。就因为这个特性，所以才有那么多的插件，这就相当于是Spring预留的一个接口。很明显，MapperFactoryBean也是通过这个来实现Mybatis和Spring的整合的。&lt;/p&gt;

&lt;p&gt;MapperFactoryBean实现了Spring的FactoryBean接口，在getObject定义了获取Mapper对象的逻辑。在定义一个MapperFactoryBean的时候有两个属性需要我们注入，一个是sqlSessionFactory；另一个是对应的Mapper接口了，因此，假如你要在Spring中注册一个Mapper,就需要在Spring的配置文件中添加类似如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// MapperFactoryBean
&amp;lt;bean id=&amp;quot;blogMapper&amp;quot; class=&amp;quot;org.mybatis.spring.mapper.MapperFactoryBean&amp;quot;&amp;gt;  
   &amp;lt;property name=&amp;quot;mapperInterface&amp;quot;  
        value=&amp;quot;com.tiantian.mybatis.mapper.BlogMapper&amp;quot; /&amp;gt;  
    &amp;lt;property name=&amp;quot;sqlSessionFactory&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;  
&amp;lt;/bean&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是MapperFactoryBean的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperFactoryBean&amp;lt;T&amp;gt; extends SqlSessionDaoSupport implements FactoryBean&amp;lt;T&amp;gt; {
    // Mappe接口
    private Class&amp;lt;T&amp;gt; mapperInterface;
    private boolean addToConfig = true;

    public MapperFactoryBean(Class&amp;lt;T&amp;gt; mapperInterface) {
        this.mapperInterface = mapperInterface;
    }

    public MapperFactoryBean() {
    }

    protected void checkDaoConfig() {
        super.checkDaoConfig();
        Assert.notNull(this.mapperInterface, &amp;quot;Property &#39;mapperInterface&#39; is required&amp;quot;);
        Configuration configuration = this.getSqlSession().getConfiguration();
        if (this.addToConfig &amp;amp;&amp;amp; !configuration.hasMapper(this.mapperInterface)) {
            try {
                configuration.addMapper(this.mapperInterface);
            } catch (Exception var6) {
                this.logger.error(&amp;quot;Error while adding the mapper &#39;&amp;quot; + this.mapperInterface + &amp;quot;&#39; to configuration.&amp;quot;, var6);
                throw new IllegalArgumentException(var6);
            } finally {
                ErrorContext.instance().reset();
            }
        }

    }

    // 衔接上了Mybatis中的逻辑，通过getSqlSession获取Mapper代理
    public T getObject() throws Exception {
        // getSqlSession()方法在父抽象类SqlSessionDaoSupport中是实现了，即根据SqlSessionFactory创建了一个SqlSessionTemplate对象
        return this.getSqlSession().getMapper(this.mapperInterface);
    }

    public Class&amp;lt;T&amp;gt; getObjectType() {
        return this.mapperInterface;
    }

    public boolean isSingleton() {
        return true;
    }

    public void setMapperInterface(Class&amp;lt;T&amp;gt; mapperInterface) {
        this.mapperInterface = mapperInterface;
    }

    public Class&amp;lt;T&amp;gt; getMapperInterface() {
        return this.mapperInterface;
    }

    public void setAddToConfig(boolean addToConfig) {
        this.addToConfig = addToConfig;
    }

    public boolean isAddToConfig() {
        return this.addToConfig;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mapperscannerconfigurer&#34;&gt;MapperScannerConfigurer&lt;/h4&gt;

&lt;p&gt;利用上面的方法进行整合的时，我们有一个Mapper就需要定义一个对应的MapperFactoryBean，当我们的Mapper比较少的时候，这样做也还可以，但是当我们的Mapper相当多时我们再这样定义就比较麻烦了。此Mybatis-Spring为我们提供了一个叫做MapperScannerConfigurer的类，通过这个类Mybatis-Spring会自动为我们注册Mapper对应的MapperFactoryBean对象。同样，需要在Spring配置文件中配置MapperScannerConfigurer，对于MapperScannerConfigurer而言有一个属性是我们必须指定的，那就是basePackage，表示这个包下的所有Mapper接口都会被注册，多个包之间可以使用逗号或者分号进行分隔。最简单的MapperScannerConfigurer定义就是只指定一个basePackage属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;mapperScannerConfigurer&amp;quot; class=&amp;quot;com.hand.hap.mybatis.spring.MapperScannerConfigurer&amp;quot;&amp;gt;
    &amp;lt;property name=&amp;quot;basePackage&amp;quot; value=&amp;quot;*.**.mapper&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;processPropertyPlaceHolders&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;property name=&amp;quot;propertiesMap&amp;quot;&amp;gt;
        &amp;lt;map&amp;gt;
            &amp;lt;entry key=&amp;quot;mappers&amp;quot; value=&amp;quot;com.hand.hap.mybatis.common.Mapper&amp;quot;/&amp;gt;
            &amp;lt;entry key=&amp;quot;IDENTITY&amp;quot; value=&amp;quot;${mybatis.identity}&amp;quot;/&amp;gt;
            &amp;lt;entry key=&amp;quot;dataBaseType&amp;quot; value=&amp;quot;${db.type}&amp;quot;/&amp;gt;
            &amp;lt;entry key=&amp;quot;seqFormat&amp;quot; value=&amp;quot;{3}_s.nextVal&amp;quot;/&amp;gt;
            &amp;lt;entry key=&amp;quot;enableMethodAnnotation&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&amp;quot;sqlSessionFactoryBeanName&amp;quot; value=&amp;quot;sqlSessionFactory&amp;quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样MapperScannerConfigurer就会扫描指定基包下面的所有接口，并把它们注册为一个个MapperFactoryBean对象
- &lt;strong&gt;sqlSessionFactory&lt;/strong&gt;
这个属性已经废弃。当我们使用了多个数据源的时候我们就需要通过sqlSessionFactory来指定在注册MapperFactoryBean的时候需要使用的SqlSessionFactory，因为在没有指定sqlSessionFactory的时候，会以Autowired的方式自动注入一个。换言之当我们只使用一个数据源的时候，即只定义了一个SqlSessionFactory的时候我们就可以不给MapperScannerConfigurer指定SqlSessionFactory&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;sqlSessionFactoryBeanName&lt;/strong&gt;：它的功能跟sqlSessionFactory是一样的，只是它指定的是定义好的SqlSessionFactory对应的bean名称&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;sqlSessionTemplate&lt;/strong&gt;
这个属性已经废弃。它的功能也是相当于sqlSessionFactory的，因为就像前面说的那样，MapperFactoryBean最终还是使用的SqlSession的getMapper方法取的对应的Mapper对象。当定义有多个SqlSessionTemplate的时候才需要指定它。对于一个MapperFactoryBean来说SqlSessionFactory和SqlSessionTemplate只需要其中一个就可以了，当两者都指定了的时候，SqlSessionFactory会被忽略&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;sqlSessionTemplateBeanName&lt;/strong&gt;
指定需要使用的sqlSessionTemplate对应的bean名称&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关于MapperScannerConfigurer的源码比较多，这里随便截取一段，在实际项目中，我们其实可以通过实现这个类来满足一些特殊的需求，比如通用Mapper&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean, ApplicationContextAware, BeanNameAware {

  private String basePackage;

  private boolean addToConfig = true;

  private SqlSessionFactory sqlSessionFactory;

  private SqlSessionTemplate sqlSessionTemplate;

  private String sqlSessionFactoryBeanName;

  private String sqlSessionTemplateBeanName;

  private Class&amp;lt;? extends Annotation&amp;gt; annotationClass;

  private Class&amp;lt;?&amp;gt; markerInterface;

  private ApplicationContext applicationContext;

  private String beanName;

  private boolean processPropertyPlaceHolders;

  private BeanNameGenerator nameGenerator;

    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
    if (this.processPropertyPlaceHolders) {
      processPropertyPlaceHolders();
    }

    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
    scanner.setAddToConfig(this.addToConfig);
    scanner.setAnnotationClass(this.annotationClass);
    scanner.setMarkerInterface(this.markerInterface);
    scanner.setSqlSessionFactory(this.sqlSessionFactory);
    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);
    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);
    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);
    scanner.setResourceLoader(this.applicationContext);
    scanner.setBeanNameGenerator(this.nameGenerator);
    scanner.registerFilters();
    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
  }

  .....

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;sqlsessiontemplate&#34;&gt;SqlSessionTemplate&lt;/h4&gt;

&lt;p&gt;除了上述整合之后直接使用Mapper接口之外，Mybatis-Spring还为我们提供了一种直接使用SqlSession的方式。Mybatis-Spring为我们提供了一个实现了SqlSession接口的SqlSessionTemplate类，它是线程安全的，可以被多个Dao同时使用。同时它还跟Spring的事务进行了关联，确保当前被使用的SqlSession是一个已经和Spring的事务进行绑定了的。而且它还可以自己管理Session的提交和关闭。当使用了Spring的事务管理机制后，SqlSession还可以跟着Spring的事务一起提交和回滚。
使用SqlSessionTemplate时我们可以在Spring的applicationContext配置文件中如下定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;bean id=&amp;quot;sqlSession&amp;quot; class=&amp;quot;org.mybatis.spring.SqlSessionTemplate&amp;quot;&amp;gt;
       &amp;lt;constructor-arg index=&amp;quot;0&amp;quot; ref=&amp;quot;sqlSessionFactory&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就可以通过Spring的依赖注入在Dao中直接使用SqlSessionTemplate来编程了，这个时候我们的Dao可能是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.tiantian.mybatis.dao;  
   
import java.util.List;  
import javax.annotation.Resource;  
import org.mybatis.spring.SqlSessionTemplate;  
import org.springframework.stereotype.Repository;  
import com.tiantian.mybatis.model.Blog;  
   
@Repository  
publicclass BlogDaoImpl implements BlogDao {  
   
    private SqlSessionTemplate sqlSessionTemplate;  
   
    publicvoid deleteBlog(int id) {  
       sqlSessionTemplate.delete(&amp;quot;com.tiantian.mybatis.mapper.BlogMapper.deleteBlog&amp;quot;, id);  
    }  
   
    public Blog find(int id) {  
      returnsqlSessionTemplate.selectOne(&amp;quot;com.tiantian.mybatis.mapper.BlogMapper.selectBlog&amp;quot;, id);  
    }  
   
    public List&amp;lt;Blog&amp;gt; find() {  
       returnthis.sqlSessionTemplate.selectList(&amp;quot;com.tiantian.mybatis.mapper.BlogMapper.selectAll&amp;quot;);  
    }  
   
    publicvoid insertBlog(Blog blog) {  
       this.sqlSessionTemplate.insert(&amp;quot;com.tiantian.mybatis.mapper.BlogMapper.insertBlog&amp;quot;, blog);  
    }  
   
    publicvoid updateBlog(Blog blog) {  
       this.sqlSessionTemplate.update(&amp;quot;com.tiantian.mybatis.mapper.BlogMapper.updateBlog&amp;quot;, blog);  
    }  
     
    public SqlSessionTemplate getSqlSessionTemplate() {  
       returnsqlSessionTemplate;  
    }  
     
    @Resource  
    publicvoid setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {  
       this.sqlSessionTemplate = sqlSessionTemplate;  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;通用mapper&#34;&gt;通用Mapper&lt;/h1&gt;

&lt;p&gt;这一节是我的个人小结，可以不用看。主要就是考察MyBatis、Spring、Spring-Mybatis的整合了，考验的就是你对这三个框架的掌握程度，通过结合hap中的源码来分析通用Mapper的实现。首先可以明确需要用到MyBatis中用到的几个注解，其实在上面也已经提到过了：@DeleteProvider、@InsertProvider、@UpdateProvider、@SelectProvider。下面演示一下@SelectProvider注解的使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * 通用Mapper接口,查询
 *
 * @param &amp;lt;T&amp;gt; 不能为空
 * @author liuzh
 */
public interface SelectCountMapper&amp;lt;T&amp;gt; {

    /**
     * 根据实体中的属性查询总数，查询条件使用等号
     *
     * @param record
     * @return
     */
    @SelectProvider(type = BaseSelectProvider.class, method = &amp;quot;dynamicSQL&amp;quot;)
    int selectCount(T record);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class BaseSelectProvider extends MapperTemplate {

    public BaseSelectProvider() {}

    public BaseSelectProvider(Class&amp;lt;?&amp;gt; mapperClass, MapperHelper mapperHelper) {
        super(mapperClass, mapperHelper);
    }
    ......

    public String selectCount(MappedStatement ms) {
        Class&amp;lt;?&amp;gt; entityClass = getEntityClass(ms);
        StringBuilder sql = new StringBuilder();
        sql.append(SqlHelper.selectCount(entityClass));
        sql.append(SqlHelper.fromTable(entityClass, tableName(entityClass)));
        sql.append(SqlHelper.whereAllIfColumns(entityClass, isNotEmpty()));
        return sql.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;演示该注解的使用，只是为了说明可以通过这种方式动态生成SQL，至于怎么生成，那就看自己的需求了。&lt;/p&gt;

&lt;p&gt;hap中重写的MapperScannerConfigurer类，可以把这个当作是入口。org.mybatis.spring.mapper.MapperScannerConfigurer类实现了BeanDefinitionRegistryPostProcessor接口，Spring容器会在实例化开发人员所定义的Bean前先调用该BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry方法。而此处对该方法进行了重写，所以在项目启动的时候，bean实例化之前，会postProcessBeanDefinitionRegistry方法的执行这段逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperScannerConfigurer extends org.mybatis.spring.mapper.MapperScannerConfigurer {
    private MapperHelper mapperHelper = new MapperHelper();


    private Map&amp;lt;String,String&amp;gt; propertiesMap;


    public void setMarkerInterface(Class&amp;lt;?&amp;gt; superClass) {
        super.setMarkerInterface(superClass);
        if (Marker.class.isAssignableFrom(superClass)) {
            mapperHelper.registerMapper(superClass);
        }
    }

    public MapperHelper getMapperHelper() {
        return mapperHelper;
    }

    public void setMapperHelper(MapperHelper mapperHelper) {
        this.mapperHelper = mapperHelper;
    }

    /**
     * 属性注入
     *
     * @param properties
     */
    public void setProperties(Properties properties) {
        // 首先加载config.properties配置文件
        mapperHelper.setProperties(properties);
    }

    public void setPropertiesMap(Map&amp;lt;String, String&amp;gt; propertiesMap) {
        if (propertiesMap.get(&amp;quot;ORDER&amp;quot;) == null) {
            if (&amp;quot;JDBC&amp;quot;.equalsIgnoreCase(propertiesMap.get(&amp;quot;IDENTITY&amp;quot;))) {
                propertiesMap.put(&amp;quot;ORDER&amp;quot;, &amp;quot;AFTER&amp;quot;);
            } else {
                propertiesMap.put(&amp;quot;ORDER&amp;quot;, &amp;quot;BEFORE&amp;quot;);
            }
        }
        this.propertiesMap = propertiesMap;
        //Properties properties = new Properties();
        //propertiesMap.forEach((k, v) -&amp;gt; {
        //    properties.put(k, v);
        //});
        //setProperties(properties);
    }

    /**
     * 注册完成后，对MapperFactoryBean的类进行特殊处理
     *
     * @param registry
     */
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {

        Properties config = new Properties();
        Properties p = new Properties();
        try {
            config.load(getClass().getResourceAsStream(&amp;quot;/config.properties&amp;quot;));
            if (propertiesMap.get(&amp;quot;ORDER&amp;quot;) == null) {
                if (&amp;quot;JDBC&amp;quot;.equalsIgnoreCase(propertiesMap.get(&amp;quot;IDENTITY&amp;quot;))) {
                    p.put(&amp;quot;ORDER&amp;quot;, &amp;quot;AFTER&amp;quot;);
                } else {
                    p.put(&amp;quot;ORDER&amp;quot;, &amp;quot;BEFORE&amp;quot;);
                }
            }
            propertiesMap.forEach((k,v)-&amp;gt;{
                if (v.startsWith(&amp;quot;${&amp;quot;) &amp;amp;&amp;amp; v.endsWith(&amp;quot;}&amp;quot;)) {
                    p.put(k, config.getProperty(v.substring(2, v.length() - 1), v));
                } else {
                    p.put(k, v);
                }
            });
            setProperties(p);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        super.postProcessBeanDefinitionRegistry(registry);
        //如果没有注册过接口，就注册默认的Mapper接口
        this.mapperHelper.ifEmptyRegisterDefaultInterface();
        String[] names = registry.getBeanDefinitionNames();
        GenericBeanDefinition definition;
        for (String name : names) {
            BeanDefinition beanDefinition = registry.getBeanDefinition(name);
            if (beanDefinition instanceof GenericBeanDefinition) {
                definition = (GenericBeanDefinition) beanDefinition;
                if (StringUtil.isNotEmpty(definition.getBeanClassName())
                        &amp;amp;&amp;amp; definition.getBeanClassName().equals(&amp;quot;org.mybatis.spring.mapper.MapperFactoryBean&amp;quot;)) {
                    definition.setBeanClass(MapperFactoryBean.class);
                    definition.getPropertyValues().add(&amp;quot;mapperHelper&amp;quot;, this.mapperHelper);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先加载config.properties配置文件，用于构建一个Properties对象，然后调用MapperHelper中的setProperties方法，这个方法很关键，因为里面涉及到Mapper的加载过程，以下是其实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
    * 配置属性
    *
    * @param properties
    */
public void setProperties(Properties properties) {
    config.setProperties(properties);
    //注册通用接口
    String mapper = null;
    if (properties != null) {
        mapper = properties.getProperty(&amp;quot;mappers&amp;quot;);
    }
    if (StringUtil.isNotEmpty(mapper)) {
        String[] mappers = mapper.split(&amp;quot;,&amp;quot;);
        for (String mapperClass : mappers) {
            if (mapperClass.length() &amp;gt; 0) {
                registerMapper(mapperClass);
            }
        }
    }
}

/**
    * 注册通用Mapper接口
    *
    * @param mapperClass
    */
public void registerMapper(String mapperClass) {
    try {
        registerMapper(Class.forName(mapperClass));
    } catch (ClassNotFoundException e) {
        throw new RuntimeException(&amp;quot;注册通用Mapper[&amp;quot; + mapperClass + &amp;quot;]失败，找不到该通用Mapper!&amp;quot;);
    }
}

/**
    * 注册通用Mapper接口
    *
    * spilledyear
    * 递归 注册 Mapper 的所有父类，registerClass 和 registerMapper 的作用是什么
    *
    * @param mapperClass
    */
public void registerMapper(Class&amp;lt;?&amp;gt; mapperClass) {
    if (!registerMapper.containsKey(mapperClass)) {
        registerClass.add(mapperClass);
            // fromMapperClass 的作用是通用Mapper接口获取对应的MapperTemplate
        registerMapper.put(mapperClass, fromMapperClass(mapperClass));
    }
    //自动注册继承的接口
    Class&amp;lt;?&amp;gt;[] interfaces = mapperClass.getInterfaces();
    if (interfaces != null &amp;amp;&amp;amp; interfaces.length &amp;gt; 0) {
        for (Class&amp;lt;?&amp;gt; anInterface : interfaces) {
            registerMapper(anInterface);
        }
    }
}


// com.hand.hap.mybatis.common.Mapper
public interface Mapper&amp;lt;T&amp;gt; extends
        BaseMapper&amp;lt;T&amp;gt;,
        ExampleMapper&amp;lt;T&amp;gt;,
        RowBoundsMapper&amp;lt;T&amp;gt;,
        Marker {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MapperFactoryBean的继承关系如下
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-1b200e8f2f37bb66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class DaoSupport implements InitializingBean {
    protected final Log logger = LogFactory.getLog(this.getClass());

    public DaoSupport() {
    }

    public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException {
        this.checkDaoConfig();

        try {
            this.initDao();
        } catch (Exception var2) {
            throw new BeanInitializationException(&amp;quot;Initialization of DAO failed&amp;quot;, var2);
        }
    }
......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，在初始化实例之后，会调用MapperFactoryBean的checkDaoConfig方法，如果是通用Mappper，就会调用mapperHelper的processConfiguration方法重新设置SqlSource。也就是根据各个provider动态生成SQL，然后创建一个SqlSource，然后根据Mybatis中的MappedStatement重新设置SqlSource，这样就达到了通用SQl的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MapperFactoryBean&amp;lt;T&amp;gt; extends org.mybatis.spring.mapper.MapperFactoryBean&amp;lt;T&amp;gt; {

    private MapperHelper mapperHelper;

    public MapperFactoryBean() {
    }

    public MapperFactoryBean(Class&amp;lt;T&amp;gt; mapperInterface) {
        super(mapperInterface);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void checkDaoConfig() {
        super.checkDaoConfig();
        //通用Mapper
        if (mapperHelper.isExtendCommonMapper(getObjectType())) {
            mapperHelper.processConfiguration(getSqlSession().getConfiguration(), getObjectType());
        }
    }

    public void setMapperHelper(MapperHelper mapperHelper) {
        this.mapperHelper = mapperHelper;
    }
}


/**
  * 配置指定的接口
  *
  * @param configuration
  * @param mapperInterface
  */
public void processConfiguration(Configuration configuration, Class&amp;lt;?&amp;gt; mapperInterface) {
    String prefix;
    if (mapperInterface != null) {
         prefix = mapperInterface.getCanonicalName();
    } else {
        prefix = &amp;quot;&amp;quot;;
    }
    for (Object object : new ArrayList&amp;lt;Object&amp;gt;(configuration.getMappedStatements())) {
        if (object instanceof MappedStatement) {
            MappedStatement ms = (MappedStatement) object;
            if (ms.getId().startsWith(prefix) &amp;amp;&amp;amp; isMapperMethod(ms.getId())) {
                if (ms.getSqlSource() instanceof ProviderSqlSource) {
                    setSqlSource(ms);
                }
            }
        }
    }
}


/**
  * 重新设置SqlSource
  * &amp;lt;p/&amp;gt;
  * 执行该方法前必须使用isMapperMethod判断，否则msIdCache会空
  * msIdCache 里面缓存了 MappedStatement对象的 key
  *
  * @param ms
  */
public void setSqlSource(MappedStatement ms) {
    MapperTemplate mapperTemplate = msIdCache.get(ms.getId());
    try {
        if (mapperTemplate != null) {
            mapperTemplate.setSqlSource(ms);
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;configuration.getMappedStatements()的作用是获取所有的MappedStatement对象，一个MappedStatement对象对应Mapper中的一个接口。上面代码的意思就是当找到符合要求的MappedStatement对象时，就重新设置SqlSource。&lt;/p&gt;

&lt;p&gt;而重新设置SqlSource的具体逻辑则是交给MapperTemplate的setSqlSource方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * 重新设置SqlSource
     *
     * @param ms
     * @throws java.lang.reflect.InvocationTargetException
     * @throws IllegalAccessException
     */
    public void setSqlSource(MappedStatement ms) throws Exception {
        if (this.mapperClass == getMapperClass(ms.getId())) {
            throw new RuntimeException(&amp;quot;请不要配置或扫描通用Mapper接口类：&amp;quot; + this.mapperClass);
        }
        Method method = methodMap.get(getMethodName(ms));
        try {
            //第一种，直接操作ms，不需要返回值
            if (method.getReturnType() == Void.TYPE) {
                method.invoke(this, ms);
            }
            //第二种，返回SqlNode
            else if (SqlNode.class.isAssignableFrom(method.getReturnType())) {
                SqlNode sqlNode = (SqlNode) method.invoke(this, ms);
                DynamicSqlSource dynamicSqlSource = new DynamicSqlSource(ms.getConfiguration(), sqlNode);
                setSqlSource(ms, dynamicSqlSource);
            }
            //第三种，返回xml形式的sql字符串
            else if (String.class.equals(method.getReturnType())) {
                String xmlSql = (String) method.invoke(this, ms);
                SqlSource sqlSource = createSqlSource(ms, xmlSql);
                //替换原有的SqlSource
                setSqlSource(ms, sqlSource);
            } else {
                throw new RuntimeException(&amp;quot;自定义Mapper方法返回类型错误,可选的返回类型为void,SqlNode,String三种!&amp;quot;);
            }
            //cache
            checkCache(ms);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e.getTargetException() != null ? e.getTargetException() : e);
        }
    }

    /**
     * 重新设置SqlSource，同时判断如果是Jdbc3KeyGenerator，就设置为MultipleJdbc3KeyGenerator
     *
     * @param ms
     * @param sqlSource
     */
    protected void setSqlSource(MappedStatement ms, SqlSource sqlSource) {
        MetaObject msObject = SystemMetaObject.forObject(ms);
        msObject.setValue(&amp;quot;sqlSource&amp;quot;, sqlSource);
        //如果是Jdbc3KeyGenerator，就设置为MultipleJdbc3KeyGenerator
        KeyGenerator keyGenerator = ms.getKeyGenerator();
        if (keyGenerator instanceof Jdbc3KeyGenerator) {
            msObject.setValue(&amp;quot;keyGenerator&amp;quot;, new MultipleJdbc3KeyGenerator());
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里根据各个Provider中方法的返回类型执行不同的逻辑，这里以BaseSelectProvider中的 selectCount方法为例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BaseSelectProvider extends MapperTemplate {
    /**
     * 查询总数
     *
     * @param ms
     * @return
     */
    public String selectCount(MappedStatement ms) {
        Class&amp;lt;?&amp;gt; entityClass = getEntityClass(ms);
        StringBuilder sql = new StringBuilder();
        sql.append(SqlHelper.selectCount(entityClass));
        sql.append(SqlHelper.fromTable(entityClass, tableName(entityClass)));
        sql.append(SqlHelper.whereAllIfColumns(entityClass, isNotEmpty()));
        return sql.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是返回一个字符串SQL，至于SQL是怎么拼接出来的，这里不做过多介绍，有兴趣的可以追一下代码，并不复杂。返回字符串之后就重新创建一个SqlSource，然后将新的SqlSource设置给MappedStatement对象。&lt;/p&gt;

&lt;p&gt;在hap中，我们自定义的Mapper接口一般都会继承com.hand.hap.mybatis.common.Mapper接口，这样就间接拥有了com.hand.hap.mybatis.common.Mapper接口中的所有方法。但是这些继承的方法在一开始的时候其实是没有任何意义的，只有在执行了MapperFactoryBean的checkDaoConfig方法之后，才会动态生成SQL，然后创建新的SqlSource对象，并依次覆盖MappedStatement对象中的SqlSource对象，这时候这些继承过来的方法来变得有意义。&lt;/p&gt;

&lt;p&gt;有关于hap中的EntityHelper、MapperHelper、SqlHelper、MapperTemplate等类以及一些注解的用法还是值得学习一下的，在动态生成SQL的时候，主要就是应用到了这些东西。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>SpringMVC</title>
      <link>https://www.spilledyear.cn/post/springmvc/</link>
      <pubDate>Sun, 12 Aug 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/springmvc/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/202.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;contextloaderlistener&#34;&gt;ContextLoaderListener&lt;/h1&gt;

&lt;p&gt;新建一个SSM应用的时候，一般会在web.xml文件中添加以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;web-app version=&amp;quot;3.0&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/javaee&amp;quot;
         xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&amp;quot;&amp;gt;
    &amp;lt;display-name&amp;gt;hand-hap&amp;lt;/display-name&amp;gt;
    &amp;lt;description&amp;gt;hand-hap&amp;lt;/description&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath*:/spring/applicationContext*.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;default&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextInitializerClasses&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;com.hand.hap.core.CustomApplicationContextInitializer&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;

    &amp;lt;!-- 和整合Spring相关 --&amp;gt;
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
    &amp;lt;/listener&amp;gt;

    &amp;lt;!-- 和SpringMVC相关 --&amp;gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;appServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:/spring/appServlet/servlet*.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
        &amp;lt;async-supported&amp;gt;true&amp;lt;/async-supported&amp;gt;
    &amp;lt;/servlet&amp;gt;

    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;appServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
    
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始化顺寻：Listene &amp;gt; Filter &amp;gt; Servlet&lt;/p&gt;

&lt;p&gt;ContextLoaderListener实现了Servlet标准中的ServletContextListener接口，说明它会监听ServletContext对象的创建和销毁&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent event) {
		initWebApplicationContext(event.getServletContext());
	}


	/**
	 * Close the root web application context.
	 */
	@Override
	public void contextDestroyed(ServletContextEvent event) {
		closeWebApplicationContext(event.getServletContext());
		ContextCleanupListener.cleanupAttributes(event.getServletContext());
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在应用启动的时候，会执行contextInitialized方法，从而调用initWebApplicationContext方法创建spring容器。initWebApplicationContext方法在父类ContextLoader中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    // 如果servletContext中已经有spring上下文了，则抛出异常
    if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {
        throw new IllegalStateException(
                &amp;quot;Cannot initialize context because there is already a root application context present - &amp;quot; +
                &amp;quot;check whether you have multiple ContextLoader* definitions in your web.xml!&amp;quot;);
    }

    long startTime = System.currentTimeMillis();
    try {
        if (this.context == null) {
            // 创建WebApplicationContext
            this.context = createWebApplicationContext(servletContext);
        }

        if (this.context instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;
            if (!cwac.isActive()) {
                // The context has not yet been refreshed -&amp;gt; provide services such as
                // setting the parent context, setting the application context id, etc
                if (cwac.getParent() == null) {
                    // 设置父容器
                    ApplicationContext parent = loadParentContext(servletContext);
                    cwac.setParent(parent);
                }
                // 配置WebApplicationContext，即执行refresh方法，前面仅仅是创建了一个WebApplicationContext，这里相当于是配置
                configureAndRefreshWebApplicationContext(cwac, servletContext);
            }
        }

// 将创建的WebApplicationContext放到ServletContext中，key为WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE；
servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);

        ClassLoader ccl = Thread.currentThread().getContextClassLoader();
        if (ccl == ContextLoader.class.getClassLoader()) {
            currentContext = this.context;
        }
        else if (ccl != null) {
            // 将创建的WebApplicationContext放到currentContextPerThread中
            currentContextPerThread.put(ccl, this.context);
        }

        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Published root WebApplicationContext as ServletContext attribute with name [&amp;quot; +
                    WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &amp;quot;]&amp;quot;);
        }
        if (logger.isInfoEnabled()) {
            long elapsedTime = System.currentTimeMillis() - startTime;
            logger.info(&amp;quot;Root WebApplicationContext: initialization completed in &amp;quot; + elapsedTime + &amp;quot; ms&amp;quot;);
        }

        return this.context;
    }
    catch (RuntimeException ex) {
        logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
        throw ex;
    }
    catch (Error err) {
        logger.error(&amp;quot;Context initialization failed&amp;quot;, err);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);
        throw err;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来看看createWebApplicationContext方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext createWebApplicationContext(ServletContext sc) {
    Class&amp;lt;?&amp;gt; contextClass = determineContextClass(sc);
    if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {
        throw new ApplicationContextException(&amp;quot;Custom context class [&amp;quot; + contextClass.getName() +
                &amp;quot;] is not of type [&amp;quot; + ConfigurableWebApplicationContext.class.getName() + &amp;quot;]&amp;quot;);
    }
    return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
}

protected Class&amp;lt;?&amp;gt; determineContextClass(ServletContext servletContext) {
    // 先尝试从配置文件的初始化参数CONTEXT_CLASS_PARAM(即&amp;quot;contextClass&amp;quot;)中获取contextClassName
    String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);

    // 如果配置了contextClass，就用配置的类实例化
    if (contextClassName != null) {
        try {
            return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
        }
        catch (ClassNotFoundException ex) {
            throw new ApplicationContextException(
                    &amp;quot;Failed to load custom context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);
        }
    }

    // 如果没有配置contextClass，就就默认的org.springframework.web.context.support.XmlWebApplicationContext实例化
    else {
        contextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());
        try {
            return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());
        }
        catch (ClassNotFoundException ex) {
            throw new ApplicationContextException(
                    &amp;quot;Failed to load default context class [&amp;quot; + contextClassName + &amp;quot;]&amp;quot;, ex);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面用到了一个defaultStrategies，可以看看相关的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final String DEFAULT_STRATEGIES_PATH = &amp;quot;ContextLoader.properties&amp;quot;;
private static final Properties defaultStrategies;
static {
    try {
        ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);
        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);
    }
    catch (IOException ex) {
        throw new IllegalStateException(&amp;quot;Could not load &#39;ContextLoader.properties&#39;: &amp;quot; + ex.getMessage());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果没有配置contextClass，就使用默认的在ContextLoader.properties文件中的XmlWebApplicationContext&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要对容器进行一些配置的操作还是在configureAndRefreshWebApplicationContext方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
    if (ObjectUtils.identityToString(wac).equals(wac.getId())) {
        // 如果配置了context id，就设置context id
        String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);
        if (idParam != null) {
            wac.setId(idParam);
        }

        // 如果没有配置context id，则自动生成一个context id
        else {
            // Generate default id...
            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +
                    ObjectUtils.getDisplayString(sc.getContextPath()));
        }
    }

    // ServletContext 和 WebApplicationContext好像是相互引用的
    wac.setServletContext(sc);

    // 读取web.xml中配置的配置文件位置
    String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);
    if (configLocationParam != null) {
        wac.setConfigLocation(configLocationParam);
    }
  
    ConfigurableEnvironment env = wac.getEnvironment();
    if (env instanceof ConfigurableWebEnvironment) {
        // 获取当前环境ConfigurableEnvironment，便于后续根据profiles来解析属性
        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);
    }
    // 执行refresh方法之前的一些初始化工作
    customizeContext(sc, wac);

    // AbstractApplicationContext中的refresh方法，最关键的方法，执行完这个方法spring容器就完成了
    wac.refresh();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;dispatcherservlet&#34;&gt;DispatcherServlet&lt;/h1&gt;

&lt;p&gt;首先看看的继承关系图
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-5d1c2961ca7cade3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据我们对Servlet的了解，Servlet主要有3个阶段：初始化、运行、销毁。
1. 初始化阶段
Servlet容器加载Servlet类，把Servlet类的.class文件读到内存中；
Servlet容器拆个那就一个ServletConfig对象，ServletConfig对象包含了Servlet的初始化配置信息；
Servlet创建一个Servlet对象；
Servlet容器调用Servlet对象的init方法进行初始化；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;运行阶段
当Servlet容器接收到一个请求时，Servlet容器会针对这个请求创建ServletRequest和ServletResponse对象，然后调用service方法。service方法根据ServletRequest获取请求信息，然后再通过ServletResponse对象生成请求的响应结果，然后销毁ServletRequest和ServletResponse对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;销毁阶段
当web应用被终止时，Servlet容器会先调用servlet对象的destroy方法，然后再销毁Servlet对象，同时也会销毁与Servlet对象相关的ServletConfig对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据上面的继承关系图和对源码的跟踪，init方法其实是在HttpServletBean方法中
HttpServletBean#init&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final void init() throws ServletException {
    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Initializing servlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot;);
    }

    // Set bean properties from init parameters.
    try {
        // 解析 init-param 并封装在 pvs 中
        PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);
 
        // 将当前的servlet类转化成一个BeanWrapper，从而能够以Spring的方式对 init-param 的值进行注入
        BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);
        ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());

        // 注册自定义属性编辑器，一旦遇到Resource类型的属性将会使用ResourceEditor进行解析
        bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));

        // 空实现，留给子类覆盖
        initBeanWrapper(bw);

        // 属性注入
        bw.setPropertyValues(pvs, true);
    }
    catch (BeansException ex) {
        logger.error(&amp;quot;Failed to set bean properties on servlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot;, ex);
        throw ex;
    }

    // Let subclasses do whatever initialization they like.
    // 留给子类扩展，FrameworkServlet覆盖了这个方法，实际上，初始化主要逻辑就在FrameworkServlet的initServletBean方法中
    initServletBean();

    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Servlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39; configured successfully&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FrameworkServlet#initServletBean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final void initServletBean() throws ServletException {
    getServletContext().log(&amp;quot;Initializing Spring FrameworkServlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot;);
    if (this.logger.isInfoEnabled()) {
        this.logger.info(&amp;quot;FrameworkServlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;: initialization started&amp;quot;);
    }
    long startTime = System.currentTimeMillis();

    try {
        // 关键的初始化逻辑，对ContextloaderListener中创建的webApplicationContext进一步补充初始化
        this.webApplicationContext = initWebApplicationContext();

        // 用于子类覆盖
        initFrameworkServlet();
    }
    catch (ServletException ex) {
        this.logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
        throw ex;
    }
    catch (RuntimeException ex) {
        this.logger.error(&amp;quot;Context initialization failed&amp;quot;, ex);
        throw ex;
    }

    if (this.logger.isInfoEnabled()) {
        long elapsedTime = System.currentTimeMillis() - startTime;
        this.logger.info(&amp;quot;FrameworkServlet &#39;&amp;quot; + getServletName() + &amp;quot;&#39;: initialization completed in &amp;quot; +
                elapsedTime + &amp;quot; ms&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FrameworkServlet#initWebApplicationContext&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected WebApplicationContext initWebApplicationContext() {
    WebApplicationContext rootContext =
            WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    WebApplicationContext wac = null;

    if (this.webApplicationContext != null) {
        // A context instance was injected at construction time -&amp;gt; use it
        // context 实例在构造函数中注入
        wac = this.webApplicationContext;
        if (wac instanceof ConfigurableWebApplicationContext) {
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
            if (!cwac.isActive()) {
                // The context has not yet been refreshed -&amp;gt; provide services such as
                // setting the parent context, setting the application context id, etc
                if (cwac.getParent() == null) {
                    // The context instance was injected without an explicit parent -&amp;gt; set
                    // the root application context (if any; may be null) as the parent
                    cwac.setParent(rootContext);
                }

                // 配置和刷新上下文环境
                configureAndRefreshWebApplicationContext(cwac);
            }
        }
    }
    if (wac == null) {
        // No context instance was injected at construction time -&amp;gt; see if one
        // has been registered in the servlet context. If one exists, it is assumed
        // that the parent context (if any) has already been set and that the
        // user has performed any initialization such as setting the context id

        // 根据 contextAttribute 属性加载 webApplicationContext
        wac = findWebApplicationContext();
    }
    if (wac == null) {
        // No context instance is defined for this servlet -&amp;gt; create a local one
        // 如果以上两种方式都没有找到 webApplicationContext 实例，则在这里创建一个
        wac = createWebApplicationContext(rootContext);
    }

    if (!this.refreshEventReceived) {
        // Either the context is not a ConfigurableApplicationContext with refresh
        // support or the context injected at construction time had already been
        // refreshed -&amp;gt; trigger initial onRefresh manually here.

        // 提供的模板方法，在 DispatcherServlet 重写了该方法主要用于刷新Spring在web功能中锁必须实现的全局变量
        onRefresh(wac);
    }

    if (this.publishContext) {
        // Publish the context as a servlet context attribute.
        String attrName = getServletContextAttributeName();
        getServletContext().setAttribute(attrName, wac);
        if (this.logger.isDebugEnabled()) {
            this.logger.debug(&amp;quot;Published WebApplicationContext of servlet &#39;&amp;quot; + getServletName() +
                    &amp;quot;&#39; as ServletContext attribute with name [&amp;quot; + attrName + &amp;quot;]&amp;quot;);
        }
    }

    return wac;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DispatcherServlet#onRefresh&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected void onRefresh(ApplicationContext context) {
    initStrategies(context);
}

/**
 * Initialize the strategy objects that this servlet uses.
 * &amp;lt;p&amp;gt;May be overridden in subclasses in order to initialize further strategy objects.
 */
protected void initStrategies(ApplicationContext context) {
    // 初始化MultipartResolver，用于处理文件上传
    initMultipartResolver(context);
    // 初始化LocaleResolver，国际化
    initLocaleResolver(context);
    // 初始化ThemeResolver，通过主题ThemeResolver来控制网页风格
    initThemeResolver(context);
    // 初始化HandlerMappings，当客户端发出Request时，DispatcherServlet将Resuest交给HandlerMapping，然后HandlerMapping根据WebApplicationContext的配置来回传给DispatcherServlet相应的Controller
    initHandlerMappings(context);
    // 初始化HandlerAdapters，适配当前的Http请求
    initHandlerAdapters(context);
    // 初始化HandlerExceptionResolvers，Spring会搜索所有注册在其环境中的实现了HandlerExceptionResolvers接口的bean，逐个执行，直到返回一个ModelAndView对象
    initHandlerExceptionResolvers(context);
    // 初始化RequestToViewNameTranslator，当在Controller中没有返回一个View对象或逻辑视图名称，并且在该方法中没有直接往response的输出流里写数据时，Spring就会采用约定好的提供一个逻辑视图名称
    initRequestToViewNameTranslator(context);
    // 初始化ViewResolvers，当Controller将请求处理结果放入ModelAndView中以后，DispatcherServlet会根据ModelAndView选择合适的试图进行渲染
    initViewResolvers(context);
    // 初始化FlashMapManager，Flash Attribute提供了一个请求存储属性，可供其它请求使用，在重定向时非常必要
    initFlashMapManager(context);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dispatcherservlet对请求的处理&#34;&gt;DispatcherServlet对请求的处理&lt;/h3&gt;

&lt;p&gt;doGet方法和doPost方法都在FrameworkServlet中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
protected final void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    processRequest(request, response);
}

/**
    * Delegate POST requests to {@link #processRequest}.
    * @see #doService
    */
@Override
protected final void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    processRequest(request, response);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;FrameworkServlet#processRequest&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final void processRequest(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    // 记录当前时间，用于计算web请求的处理时间       
    long startTime = System.currentTimeMillis();
    Throwable failureCause = null;

    // 为了保证当前线程的LocaleContext以及RequestAttributes可以在当前请求后还能恢复，体取当前线程得了两个属性
    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
    // 根据当前request创建对应的LocaleContext以及RequestAttributes，并绑定到当前线程
    LocaleContext localeContext = buildLocaleContext(request);

    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());

    initContextHolders(request, localeContext, requestAttributes);

    try {
        // 委托doService方法进行处理
        doService(request, response);
    }
    catch (ServletException ex) {
        failureCause = ex;
        throw ex;
    }
    catch (IOException ex) {
        failureCause = ex;
        throw ex;
    }
    catch (Throwable ex) {
        failureCause = ex;
        throw new NestedServletException(&amp;quot;Request processing failed&amp;quot;, ex);
    }

    finally {
        resetContextHolders(request, previousLocaleContext, previousAttributes);
        if (requestAttributes != null) {
            requestAttributes.requestCompleted();
        }

        if (logger.isDebugEnabled()) {
            if (failureCause != null) {
                this.logger.debug(&amp;quot;Could not complete request&amp;quot;, failureCause);
            }
            else {
                if (asyncManager.isConcurrentHandlingStarted()) {
                    logger.debug(&amp;quot;Leaving response open for concurrent processing&amp;quot;);
                }
                else {
                    this.logger.debug(&amp;quot;Successfully completed request&amp;quot;);
                }
            }
        }
        // 无论请求成功失败，发通知
        publishRequestHandledEvent(request, response, startTime, failureCause);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet#doService&lt;/strong&gt;
这个方法主要时做一些准备工作，比如将 localResolver 、 themeResolveer 等设置在request属性中，真正的逻辑在doDispatch方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
    if (logger.isDebugEnabled()) {
        String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? &amp;quot; resumed&amp;quot; : &amp;quot;&amp;quot;;
        logger.debug(&amp;quot;DispatcherServlet with name &#39;&amp;quot; + getServletName() + &amp;quot;&#39;&amp;quot; + resumed +
                &amp;quot; processing &amp;quot; + request.getMethod() + &amp;quot; request for [&amp;quot; + getRequestUri(request) + &amp;quot;]&amp;quot;);
    }

    // Keep a snapshot of the request attributes in case of an include,
    // to be able to restore the original attributes after the include.
    Map&amp;lt;String, Object&amp;gt; attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) {
        attributesSnapshot = new HashMap&amp;lt;String, Object&amp;gt;();
        Enumeration&amp;lt;?&amp;gt; attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith(&amp;quot;org.springframework.web.servlet&amp;quot;)) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

    // 将 localResolver 、 themeResolveer 等设置在request属性中
    // Make framework objects available to handlers and view objects.
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
    if (inputFlashMap != null) {
        request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
    }
    request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
    request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);

    try {
        // 真正的请求跳转等逻辑
        doDispatch(request, response);
    }
    finally {
        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            // Restore the original attribute snapshot, in case of an include.
            if (attributesSnapshot != null) {
                restoreAttributesAfterInclude(request, attributesSnapshot);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet#doDispatch&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            // 如果是MultipartContent类型的request，则转换request为MultipartHttpRequest类型的request
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            // 根据request信息寻找对应的Handler
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null || mappedHandler.getHandler() == null) {
                // 如果没有找到Handler，则通过response返回错误信息
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
            // 根据handle寻找对应的handlerAdapter
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            // 如果当前handler支持 last-modified 头处理，缓存处理
            String method = request.getMethod();
            boolean isGet = &amp;quot;GET&amp;quot;.equals(method);
            if (isGet || &amp;quot;HEAD&amp;quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (logger.isDebugEnabled()) {
                    logger.debug(&amp;quot;Last-Modified value for [&amp;quot; + getRequestUri(request) + &amp;quot;] is: &amp;quot; + lastModified);
                }
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {
                    return;
                }
            }

            // 拦截器的preHandle方法调用
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            // 真正激活handler并返回试图
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }
            
            // 试图名称转换用于需要添加前后缀的情况
            applyDefaultViewName(processedRequest, mv);

            // 应用所有拦截器的postHandle方法
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we&#39;re processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&amp;quot;Handler dispatch failed&amp;quot;, err);
        }

        // 返回结果处理
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                new NestedServletException(&amp;quot;Handler processing failed&amp;quot;, err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;DispatcherServlet#processDispatchResult&lt;/strong&gt;
processDispatchResult方法在doDispatch方法中被调用，用于处理返回结果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug(&amp;quot;ModelAndViewDefiningException encountered&amp;quot;, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Did the handler return a view to render?
    // 如果Handler 实例的处理中返回了view，那么需要做页面的处理
    if (mv != null &amp;amp;&amp;amp; !mv.wasCleared()) {
        // 处理页面跳转
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Null ModelAndView returned to DispatcherServlet with name &#39;&amp;quot; + getServletName() +
                    &amp;quot;&#39;: assuming HandlerAdapter completed request handling&amp;quot;);
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        // 完成处理激活触发器
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>SpringAOP</title>
      <link>https://www.spilledyear.cn/post/springaop/</link>
      <pubDate>Sun, 05 Aug 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/springaop/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/267.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要是解析Spring AOP的运作流程。
上次讲到Java中的两种动态代理技术：JDK动态代理和CGLIB动态代理，也简单分析了他们的实现原理，这篇文章主要是介绍基于动态代理的Spring AOP 技术。AOP是一个规范，Spring AOP仅仅是AOP的一种实现，是为了方便我们在spring应用中使用AOP技术。相对应的，AspectJ是另一个由Java实现的AOP框架，它更专业，功能也更强大，可以与Java无缝对接，因此我们需要简单了解一下AspectJ，但这并不代表Spring AOP和AspectJ有什么必然联系，事实上，Spring AOP的底层实现和AspectJ没有任何关系，只是他们在使用的时候有一些相似的地方罢了，使用过就能体会到了。&lt;/p&gt;

&lt;h1 id=&#34;aspectj&#34;&gt;AspectJ&lt;/h1&gt;

&lt;h4 id=&#34;前置条件&#34;&gt;前置条件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;aspectjtools-1.9.0.jar&lt;/li&gt;
&lt;li&gt;aspectjrt-1.5.3.jar&lt;/li&gt;
&lt;li&gt;IDEA 2018.2&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;工程准备&#34;&gt;工程准备&lt;/h4&gt;

&lt;p&gt;这里很有必要提一下IDEA的版本：2018.2，如果你用的是这个版本，那么IDEA自带了AspectJ Support 插件 和 Spring AOP/@AspectJ 插件，其他的版本我不知道，如果没有的话就自己安装，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_002.png&#34; alt=&#34;post_002&#34; /&gt;&lt;/p&gt;

&lt;p&gt;aspectjtools-1.9.0.jar 和 aspectjrt-1.5.3.jar 这两个jar包分别有不同的作用。aspectjtools-1.9.0.jar里面有Ajc编译器，而aspectjrt-1.5.3.jar是一个依赖包。
装好这两个插件之后，修改以下配置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_003.png&#34; alt=&#34;post_003&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们使用Ajc编译器，因为Ajc编译器既能编译AspectJ语法，又可以编译java语法，而Javac只能编译java语法。&lt;/p&gt;

&lt;h5 id=&#34;基本概念&#34;&gt;基本概念&lt;/h5&gt;

&lt;p&gt;这部分内容我不想过多说明，如果不理解的可以网上查一下资料，主要有以下概念：
- JoinPoint：连接点，即哪些目标函数可以被拦截。
- PointCut：切点，对哪些连接点进行切入。
- Advice：通知，在切点上要执行的动作。前置、后置、环绕、后置返回、异常。
- Aspect：切面，切点和通知的组合体。
- Weaving：织入，把切面代码织入到目标函数的过程。&lt;/p&gt;

&lt;h4 id=&#34;测试案例&#34;&gt;测试案例&lt;/h4&gt;

&lt;p&gt;我们首先新建一个Java工程，然后引入我们刚刚下载aspectjrt-1.5.3.jar，怎么引入不限制，你直接下载jar包然后引入，也可以通过maven，也可以通过其他手段。
为了测试，我这里新建了以下几个类：Hello、AspectGrammar、AspectJJava&lt;/p&gt;

&lt;p&gt;Hello是我们的目标类，剩下的是两个切面，一个用AspectJ语法实现，一个用Java语法实现。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Hello {
    public void sayHello(){
        System.out.println(&amp;quot;目标方法 say hello&amp;quot;);
    }

    public static void main(String[] args) {
        Hello h = new Hello();
        h.sayHello();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//切面1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public aspect AspectGrammar {

    /**
     * 第一种写法，不通过pointcut
     */
    void around():call(void Hello.sayHello()){
        System.out.println(&amp;quot;【AspectJ语法添加通知】 sayHello方法环绕通知&amp;quot;);
        proceed();
        System.out.println(&amp;quot;【AspectJ语法添加通知】 sayHello方法环绕通知&amp;quot;);
    }



    /**
     * 第二种写法，通过pointcut
     */
    pointcut recordLog():call(* Hello.sayHello(..));


    /**
     * 定义前置通知!
     */
    before():recordLog(){
        System.out.println(&amp;quot;【AspectJ语法添加通知】 sayHello方法执行前 输出日志&amp;quot;);
    }

    /**
     * 定义后置通知
     */
    after():recordLog(){
        System.out.println(&amp;quot;【AspectJ语法添加通知】 sayHello方法执行后 输出日志&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//切面2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class AspectJJava {
    @Pointcut(&amp;quot;execution(* *.sayHello(..))&amp;quot;)
    private void pointcut(){}

    @Before(value=&amp;quot;pointcut()&amp;quot;)
    public void beforeAdvice(){
        System.out.println(&amp;quot;【AspectJ语法添加通知】 前置通知&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接执行 Hello的main方法，结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_004.png&#34; alt=&#34;post_004&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;工作原理&#34;&gt;工作原理&lt;/h4&gt;

&lt;p&gt;网上找到的一张图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_005.png&#34; alt=&#34;post_005&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ApectJ主要采用的是编译期织入，在这个期间使用AspectJAjc编译器aspect类编译成clas字节码后，在java目标类编译时织入，即先编aspect类再编译目标类。
我们可以看一下编译后的class文件，很明显被修改过了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_006.png&#34; alt=&#34;post_006&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显然AspectJ的织入原理已很明朗了，当然除了编译期织入，还存在链接期(编译后)织入，即将aspect类和java目标类同时编译成字节码文件后，再进行织入处理，这种方式比较有助于已编译好的第三方jar和Class文件进行织入操作，有兴趣的同学可以了解一下。&lt;/p&gt;

&lt;p&gt;AspectJ的这种织入方式我们称之为静态植入，与之对应的还有动态织入，Sring AOP就是采用的动态织入。动态织入的方式是在运行时动态将要增强的代码织入到目标类中，这样往往是通过动态代理技术完成的，如Java JDK的动态代理或者是CGLIB动态代理。至于这两种动态代理之间的区别，我们前面的文章已经介绍过了，Spring AOP为了满足不同场景下的代理需求，两种动态代理技术都用到了，下面详细介绍Spring AOP的实现原理。&lt;/p&gt;

&lt;h1 id=&#34;spring-aop&#34;&gt;Spring AOP&lt;/h1&gt;

&lt;p&gt;Spring AOP的使用有两种方法，一种是基于XML配置文件，一种是基于注解。可以根据自己的兴趣来选择，不过一般是选择使用注解的方式，简单直观，XML太繁琐了。Spring AOP一般是结合IOC一起使用的，如果想全面了解Spring AOP的原理，对IOC的掌握也需要有一定要求。&lt;/p&gt;

&lt;h4 id=&#34;整体流程&#34;&gt;整体流程&lt;/h4&gt;

&lt;p&gt;我觉得Spring AOP整体上可以分为4个流程：
1.  XML解析。
这部分我感觉和第二部分还是有点相同的地方的。针对XML解析，主要就是将各个不同的标签，解析成一个个BeanDefinition，同时给BeanDefinition设置其对应的beanClass属性，然后维护到Bean容器中。如果你在项目中是基于XML的方式使用Spring AOP，那么在这个过程中就会解析完所有相关的Bean，然后在第二流程中(筛选通知器)，就不会去创建通知器了。而如果你是使用是注解的方式只用Spring AOP，那么在这个过程不会做什么处理，然后会在筛选通知器的时候根据各个注解创建对应的Bean。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;筛选通知器。
初始化之后，需要为每个Bean筛选出这个Bean对应的通知器。通知器（Advisor）是Spring AOP中非常重要的一个概念，如果你暂时不理解什么是通知器，就把它当作通知和切面的组合吧，通知器里面维护了通知和切面的属性。和切面不同的地方在于，一个切面里面可以有多个通知，而一个通知器里面只有一个通知，并且有该通知对应的切面信息。有关于通知器我下面会有介绍。
我们知道Spring AOP底层是通过动态代理来实现的，也就是说在运行时创建一个代理类，那么我们能够想到通过代理实现AOP技术的方式有两种：一种是在生成代理类的时候，把所有通知的逻辑放到那个代理类中，根据我们对JDK基于接口的动态代理和CGLIB基于父的动态代理的了解，这应该不太可能把，通知可以有很多很多，如果真这样做，到时候生成的代理类不是非常混乱吗？第二种方法就是，在执行动态代理方法的时候，在代理方法内部调用那些通知逻辑，至于怎么调用，这也算是一个很Sring AOP中一个较为复杂的过程。这个想法不错，实际上Spring AOP也是这么干的。
既然是在代理类执行方法的时候调用通知链的逻辑，那么就存在这样一个问题，有哪些通知链？也就是说，要实现上面说的那样，Spring 必须知道每个Bean对应的通知链。这其实就是所谓的筛选通知器。
那么这里就引出一堆问题，怎么组织通知，即通知在Spring中该怎么表示？什么时候筛选？怎么筛选？我觉得这是Spring AOP中最复杂的一个过程，因为这里面还涉及到Spring IOC的部分内容，而IOC作为Spring的根基，挺复杂的，虽然知道它的大体流程，但是对于具体细节一无所知。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建代理对象
即为目标类创建代理对象，采用哪种方式？JDK动态代理还是CGLIB动态代理。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理调用过程
这可能是我们最感兴趣的一个过程，即：代理类是怎么调用这些通知链的逻辑的，然后又是怎么有规律的调用的，很有趣。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是我在接下来讲解的时候不会将每个流程当作一个小节来讲解，因为每个流程都太长了，所以多分几个章节。&lt;/p&gt;

&lt;h4 id=&#34;项目准备&#34;&gt;项目准备&lt;/h4&gt;

&lt;p&gt;IDEA可以很方便Debug，这是学习源码的一个好方式。准备一个Maven工程，并添加Spring中的一些核心模块，把常见的模块加上去就好了，然后准备测试代码。&lt;/p&gt;

&lt;h4 id=&#34;xml解析&#34;&gt;XML解析&lt;/h4&gt;

&lt;p&gt;aop名称空间的解析器是AopNamespaceHandler&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class AopNamespaceHandler extends NamespaceHandlerSupport {

   /**
    * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the
    * &#39;{@code config}&#39;, &#39;{@code spring-configured}&#39;, &#39;{@code aspectj-autoproxy}&#39;
    * and &#39;{@code scoped-proxy}&#39; tags.
    */
   @Override
   public void init() {
      // In 2.0 XSD as well as in 2.1 XSD.
      registerBeanDefinitionParser(&amp;quot;config&amp;quot;, new ConfigBeanDefinitionParser());
      registerBeanDefinitionParser(&amp;quot;aspectj-autoproxy&amp;quot;, new AspectJAutoProxyBeanDefinitionParser());
      registerBeanDefinitionDecorator(&amp;quot;scoped-proxy&amp;quot;, new ScopedProxyBeanDefinitionDecorator());

      // Only in 2.0 XSD: moved to context namespace as of 2.1
      registerBeanDefinitionParser(&amp;quot;spring-configured&amp;quot;, new SpringConfiguredBeanDefinitionParser());
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在ConfigBeanDefinitionParser的parse方法中对aop:config下面的三个直接子标签pointcut、advisor、aspect分别进行解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
   CompositeComponentDefinition compositeDef =
         new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));
   parserContext.pushContainingComponent(compositeDef);

   configureAutoProxyCreator(parserContext, element);

   List&amp;lt;Element&amp;gt; childElts = DomUtils.getChildElements(element);
   for (Element elt: childElts) {
      String localName = parserContext.getDelegate().getLocalName(elt);
      if (POINTCUT.equals(localName)) {
         parsePointcut(elt, parserContext);
      }
      else if (ADVISOR.equals(localName)) {
         parseAdvisor(elt, parserContext);
      }
      else if (ASPECT.equals(localName)) {
         parseAspect(elt, parserContext);
      }
   }

   parserContext.popAndRegisterContainingComponent();
   return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在解析的时候，会将一个个标封装成一个个BeanDefinition，其实这属于IOC的内容，对于这些细节我并不是很清楚，只能了解它的大致意图。
比如现在有这样一段XML配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;context:component-scan base-package=&amp;quot;aop&amp;quot;/&amp;gt;

&amp;lt;!-- 启动@aspectj的自动代理支持--&amp;gt;
&amp;lt;aop:aspectj-autoproxy /&amp;gt;

&amp;lt;bean id=&amp;quot;simpleMethodInterceptor&amp;quot; class=&amp;quot;aop.SimpleMethodInterceptor&amp;quot; /&amp;gt;

&amp;lt;bean class=&amp;quot;aop.SimpleAopBean&amp;quot; /&amp;gt;

&amp;lt;aop:config expose-proxy=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;aop:pointcut id=&amp;quot;xxx&amp;quot; expression=&amp;quot;execution(* aop.SimpleAopBean.*(..))&amp;quot;/&amp;gt;
    &amp;lt;aop:aspect&amp;gt;
        &amp;lt;aop:before method=&amp;quot;yyy&amp;quot; pointcut-ref=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
        &amp;lt;aop:after method=&amp;quot;yyy&amp;quot; pointcut-ref=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/aop:after&amp;gt;
        &amp;lt;aop:around method=&amp;quot;yyy&amp;quot; pointcut-ref=&amp;quot;xxx&amp;quot;&amp;gt;&amp;lt;/aop:around&amp;gt;
        &amp;lt;!-- 还有各种通知 --&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;

&amp;lt;aop:config expose-proxy=&amp;quot;true&amp;quot;&amp;gt;
    &amp;lt;aop:advisor advice-ref=&amp;quot;simpleMethodInterceptor&amp;quot; pointcut=&amp;quot;execution(* aop.SimpleAopBean.*(..))&amp;quot; /&amp;gt;
    &amp;lt;aop:aspect ref=&amp;quot;simpleMethodInterceptor&amp;quot; /&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终pointcut、aspect、advisor解析之后变成了一个个BeanDefinition，但是在生成BeanDefinition时给它设置的beanClass属性才是关键，这个beanClass也代表每个标签实际对应的Clas类型，下面分别看看这三个标签对应的Class类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pointcut：AspectJExpressionPointcut&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expression) {
RootBeanDefinition beanDefinition = new RootBeanDefinition(AspectJExpressionPointcut.class);
beanDefinition.setScope(BeanDefinition.SCOPE_PROTOTYPE);
beanDefinition.setSynthetic(true);
beanDefinition.getPropertyValues().add(EXPRESSION, expression);
return beanDefinition;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;advisor：DefaultBeanFactoryPointcutAdvisor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private AbstractBeanDefinition createAdvisorBeanDefinition(Element advisorElement, ParserContext parserContext) {
RootBeanDefinition advisorDefinition = new RootBeanDefinition(DefaultBeanFactoryPointcutAdvisor.class);
advisorDefinition.setSource(parserContext.extractSource(advisorElement));

String adviceRef = advisorElement.getAttribute(ADVICE_REF);
if (!StringUtils.hasText(adviceRef)) {
  parserContext.getReaderContext().error(
        &amp;quot;&#39;advice-ref&#39; attribute contains empty value.&amp;quot;, advisorElement, this.parseState.snapshot());
}
else {
  advisorDefinition.getPropertyValues().add(
        ADVICE_BEAN_NAME, new RuntimeBeanNameReference(adviceRef));
}

if (advisorElement.hasAttribute(ORDER_PROPERTY)) {
  advisorDefinition.getPropertyValues().add(
        ORDER_PROPERTY, advisorElement.getAttribute(ORDER_PROPERTY));
}

return advisorDefinition;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关于DefaultBeanFactoryPointcutAdvisor，可以看看它的继承关系，发现它实现了顶层的Advisor接口&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_007.png&#34; alt=&#34;post_007&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;aspect：DefaultBeanFactoryPointcutAdvisor
aspect的解析会复杂一些，因为除了它本身，aspect下面还有很多子标签，即：各种通知。比如：before、after等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void parseAspect(Element aspectElement, ParserContext parserContext) {
String aspectId = aspectElement.getAttribute(ID);
String aspectName = aspectElement.getAttribute(REF);

try {
  this.parseState.push(new AspectEntry(aspectId, aspectName));
  List&amp;lt;BeanDefinition&amp;gt; beanDefinitions = new ArrayList&amp;lt;BeanDefinition&amp;gt;();
  List&amp;lt;BeanReference&amp;gt; beanReferences = new ArrayList&amp;lt;BeanReference&amp;gt;();

  List&amp;lt;Element&amp;gt; declareParents = DomUtils.getChildElementsByTagName(aspectElement, DECLARE_PARENTS);
  for (int i = METHOD_INDEX; i &amp;lt; declareParents.size(); i++) {
     Element declareParentsElement = declareParents.get(i);
     beanDefinitions.add(parseDeclareParents(declareParentsElement, parserContext));
  }

  // We have to parse &amp;quot;advice&amp;quot; and all the advice kinds in one loop, to get the
  // ordering semantics right.
  NodeList nodeList = aspectElement.getChildNodes();
  boolean adviceFoundAlready = false;
  for (int i = 0; i &amp;lt; nodeList.getLength(); i++) {
     Node node = nodeList.item(i);
     if (isAdviceNode(node, parserContext)) {
        if (!adviceFoundAlready) {
           adviceFoundAlready = true;
           if (!StringUtils.hasText(aspectName)) {
              parserContext.getReaderContext().error(
                    &amp;quot;&amp;lt;aspect&amp;gt; tag needs aspect bean reference via &#39;ref&#39; attribute when declaring advices.&amp;quot;,
                    aspectElement, this.parseState.snapshot());
              return;
           }
           beanReferences.add(new RuntimeBeanReference(aspectName));
        }
        AbstractBeanDefinition advisorDefinition = parseAdvice(
              aspectName, i, aspectElement, (Element) node, parserContext, beanDefinitions, beanReferences);
        beanDefinitions.add(advisorDefinition);
     }
  }

  AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(
        aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);
  parserContext.pushContainingComponent(aspectComponentDefinition);

  List&amp;lt;Element&amp;gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);
  for (Element pointcutElement : pointcuts) {
     parsePointcut(pointcutElement, parserContext);
  }

  parserContext.popAndRegisterContainingComponent();
}
finally {
  this.parseState.pop();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大体思路如下：先获取aspect标签下面的所有子标签，然后遍历，在遍历的时候判断该子标签是否是通知类型的标签，如果是，就解析子标签。
判断是否是通知标签的逻辑比较简单&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean isAdviceNode(Node aNode, ParserContext parserContext) {
   if (!(aNode instanceof Element)) {
      return false;
   }
   else {
      String name = parserContext.getDelegate().getLocalName(aNode);
      return (BEFORE.equals(name) || AFTER.equals(name) || AFTER_RETURNING_ELEMENT.equals(name) ||
            AFTER_THROWING_ELEMENT.equals(name) || AROUND.equals(name));
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面重点来关注一下对aspect子标签的解析过程&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private AbstractBeanDefinition parseAdvice(
      String aspectName, int order, Element aspectElement, Element adviceElement, ParserContext parserContext,
      List&amp;lt;BeanDefinition&amp;gt; beanDefinitions, List&amp;lt;BeanReference&amp;gt; beanReferences) {

   try {
      this.parseState.push(new AdviceEntry(parserContext.getDelegate().getLocalName(adviceElement)));

      // create the method factory bean
      RootBeanDefinition methodDefinition = new RootBeanDefinition(MethodLocatingFactoryBean.class);
      methodDefinition.getPropertyValues().add(&amp;quot;targetBeanName&amp;quot;, aspectName);
      methodDefinition.getPropertyValues().add(&amp;quot;methodName&amp;quot;, adviceElement.getAttribute(&amp;quot;method&amp;quot;));
      methodDefinition.setSynthetic(true);

      // create instance factory definition
      RootBeanDefinition aspectFactoryDef =
            new RootBeanDefinition(SimpleBeanFactoryAwareAspectInstanceFactory.class);
      aspectFactoryDef.getPropertyValues().add(&amp;quot;aspectBeanName&amp;quot;, aspectName);
      aspectFactoryDef.setSynthetic(true);

      // register the pointcut
      AbstractBeanDefinition adviceDef = createAdviceDefinition(
            adviceElement, parserContext, aspectName, order, methodDefinition, aspectFactoryDef,
            beanDefinitions, beanReferences);

      // configure the advisor
      RootBeanDefinition advisorDefinition = new RootBeanDefinition(AspectJPointcutAdvisor.class);
      advisorDefinition.setSource(parserContext.extractSource(adviceElement));
      advisorDefinition.getConstructorArgumentValues().addGenericArgumentValue(adviceDef);
      if (aspectElement.hasAttribute(ORDER_PROPERTY)) {
         advisorDefinition.getPropertyValues().add(
               ORDER_PROPERTY, aspectElement.getAttribute(ORDER_PROPERTY));
      }

      // register the final advisor
      parserContext.getReaderContext().registerWithGeneratedName(advisorDefinition);

      return advisorDefinition;
   }
   finally {
      this.parseState.pop();
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1、创建一个class类型为MethodLocatingFactoryBean的BeanDefinition，关联上aspectName 和 methodName。注意，targetName就是取aspect标签上ref的值，methodName 就是子标签上对应的methon属性值！以下的也是类似。&lt;/p&gt;

&lt;p&gt;2、创建一个class类型为SimpleBeanFactoryAwareAspectInstanceFactory的BeanDefinition，关联上aspectName 和 methodName。&lt;/p&gt;

&lt;p&gt;3、重点来了。这一步才是对子标签真正的解析，即：每个标签对应什么类型。这里会创建根据子标签的类型创建一个class类型为对对应类型的BeanDefinition，至于具体有哪些类型，下面会有详细介绍。创建这个BeanDefinition的时候需要依赖到前面创建的那两个BeanDefinition，至于Spring这里这样处理的意图，不好意思，我还不太清楚。&lt;/p&gt;

&lt;p&gt;4、创建以class类型为AspectJPointcutAdvisor的BeanDefinition，这也是最终真正的返回值，这里需要依赖第三部创建的BeanDefinition。从这里我们可以看出，aspect下的每个通知标签，最终都会转换成Advisor(AspectJPointcutAdvisor)，而每个通知标签都是aspect的子标签，也就是说，每个Advisor，可以堪称是Aspect和Advice的组合，这就是通知器！这句话很重要！&lt;/p&gt;

&lt;p&gt;5、注册最终生成的AspectJPointcutAdvisor。&lt;/p&gt;

&lt;p&gt;这就是一个个通知标签的解析过程，在第三个步骤中，提到了有一些class类型，这里可以看看&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Class&amp;lt;?&amp;gt; getAdviceClass(Element adviceElement, ParserContext parserContext) {
   String elementName = parserContext.getDelegate().getLocalName(adviceElement);
   if (BEFORE.equals(elementName)) {
      return AspectJMethodBeforeAdvice.class;
   }
   else if (AFTER.equals(elementName)) {
      return AspectJAfterAdvice.class;
   }
   else if (AFTER_RETURNING_ELEMENT.equals(elementName)) {
      return AspectJAfterReturningAdvice.class;
   }
   else if (AFTER_THROWING_ELEMENT.equals(elementName)) {
      return AspectJAfterThrowingAdvice.class;
   }
   else if (AROUND.equals(elementName)) {
      return AspectJAroundAdvice.class;
   }
   else {
      throw new IllegalArgumentException(&amp;quot;Unknown advice kind [&amp;quot; + elementName + &amp;quot;].&amp;quot;);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个关系应该很明显了，下面来看看通知类的继承关系&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_008.png&#34; alt=&#34;post_008&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有关于解析aspect子标签，即：解析通知到这里基本可以结束了，还有很多不太清楚的地方，能力有限，但现在对我们研究Spring AOP影响不大，这里花大把时间解释子标签的解析过程，就是为了让大家了解Advisor，这在Spring AOP里面是一个非常重要的概念。其实，现在不是很清楚的一些东西，在下面的解析过程中，都会一个显现出来，都是很就可以知它们这样做的意义了。&lt;/p&gt;

&lt;p&gt;当aspect下的所有通知子标签解析完成之后，还有一个过程要处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AspectComponentDefinition aspectComponentDefinition = createAspectComponentDefinition(
      aspectElement, aspectId, beanDefinitions, beanReferences, parserContext);
parserContext.pushContainingComponent(aspectComponentDefinition);

private AspectComponentDefinition createAspectComponentDefinition(
      Element aspectElement, String aspectId, List&amp;lt;BeanDefinition&amp;gt; beanDefs,
      List&amp;lt;BeanReference&amp;gt; beanRefs, ParserContext parserContext) {

   BeanDefinition[] beanDefArray = beanDefs.toArray(new BeanDefinition[beanDefs.size()]);
   BeanReference[] beanRefArray = beanRefs.toArray(new BeanReference[beanRefs.size()]);
   Object source = parserContext.extractSource(aspectElement);
   return new AspectComponentDefinition(aspectId, beanDefArray, beanRefArray, source);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是做啥用的？可以看看AspectComponentDefinition这个类是干嘛的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * {@link org.springframework.beans.factory.parsing.ComponentDefinition}
 * that holds an aspect definition, including its nested pointcuts.
 *
 * @author Rob Harrop
 * @author Juergen Hoeller
 * @since 2.0
 * @see #getNestedComponents()
 * @see PointcutComponentDefinition
 */
public class AspectComponentDefin
……
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是维护每个aspect和它下面哪些通知的关系，aspec 和 advice的关系是1-N&lt;/p&gt;

&lt;p&gt;通知类标签解析完成之后，还有一个小流程，解析aspect下面的pointcut标签，pointcut标签可以和aspect标签同级，也可以是它的子级，解析方法是一样，不多说了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Element&amp;gt; pointcuts = DomUtils.getChildElementsByTagName(aspectElement, POINTCUT);
for (Element pointcutElement : pointcuts) {
   parsePointcut(pointcutElement, parserContext);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于Spring AOP中解析XML的内容就到这里了，其实这里主要是针对我们使用XML的方式使用Spring AOP，与之对应的，还有基于注解的解析，这是我们接下来要讲的内容。对于这一部分内容跟，最重要的就是理解那些标签经过转换之后的表示方式，因为不管是XML还是注解，最终都是对应的一个Class，理解这一点非常重要。&lt;/p&gt;

&lt;h4 id=&#34;所有通知器-1&#34;&gt;所有通知器(1)&lt;/h4&gt;

&lt;p&gt;在网上找了一些资料，大部分说是在 bean初始化后置处理过程中为Bean筛选通知器，但是我在前置方法里面也看到对应的操作，两个方法的实现基本一致，只是判断条件不同，不知道具体的用意是什么。AbstractAutoProxyCreator.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
   Object cacheKey = getCacheKey(beanClass, beanName);

   if (beanName == null || !this.targetSourcedBeans.contains(beanName)) {
      if (this.advisedBeans.containsKey(cacheKey)) {
         return null;
      }
      if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) {
         this.advisedBeans.put(cacheKey, Boolean.FALSE);
         return null;
      }
   }

   // Create proxy here if we have a custom TargetSource.
   // Suppresses unnecessary default instantiation of the target bean:
   // The TargetSource will handle target instances in a custom fashion.
   if (beanName != null) {
      TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
      if (targetSource != null) {
         this.targetSourcedBeans.add(beanName);
         Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
         Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
         this.proxyTypes.put(cacheKey, proxy.getClass());
         return proxy;
      }
   }

   return null;
}

@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
   if (bean != null) {
      Object cacheKey = getCacheKey(bean.getClass(), beanName);
      if (!this.earlyProxyReferences.contains(cacheKey)) {
         return wrapIfNecessary(bean, beanName, cacheKey);
      }
   }
   return bean;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在前置中多了一个判断，即判断用户是否自定义了custom TargetSource，暂时不太清楚这里的用意，先跳过，直接介绍那个后置方法吧。&lt;/p&gt;

&lt;p&gt;Spring AOP通过实现BeanPostProcessor 接口，在 bean初始化后置处理过程中需寻找Bean对应的通知器，该实现类是 AbstractAutoProxyCreator。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class AbstractAutoProxyCreator extends ProxyProcessorSupport
      implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware {
/**
 * Create a proxy with the configured interceptors if the bean is
 * identified as one to proxy by the subclass.
 * @see #getAdvicesAndAdvisorsForBean
 */
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
   if (bean != null) {
      Object cacheKey = getCacheKey(bean.getClass(), beanName);
      if (!this.earlyProxyReferences.contains(cacheKey)) {
         return wrapIfNecessary(bean, beanName, cacheKey);
      }
   }
   return bean;
}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this.earlyProxyReferences是一个Set集合，估计是缓存的作用，至于它在哪里初始化的，我还不太清楚。主要关注点就是wrapIfNecessary方法，所有主要流程都在这个方法里面可以看到，但千万别认为它很简单，这个方法里面的每个方法调用 ，都很复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.
 * @param bean the raw bean instance
 * @param beanName the name of the bean
 * @param cacheKey the cache key for metadata access
 * @return a proxy wrapping the bean, or the raw bean instance as-is
 */
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
   if (beanName != null &amp;amp;&amp;amp; this.targetSourcedBeans.contains(beanName)) {
      return bean;
   }
   if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
      return bean;
   }
   if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
      this.advisedBeans.put(cacheKey, Boolean.FALSE);
      return bean;
   }

   // Create proxy if we have advice.
   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
   if (specificInterceptors != DO_NOT_PROXY) {
      this.advisedBeans.put(cacheKey, Boolean.TRUE);
      Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
      this.proxyTypes.put(cacheKey, proxy.getClass());
      return proxy;
   }

   this.advisedBeans.put(cacheKey, Boolean.FALSE);
   return bean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法里面其实包括了筛选通知器和创建代理两个过程，但我还是觉得把他们分开来讲解更好一些，这个地方注意以下。&lt;/p&gt;

&lt;p&gt;前面这几个判断，主要是筛选一下有没有必要为当前的bean创建代理。每个bean进这个方法的时候，都会将这个bean放到 this.advisedBeans 中，这是一个Map集合&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Map&amp;lt;Object, Boolean&amp;gt; advisedBeans = new ConcurrentHashMap&amp;lt;Object, Boolean&amp;gt;(256);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果当前bean不需要创建代理，就设置为false；如果需要创建代理，创建代理之后就就设置为true，this.advisedBeans可以把它当作是一个缓存，当下次有相同的bean跑进来的时候，就可以快速判断了。&lt;/p&gt;

&lt;p&gt;这个主要是判断当前bean是否基础设施类（Pointcut、Advice、Advisor 等接口的实现类），或是应该跳过的类，如果是就不创建代理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
   this.advisedBeans.put(cacheKey, Boolean.FALSE);
   return bean;
}

protected boolean isInfrastructureClass(Class&amp;lt;?&amp;gt; beanClass) {
   boolean retVal = Advice.class.isAssignableFrom(beanClass) ||
         Pointcut.class.isAssignableFrom(beanClass) ||
         Advisor.class.isAssignableFrom(beanClass) ||
         AopInfrastructureBean.class.isAssignableFrom(beanClass);
   if (retVal &amp;amp;&amp;amp; logger.isTraceEnabled()) {
      logger.trace(&amp;quot;Did not attempt to auto-proxy infrastructure class [&amp;quot; + beanClass.getName() + &amp;quot;]&amp;quot;);
   }
   return retVal;
}

// shouldSkip默认是返回 false的，子类可以覆盖这个方法
protected boolean shouldSkip(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
   return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就是筛选通知器的核心了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有相关的细节都在这个方法里面。这个方法的作用就是为当前bean找到合适的通知器。它的默认实现在其父类方法中  AbstractAdvisorAutoProxyCreator&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Override
protected Object[] getAdvicesAndAdvisorsForBean(Class&amp;lt;?&amp;gt; beanClass, String beanName, TargetSource targetSource) {
   List&amp;lt;Advisor&amp;gt; advisors = findEligibleAdvisors(beanClass, beanName);
   if (advisors.isEmpty()) {
      return DO_NOT_PROXY;
   }
   return advisors.toArray();
}

protected List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
   List&amp;lt;Advisor&amp;gt; candidateAdvisors = findCandidateAdvisors();
   List&amp;lt;Advisor&amp;gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
   extendAdvisors(eligibleAdvisors);
   if (!eligibleAdvisors.isEmpty()) {
      eligibleAdvisors = sortAdvisors(eligibleAdvisors);
   }
   return eligibleAdvisors;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从以上代码可以看出，为当前bean寻找通知器的大体流程如下
- 查找所有的通知器，findCandidateAdvisors()
- 在上一步的基础上，筛选出符合当前bean的通知器，findAdvisorsThatCanApply(…..)&lt;/p&gt;

&lt;p&gt;有关于findCandidateAdvisors方法，这里分两部分。处理AbstractAdvisorAutoProxyCreator类中的默认实现外，他还有一个子类，AnnotationAwareAspectJAutoProxyCreator，并且这个子类重写了这个方法，根据类名可以看出，主要是处理注解相关的。&lt;/p&gt;

&lt;p&gt;先看默认实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected List&amp;lt;Advisor&amp;gt; findCandidateAdvisors() {
   return this.advisorRetrievalHelper.findAdvisorBeans();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很明显这里是通过BeanFactoryAdvisorRetrievalHelper的findAdvisorBeans方法找到所有的通知器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;Advisor&amp;gt; findAdvisorBeans() {
   // Determine list of advisor bean names, if not cached already.
   String[] advisorNames = null;
   synchronized (this) {
      advisorNames = this.cachedAdvisorBeanNames;
      if (advisorNames == null) {
         // Do not initialize FactoryBeans here: We need to leave all regular beans
         // uninitialized to let the auto-proxy creator apply to them!
         advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
               this.beanFactory, Advisor.class, true, false);
         this.cachedAdvisorBeanNames = advisorNames;
      }
   }
   if (advisorNames.length == 0) {
      return new LinkedList&amp;lt;Advisor&amp;gt;();
   }

   List&amp;lt;Advisor&amp;gt; advisors = new LinkedList&amp;lt;Advisor&amp;gt;();
   for (String name : advisorNames) {
      if (isEligibleBean(name)) {
         if (this.beanFactory.isCurrentlyInCreation(name)) {
            if (logger.isDebugEnabled()) {
               logger.debug(&amp;quot;Skipping currently created advisor &#39;&amp;quot; + name + &amp;quot;&#39;&amp;quot;);
            }
         }
         else {
            try {
               advisors.add(this.beanFactory.getBean(name, Advisor.class));
            }
            catch (BeanCreationException ex) {
               Throwable rootCause = ex.getMostSpecificCause();
               if (rootCause instanceof BeanCurrentlyInCreationException) {
                  BeanCreationException bce = (BeanCreationException) rootCause;
                  if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) {
                     if (logger.isDebugEnabled()) {
                        logger.debug(&amp;quot;Skipping advisor &#39;&amp;quot; + name +
                              &amp;quot;&#39; with dependency on currently created bean: &amp;quot; + ex.getMessage());
                     }
                     // Ignore: indicates a reference back to the bean we&#39;re trying to advise.
                     // We want to find advisors other than the currently created bean itself.
                     continue;
                  }
               }
               throw ex;
            }
         }
      }
   }
   return advisors;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面对上面的方法分开来解析&lt;/p&gt;

&lt;p&gt;首先，这里使用了单例模式的双重校验，this.cachedAdvisorBeanNames就是所有通知器名称的缓存，只需要查找一次就可以了，如果对每个bean都查找一次所有的通知器，那不是慢死了。所以，查找逻辑全在beanNamesForTypeIncludingAncestors方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] advisorNames = null;
synchronized (this) {
   advisorNames = this.cachedAdvisorBeanNames;
   if (advisorNames == null) {
      // Do not initialize FactoryBeans here: We need to leave all regular beans
      // uninitialized to let the auto-proxy creator apply to them!
      advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
            this.beanFactory, Advisor.class, true, false);
      this.cachedAdvisorBeanNames = advisorNames;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这里使用了递归查找，查找的主要逻辑就是getBeanNamesForType方法，这是Spring为我们封装好的方法，就不再深究了。其实就是就是找到所有的Advisor，因为这是通知器的顶级接口，前面的继承关系图中已经展示过了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static String[] beanNamesForTypeIncludingAncestors(
      ListableBeanFactory lbf, Class&amp;lt;?&amp;gt; type, boolean includeNonSingletons, boolean allowEagerInit) {

   Assert.notNull(lbf, &amp;quot;ListableBeanFactory must not be null&amp;quot;);
   String[] result = lbf.getBeanNamesForType(type, includeNonSingletons, allowEagerInit);
   if (lbf instanceof HierarchicalBeanFactory) {
      HierarchicalBeanFactory hbf = (HierarchicalBeanFactory) lbf;
      if (hbf.getParentBeanFactory() instanceof ListableBeanFactory) {
         String[] parentResult = beanNamesForTypeIncludingAncestors(
               (ListableBeanFactory) hbf.getParentBeanFactory(), type, includeNonSingletons, allowEagerInit);
         List&amp;lt;String&amp;gt; resultList = new ArrayList&amp;lt;String&amp;gt;();
         resultList.addAll(Arrays.asList(result));
         for (String beanName : parentResult) {
            if (!resultList.contains(beanName) &amp;amp;&amp;amp; !hbf.containsLocalBean(beanName)) {
               resultList.add(beanName);
            }
         }
         result = StringUtils.toStringArray(resultList);
      }
   }
   return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在获取所有通知器名称之后，进行遍历，找到所有名称对应的Bean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Advisor&amp;gt; advisors = new LinkedList&amp;lt;Advisor&amp;gt;();
for (String name : advisorNames) {
   if (isEligibleBean(name)) {
      if (this.beanFactory.isCurrentlyInCreation(name)) {
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Skipping currently created advisor &#39;&amp;quot; + name + &amp;quot;&#39;&amp;quot;);
         }
      }
      else {
         try {
            advisors.add(this.beanFactory.getBean(name, Advisor.class));
         }
……
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;isEligibleBean也是一个可以被子类覆盖的方法，默认返回true。this.beanFactory.isCurrentlyInCreation(name)用于忽略当前正在创建的Bean。然后就是根据name找到对应的Bean放到list中，最后返回list。&lt;/p&gt;

&lt;h4 id=&#34;所有通知器-2&#34;&gt;所有通知器(2)&lt;/h4&gt;

&lt;p&gt;上面是默认实现，接下来看看AnnotationAwareAspectJAutoProxyCreator中该方法的实现&lt;/p&gt;

&lt;p&gt;先调用了父类的方法，它的实现我们在上面已经讲解过了， 然后再调用BeanFactoryAspectJAdvisorsBuilder的buildAspectJAdvisors方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected List&amp;lt;Advisor&amp;gt; findCandidateAdvisors() {
   // Add all the Spring advisors found according to superclass rules.
   List&amp;lt;Advisor&amp;gt; advisors = super.findCandidateAdvisors();
   // Build Advisors for all AspectJ aspects in the bean factory.
   advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
   return advi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;Advisor&amp;gt; buildAspectJAdvisors() {
   List&amp;lt;String&amp;gt; aspectNames = null;

   synchronized (this) {
      aspectNames = this.aspectBeanNames;
      if (aspectNames == null) {
         List&amp;lt;Advisor&amp;gt; advisors = new LinkedList&amp;lt;Advisor&amp;gt;();
         aspectNames = new LinkedList&amp;lt;String&amp;gt;();
         String[] beanNames =
               BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false);
         for (String beanName : beanNames) {
            if (!isEligibleBean(beanName)) {
               continue;
            }
            // We must be careful not to instantiate beans eagerly as in this
            // case they would be cached by the Spring container but would not
            // have been weaved
            Class&amp;lt;?&amp;gt; beanType = this.beanFactory.getType(beanName);
            if (beanType == null) {
               continue;
            }
            if (this.advisorFactory.isAspect(beanType)) {
               aspectNames.add(beanName);
               AspectMetadata amd = new AspectMetadata(beanType, beanName);
               if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                  MetadataAwareAspectInstanceFactory factory =
                        new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
                  List&amp;lt;Advisor&amp;gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
                  if (this.beanFactory.isSingleton(beanName)) {
                     this.advisorsCache.put(beanName, classAdvisors);
                  }
                  else {
                     this.aspectFactoryCache.put(beanName, factory);
                  }
                  advisors.addAll(classAdvisors);
               }
               else {
                  // Per target or per this.
                  if (this.beanFactory.isSingleton(beanName)) {
                     throw new IllegalArgumentException(&amp;quot;Bean with name &#39;&amp;quot; + beanName +
                           &amp;quot;&#39; is a singleton, but aspect instantiation model is not singleton&amp;quot;);
                  }
                  MetadataAwareAspectInstanceFactory factory =
                        new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
                  this.aspectFactoryCache.put(beanName, factory);
                  advisors.addAll(this.advisorFactory.getAdvisors(factory));
               }
            }
         }
         this.aspectBeanNames = aspectNames;
         return advisors;
      }
   }

   if (aspectNames.isEmpty()) {
      return Collections.emptyList();
   }
   List&amp;lt;Advisor&amp;gt; advisors = new LinkedList&amp;lt;Advisor&amp;gt;();
   for (String aspectName : aspectNames) {
      List&amp;lt;Advisor&amp;gt; cachedAdvisors = this.advisorsCache.get(aspectName);
      if (cachedAdvisors != null) {
         advisors.addAll(cachedAdvisors);
      }
      else {
         MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
         advisors.addAll(this.advisorFactory.getAdvisors(factory));
      }
   }
   return advisors;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它的大致流程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取IOC容器中所有Bean的名称&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] beanNames =
  BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;遍历这些名称并根据名称找到对应的bean，筛选出含有@Aspect注解的 Bean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;his.advisorFactory.isAspect(beanType)


@Override
public boolean isAspect(Class&amp;lt;?&amp;gt; clazz) {
return (hasAspectAnnotation(clazz) &amp;amp;&amp;amp; !compiledByAjc(clazz));
}

private boolean hasAspectAnnotation(Class&amp;lt;?&amp;gt; clazz) {
return (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据含有@Aspect注解的Bean获取通知器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Advisor&amp;gt; classAdvisors = this.advisorFactory.getAdvisors(factory);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，现在主要是看看根据@Aspec注解获取通知器的逻辑。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public List&amp;lt;Advisor&amp;gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
   Class&amp;lt;?&amp;gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
   String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
   validate(aspectClass);

   // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
   // so that it will only instantiate once.
   MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
         new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

   List&amp;lt;Advisor&amp;gt; advisors = new LinkedList&amp;lt;Advisor&amp;gt;();
   for (Method method : getAdvisorMethods(aspectClass)) {
      Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
      if (advisor != null) {
         advisors.add(advisor);
      }
   }

   // If it&#39;s a per target aspect, emit the dummy instantiating aspect.
   if (!advisors.isEmpty() &amp;amp;&amp;amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
      Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
      advisors.add(0, instantiationAdvisor);
   }

   // Find introduction fields.
   for (Field field : aspectClass.getDeclaredFields()) {
      Advisor advisor = getDeclareParentsAdvisor(field);
      if (advisor != null) {
         advisors.add(advisor);
      }
   }

   return advisors;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概步骤如下
- 找到所有不包含@Pointcut的注解进行遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (Method method : getAdvisorMethods(aspectClass))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在遍历的时候根据方法名获取通知器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于根据方法名获取通知的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
  int declarationOrderInAspect, String aspectName) {

validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

AspectJExpressionPointcut expressionPointcut = getPointcut(
     candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
if (expressionPointcut == null) {
  return null;
}

return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
     this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先创建AspectJExpressionPointcut对象，其实这里仅仅是获取注解后面的那串值并把它封装成AspectJExpressionPointcut。
例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Component
@Aspect
public class LogAspect {
    @Pointcut(&amp;quot;execution(* *.testB(..))&amp;quot;)
    private void pointcut(){}

    @Before(value=&amp;quot;pointcut()&amp;quot;)
    public void beforeAdvice(){
        System.out.println(&amp;quot;【AspectJ Java语法添加通知】 前置通知&amp;quot;);
    }

    public void tttttt(){

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假如现在获取beforeAdvice的通知器，这里的AspectJExpressionPointcut仅仅是@Before注解中 vlue 的值，即 “pooint()”，并不是@Pointcut上真正的值。
获取了AspectJExpressionPointcut之后，接下来就是创建Adviso实现类了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
      Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
      MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

   if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
      // Static part of the pointcut is a lazy type.
      Pointcut preInstantiationPointcut = Pointcuts.union(
            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

      this.pointcut = new PerTargetInstantiationModelPointcut(
            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
      this.lazy = true;
   }
   else {
      // A singleton aspect.
      this.pointcut = this.declaredPointcut;
      this.lazy = false;
      this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的一些初始化代码被我删了，直接关注instantiateAdvice(this.declaredPointcut)这个方法把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Advice instantiateAdvice(AspectJExpressionPointcut pcut) {
   return this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pcut,
         this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
}

@Override
public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
      MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

   Class&amp;lt;?&amp;gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
   validate(candidateAspectClass);

   AspectJAnnotation&amp;lt;?&amp;gt; aspectJAnnotation =
         AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
   if (aspectJAnnotation == null) {
      return null;
   }

   // If we get here, we know we have an AspectJ method.
   // Check that it&#39;s an AspectJ-annotated class
   if (!isAspect(candidateAspectClass)) {
      throw new AopConfigException(&amp;quot;Advice must be declared inside an aspect type: &amp;quot; +
            &amp;quot;Offending method &#39;&amp;quot; + candidateAdviceMethod + &amp;quot;&#39; in class [&amp;quot; +
            candidateAspectClass.getName() + &amp;quot;]&amp;quot;);
   }

   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Found AspectJ method: &amp;quot; + candidateAdviceMethod);
   }

   AbstractAspectJAdvice springAdvice;

   switch (aspectJAnnotation.getAnnotationType()) {
      case AtBefore:
         springAdvice = new AspectJMethodBeforeAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtAfter:
         springAdvice = new AspectJAfterAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtAfterReturning:
         springAdvice = new AspectJAfterReturningAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
         if (StringUtils.hasText(afterReturningAnnotation.returning())) {
            springAdvice.setReturningName(afterReturningAnnotation.returning());
         }
         break;
      case AtAfterThrowing:
         springAdvice = new AspectJAfterThrowingAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
         if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
            springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
         }
         break;
      case AtAround:
         springAdvice = new AspectJAroundAdvice(
               candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
         break;
      case AtPointcut:
         if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Processing pointcut &#39;&amp;quot; + candidateAdviceMethod.getName() + &amp;quot;&#39;&amp;quot;);
         }
         return null;
      default:
         throw new UnsupportedOperationException(
               &amp;quot;Unsupported advice type on method: &amp;quot; + candidateAdviceMethod);
   }

   // Now to configure the advice...
   springAdvice.setAspectName(aspectName);
   springAdvice.setDeclarationOrder(declarationOrder);
   String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
   if (argNames != null) {
      springAdvice.setArgumentNamesFromStringArray(argNames);
   }
   springAdvice.calculateArgumentBindings();
   return springAdvice;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据不同的注解，创建不同的通知类型，然后关联到Advisor上。&lt;/p&gt;

&lt;h4 id=&#34;筛选通知器&#34;&gt;筛选通知器&lt;/h4&gt;

&lt;p&gt;找到所有的通知器之后，接下来就是从这些通知器里面找到和当前Bean相关的通知器了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(
      List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt; beanClass, String beanName) {

   ProxyCreationContext.setCurrentProxiedBeanName(beanName);
   try {
      return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
   }
   finally {
      ProxyCreationContext.setCurrentProxiedBeanName(null);
   }
}

public static List&amp;lt;Advisor&amp;gt; findAdvisorsThatCanApply(List&amp;lt;Advisor&amp;gt; candidateAdvisors, Class&amp;lt;?&amp;gt; clazz) {
   if (candidateAdvisors.isEmpty()) {
      return candidateAdvisors;
   }
   List&amp;lt;Advisor&amp;gt; eligibleAdvisors = new LinkedList&amp;lt;Advisor&amp;gt;();
   for (Advisor candidate : candidateAdvisors) {
      if (candidate instanceof IntroductionAdvisor &amp;amp;&amp;amp; canApply(candidate, clazz)) {
         eligibleAdvisors.add(candidate);
      }
   }
   boolean hasIntroductions = !eligibleAdvisors.isEmpty();
   for (Advisor candidate : candidateAdvisors) {
      if (candidate instanceof IntroductionAdvisor) {
         // already processed
         continue;
      }
      if (canApply(candidate, clazz, hasIntroductions)) {
         eligibleAdvisors.add(candidate);
      }
   }
   return eligibleAdvisors;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有引出一个概念：引介。
前面我们说了Spring AOP中有前置、后置等集中增强，其实还有一种引介增强。引介增强是一种比较特殊的增强类型，它不是在目标方法周围织入增强，而是为目标创建新的方法和属性，所以它的连接点是类级别的而非方法级别的 。
通过引介增强我们可以为目标类添加一个接口的实现即原来目标类未实现某个接口,那么通过引介增强可以为目标类创建实现某接口的代理。
Spring定义了引介增强接口IntroductionInterceptor以及为该接口提供了DelegatingIntroductionInterceptor实现类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_009.png&#34; alt=&#34;post_009&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假如现在有这么一个类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package aop;

public class PreBook {
    public void selfMethod(){
        System.out.println(&amp;quot;这是目标类自己的方法&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有这么一个接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package aop;

public interface IBook {
    void newMethd();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在希望在不修改PreBook的前提下，为PreBook类添加 newMethod() 方法，这时候就可以用到引介增强。可以实现这么一个类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package aop;

import org.aopalliance.intercept.MethodInvocation;
import org.springframework.aop.support.DelegatingIntroductionInterceptor;

public class BookInterceptor extends DelegatingIntroductionInterceptor implements IBook {
    @Override
    public void newMethd() {
        System.out.println(&amp;quot;没有改变原始类，却为它添加的一个新方法&amp;quot;);
    }

    public Object invoke(MethodInvocation mi) throws Throwable {

        Object obj = super.invoke(mi);
        return obj;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，在代理对象调用目标方法的时候，就会执行newMethod()方法。好像还需要特别配置一下，暂时不知道这样增强有什么用，暂时不考虑吧。
而如果我们要使用引介增强，对应的通知器只是使用IntroductionAdvisor。&lt;/p&gt;

&lt;p&gt;所以，上述的
findAdvisorsThatCanApply的方法中，此段代码就是用于判断是不是印介增强，并且这里通过两个循环将引介增强通知器放在了前面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;or (Advisor candidate : candidateAdvisors) {
   if (candidate instanceof IntroductionAdvisor &amp;amp;&amp;amp; canApply(candidate, clazz)) {
      eligibleAdvisors.add(candidate);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，最终需要关注的方法就是 canApply，canApply(candidate, clazz)相当于是调用了canApply(advisor, targetClass, false)方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean canApply(Advisor advisor, Class&amp;lt;?&amp;gt; targetClass, boolean hasIntroductions) {
   if (advisor instanceof IntroductionAdvisor) {
      return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
   }
   else if (advisor instanceof PointcutAdvisor) {
      PointcutAdvisor pca = (PointcutAdvisor) advisor;
      return canApply(pca.getPointcut(), targetClass, hasIntroductions);
   }
   else {
      // It doesn&#39;t have a pointcut so we assume it applies.
      return true;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里可以看出，Spring AOP把通知器当作了两种类型来处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_010.png&#34; alt=&#34;post_010&#34; /&gt;&lt;/p&gt;

&lt;p&gt;根据我们前面提到的，各种前置、后置、环绕通知，最终都是解析成AspectJPointcutAdvisor，因此这里的IntroductionAdvisor就是为了处理增强通知的。&lt;/p&gt;

&lt;p&gt;至此，可以看出真正执行筛选的逻辑，是放在getClassFilter().matches 中进行处理的，这里引出了ClassFilter的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_011.png&#34; alt=&#34;post_011&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出，AspectJExpressionPointcut也是一个ClassFilter，而XML中的pointcut标签经过解析之后，正是一个AspectJExpressionPointcut对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static boolean canApply(Pointcut pc, Class&amp;lt;?&amp;gt; targetClass, boolean hasIntroductions) {
   Assert.notNull(pc, &amp;quot;Pointcut must not be null&amp;quot;);
   if (!pc.getClassFilter().matches(targetClass)) {
      return false;
   }

   MethodMatcher methodMatcher = pc.getMethodMatcher();
   if (methodMatcher == MethodMatcher.TRUE) {
      // No need to iterate the methods if we&#39;re matching any method anyway...
      return true;
   }

   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
   if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
   }

   Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; classes = new LinkedHashSet&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
   classes.add(targetClass);
   for (Class&amp;lt;?&amp;gt; clazz : classes) {
      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
      for (Method method : methods) {
         if ((introductionAwareMethodMatcher != null &amp;amp;&amp;amp;
               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
               methodMatcher.matches(method, targetClass)) {
            return true;
         }
      }
   }

   return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于matches方法的具体逻辑，有点复杂，就不看了。&lt;/p&gt;

&lt;h4 id=&#34;创建代理&#34;&gt;创建代理&lt;/h4&gt;

&lt;p&gt;创建代理也是在wrapIfNecessary方法中被调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object proxy = createProxy(
      bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));

protected Object createProxy(
      Class&amp;lt;?&amp;gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

   if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
      AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
   }

   ProxyFactory proxyFactory = new ProxyFactory();
   proxyFactory.copyFrom(this);

   if (!proxyFactory.isProxyTargetClass()) {
      if (shouldProxyTargetClass(beanClass, beanName)) {
         proxyFactory.setProxyTargetClass(true);
      }
      else {
         evaluateProxyInterfaces(beanClass, proxyFactory);
      }
   }

   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
   for (Advisor advisor : advisors) {
      proxyFactory.addAdvisor(advisor);
   }

   proxyFactory.setTargetSource(targetSource);
   customizeProxyFactory(proxyFactory);

   proxyFactory.setFrozen(this.freezeProxy);
   if (advisorsPreFiltered()) {
      proxyFactory.setPreFiltered(true);
   }

   return proxyFactory.getProxy(getProxyClassLoader());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中间会有一些校验，比如proxyFactory.isProxyTargetClass()，到时候会根据这个属性来判断使用JDK动态代理还是CGLIB动态代理。这个属性可以在配置文件中配置，proxy-target-class = &amp;ldquo;false&amp;rdquo;，默认是false;
Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);是将一些Advie转换成Advisor，应该没有了吧？
然后调用ProxyFactory类的getProxy(getProxyClassLoader())创建代理对象。ProxyFactory的继承关系如下，一些常用方法都在ProxyCreatorSupport中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_012.png&#34; alt=&#34;post_012&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先是调用了ProxyCreatorSupport中的createAopProxy()方法获得一个Spring  AOP中的AopProxy对象，然后再调用getProxy(…)方法获得目标Bean的一个代理对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Object getProxy(ClassLoader classLoader) {
   return createAopProxy().getProxy(classLoader);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于AopProxy的继承关系图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_013.png&#34; alt=&#34;post_013&#34; /&gt;&lt;/p&gt;

&lt;p&gt;先看一下createAopProxy()方法的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected final synchronized AopProxy createAopProxy() {
   if (!this.active) {
      activate();
   }
   return getAopProxyFactory().createAopProxy(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// DefaultAopProxyFactory.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
   if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
      Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
      if (targetClass == null) {
         throw new AopConfigException(&amp;quot;TargetSource cannot determine target class: &amp;quot; +
               &amp;quot;Either an interface or a target is required for proxy creation.&amp;quot;);
      }
      if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
         return new JdkDynamicAopProxy(config);
      }
      return new ObjenesisCglibAopProxy(config);
   }
   else {
      return new JdkDynamicAopProxy(config);
   }
}

final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {

……

   public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {
      Assert.notNull(config, &amp;quot;AdvisedSupport must not be null&amp;quot;);
      if (config.getAdvisors().length == 0 &amp;amp;&amp;amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {
         throw new AopConfigException(&amp;quot;No advisors and no TargetSource specified&amp;quot;);
      }
      this.advised = config;
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;config.isOptimize()用于判断是否要优化创建代理，如果为true，就是使用CGLIB创建代理。然后就是判断一下用户是否配置了proxy-target-class那个属性，判断目标类是否有接口等等。默认就是使用JDK动态创建代理。&lt;/p&gt;

&lt;p&gt;AdvisedSupport的继承关系如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_014.png&#34; alt=&#34;post_014&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建AopProxy 对象之后，接下来就是调用 getProxy()方法获取目标Bean的代理对象，其实到这里才算是真正开始为目标Bean创建代理对象。这里以JdkDynamicAopProxy的getProxy方法为例&lt;/p&gt;

&lt;p&gt;// JdkDynamicAopProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Object getProxy() {
   return getProxy(ClassUtils.getDefaultClassLoader());
}



@Override
public Object getProxy(ClassLoader classLoader) {
   if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Creating JDK dynamic proxy: target source is &amp;quot; + this.advised.getTargetSource());
   }
   Class&amp;lt;?&amp;gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
   return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里已经很明显了，JdkDynamicAopProxy实现了InvocationHandler接口，调用了JDK的Proxy.newProxyInstance方法创建代理。有关于CGLIB也是类似，这里就不过多说明了。&lt;/p&gt;

&lt;h4 id=&#34;代理调用过程&#34;&gt;代理调用过程&lt;/h4&gt;

&lt;p&gt;前面所介绍的所有内容，都是在Spring应用启动的时候完成，都是为了创建能够正常工作的代理对象。那么在代理对象调用方法的时候，是怎么对通知上的逻辑进行调用呢？这就是本节所要讲解的内容，这里以JdkDynamicAopProxy为利，其实CglibAopProxy也基本上是一样的。&lt;/p&gt;

&lt;p&gt;我们知道，由JDK动态代理创建的代理对象，在调用目标方法的时候，实际上是调用实现了InvocationHandler 接口 那个类的 invoke 方法，前面已经知道，JdkDynamicAopProxy实现了InvocationHandler接口，也就是说，在代理对象调用方法的时候，会执行JdkDynamicAopProxy的invoke 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
   MethodInvocation invocation;
   Object oldProxy = null;
   boolean setProxyContext = false;

   TargetSource targetSource = this.advised.targetSource;
   Class&amp;lt;?&amp;gt; targetClass = null;
   Object target = null;

   try {
      if (!this.equalsDefined &amp;amp;&amp;amp; AopUtils.isEqualsMethod(method)) {
         // The target does not implement the equals(Object) method itself.
         return equals(args[0]);
      }
      else if (!this.hashCodeDefined &amp;amp;&amp;amp; AopUtils.isHashCodeMethod(method)) {
         // The target does not implement the hashCode() method itself.
         return hashCode();
      }
      else if (method.getDeclaringClass() == DecoratingProxy.class) {
         // There is only getDecoratedClass() declared -&amp;gt; dispatch to proxy config.
         return AopProxyUtils.ultimateTargetClass(this.advised);
      }
      else if (!this.advised.opaque &amp;amp;&amp;amp; method.getDeclaringClass().isInterface() &amp;amp;&amp;amp;
            method.getDeclaringClass().isAssignableFrom(Advised.class)) {
         // Service invocations on ProxyConfig with the proxy config...
         return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
      }

      Object retVal;

      if (this.advised.exposeProxy) {
         // Make invocation available if necessary.
         oldProxy = AopContext.setCurrentProxy(proxy);
         setProxyContext = true;
      }

      // May be null. Get as late as possible to minimize the time we &amp;quot;own&amp;quot; the target,
      // in case it comes from a pool.
      target = targetSource.getTarget();
      if (target != null) {
         targetClass = target.getClass();
      }

      // Get the interception chain for this method.
      List&amp;lt;Object&amp;gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

      // Check whether we have any advice. If we don&#39;t, we can fallback on direct
      // reflective invocation of the target, and avoid creating a MethodInvocation.
      if (chain.isEmpty()) {
         // We can skip creating a MethodInvocation: just invoke the target directly
         // Note that the final invoker must be an InvokerInterceptor so we know it does
         // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
         Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
         retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
      }
      else {
         // We need to create a method invocation...
         invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
         // Proceed to the joinpoint through the interceptor chain.
         retVal = invocation.proceed();
      }

      // Massage return value if necessary.
      Class&amp;lt;?&amp;gt; returnType = method.getReturnType();
      if (retVal != null &amp;amp;&amp;amp; retVal == target &amp;amp;&amp;amp; returnType.isInstance(proxy) &amp;amp;&amp;amp;
            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
         // Special case: it returned &amp;quot;this&amp;quot; and the return type of the method
         // is type-compatible. Note that we can&#39;t help if the target sets
         // a reference to itself in another returned object.
         retVal = proxy;
      }
      else if (retVal == null &amp;amp;&amp;amp; returnType != Void.TYPE &amp;amp;&amp;amp; returnType.isPrimitive()) {
         throw new AopInvocationException(
               &amp;quot;Null return value from advice does not match primitive return type for: &amp;quot; + method);
      }
      return retVal;
   }
   finally {
      if (target != null &amp;amp;&amp;amp; !targetSource.isStatic()) {
         // Must have come from TargetSource.
         targetSource.releaseTarget(target);
      }
      if (setProxyContext) {
         // Restore old proxy.
         AopContext.setCurrentProxy(oldProxy);
      }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先是判断一下是否为 equals  和hashCode方法，如果是就执行 自己的逻辑。
然后判断是否expose-proxy 属性是否为 true，是就暴露代理对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (this.advised.exposeProxy) {
   // Make invocation available if necessary.
   oldProxy = AopContext.setCurrentProxy(proxy);
   setProxyContext = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要设置这个呢？因为代理对象中如果方法调用了方法，里面的方法就没办法插入增强逻辑，如果想让里面的方法也插入增强逻辑，就要暴露代理对象，然后再调用的时候使用代理对象调用就可以了，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void boo() {
    System.out.println(&amp;quot;testA执行&amp;quot;);
    testB();
}

public void testB() {
    System.out.println(&amp;quot;testB执行&amp;quot;);
    ((ISimpleAopBean) AopContext.currentProxy()).testC();
}

public void testC() {
    System.out.println(&amp;quot;testC执行&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，关键的内容来了，获取拦截器链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;Object&amp;gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里大家第拦截器可能会有点不理解，好像前面都没说到这个，其实这个没什么关系，只是在通知器上取出来通知，然后再通知上包装了一层而已。看下面的图就可以知道，MethodInterceptor也实现了通知的接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/SpringAOP/post_015.png&#34; alt=&#34;post_015&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;Object&amp;gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&amp;lt;?&amp;gt; targetClass) {
   MethodCacheKey cacheKey = new MethodCacheKey(method);
   List&amp;lt;Object&amp;gt; cached = this.methodCache.get(cacheKey);
   if (cached == null) {
      cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(
            this, method, targetClass);
      this.methodCache.put(cacheKey, cached);
   }
   return cached;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是做了一下缓存，所以主要的逻辑是在下面这个方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public List&amp;lt;Object&amp;gt; getInterceptorsAndDynamicInterceptionAdvice(
      Advised config, Method method, Class&amp;lt;?&amp;gt; targetClass) {

   // This is somewhat tricky... We have to process introductions first,
   // but we need to preserve order in the ultimate list.
   List&amp;lt;Object&amp;gt; interceptorList = new ArrayList&amp;lt;Object&amp;gt;(config.getAdvisors().length);
   Class&amp;lt;?&amp;gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());
   boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);
   AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();

   for (Advisor advisor : config.getAdvisors()) {
      if (advisor instanceof PointcutAdvisor) {
         // Add it conditionally.
         PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
         if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {
            MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
            MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
            if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {
               if (mm.isRuntime()) {
                  // Creating a new object instance in the getInterceptors() method
                  // isn&#39;t a problem as we normally cache created chains.
                  for (MethodInterceptor interceptor : interceptors) {
                     interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
                  }
               }
               else {
                  interceptorList.addAll(Arrays.asList(interceptors));
               }
            }
         }
      }
      else if (advisor instanceof IntroductionAdvisor) {
         IntroductionAdvisor ia = (IntroductionAdvisor) advisor;
         if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {
            Interceptor[] interceptors = registry.getInterceptors(advisor);
            interceptorList.addAll(Arrays.asList(interceptors));
         }
      }
      else {
         Interceptor[] interceptors = registry.getInterceptors(advisor);
         interceptorList.addAll(Arrays.asList(interceptors));
      }
   }

   return interceptorList;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里对引介通增强和非非引介增强做了不同处理，如果不是引介增强，就转换为MethodInterceptor，这里就暂时不讨论引介增强了。
- 遍历所有的通知器
- 调用AdvisorAdapterRegistry的getInterceptors方法将通知器里面的通知转换成MethodInterceptor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {
   List&amp;lt;MethodInterceptor&amp;gt; interceptors = new ArrayList&amp;lt;MethodInterceptor&amp;gt;(3);
   Advice advice = advisor.getAdvice();
   if (advice instanceof MethodInterceptor) {
      interceptors.add((MethodInterceptor) advice);
   }
   for (AdvisorAdapter adapter : this.adapters) {
      if (adapter.supportsAdvice(advice)) {
         interceptors.add(adapter.getInterceptor(advisor));
      }
   }
   if (interceptors.isEmpty()) {
      throw new UnknownAdviceTypeException(advisor.getAdvice());
   }
   return interceptors.toArray(new MethodInterceptor[interceptors.size()]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果通知是MethodInterceptor类型，就直接转换为MethodInterceptor。由于部分通知没有是实现MethodInterceptor接口，所以这时候需要用对应的适配器转换成MethodInterceptor，这里以MethodBeforeAdviceAdapter为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {

   @Override
   public boolean supportsAdvice(Advice advice) {
      return (advice instanceof MethodBeforeAdvice);
   }

   @Override
   public MethodInterceptor getInterceptor(Advisor advisor) {
      MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
      return new MethodBeforeAdviceInterceptor(advice);
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取到拦截器链之后
如果拦截器链为空，直接通过反射执行目标类的对应方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (chain.isEmpty()) {
   // We can skip creating a MethodInvocation: just invoke the target directly
   // Note that the final invoker must be an InvokerInterceptor so we know it does
   // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果拦截器链不为空，通过MethodInvocation对象来调用拦截器链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
// Proceed to the joinpoint through the interceptor chain.
retVal = invocation.proceed();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReflectiveMethodInvocation是MethodInvocation的一个实现，在这里用的真的很巧妙，就是通过它的proceed()方法，完成了对拦截器链的调用，proceed()方法源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Object proceed() throws Throwable {
   // We start with an index of -1 and increment early.
   if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
      return invokeJoinpoint();
   }

   Object interceptorOrInterceptionAdvice =
         this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
   if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
      // Evaluate dynamic method matcher here: static part will already have
      // been evaluated and found to match.
      InterceptorAndDynamicMethodMatcher dm =
            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
      if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
         return dm.interceptor.invoke(this);
      }
      else {
         // Dynamic matching failed.
         // Skip this interceptor and invoke the next in the chain.
         return proceed();
      }
   }
   else {
      // It&#39;s an interceptor, so we just invoke it: The pointcut will have
      // been evaluated statically before this object was constructed.
      return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this.currentInterceptorIndex代表拦截器链数组的下标，如果拦截器链执行完毕，就调用invokeJoinpoint()方法，其实就是通过反射执行目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private int currentInterceptorIndex = -1;

protected Object invokeJoinpoint() throws Throwable {
   return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果拦截器链没有执行完毕，就判断一下这个拦截器能不能在当前目前方法上增强，如果判断通过，就调用该拦截器的invoke的方法，其实这就是调用通知的逻辑代码；否则的话，继续执行下一个拦截器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;InterceptorAndDynamicMethodMatcher dm =
      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
   return dm.interceptor.invoke(this);
}
else {
   // Dynamic matching failed.
   // Skip this interceptor and invoke the next in the chain.
   return proceed();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里以MethodBeforeAdviceInterceptor为例，看看它的invoke方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {

   private MethodBeforeAdvice advice;


   /**
    * Create a new MethodBeforeAdviceInterceptor for the given advice.
    * @param advice the MethodBeforeAdvice to wrap
    */
   public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
      Assert.notNull(advice, &amp;quot;Advice must not be null&amp;quot;);
      this.advice = advice;
   }

   @Override
   public Object invoke(MethodInvocation mi) throws Throwable {
      this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );
      return mi.proceed();
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现里面先调用了this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );也就是 AspectJMethodBeforeAdvice的before方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void before(Method method, Object[] args, Object target) throws Throwable {
   invokeAdviceMethod(getJoinPointMatch(), null, null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;invokeAdviceMethod方法是在AbstractAspectJAdvice抽象类中实现的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object invokeAdviceMethod(JoinPointMatch jpMatch, Object returnValue, Throwable ex) throws Throwable {
   return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));
}



protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
   Object[] actualArgs = args;
   if (this.aspectJAdviceMethod.getParameterTypes().length == 0) {
      actualArgs = null;
   }
   try {
      ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
      // TODO AopUtils.invokeJoinpointUsingReflection
      return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
   }
   catch (IllegalArgumentException ex) {
      throw new AopInvocationException(&amp;quot;Mismatch on arguments to advice method [&amp;quot; +
            this.aspectJAdviceMethod + &amp;quot;]; pointcut expression [&amp;quot; +
            this.pointcut.getPointcutExpression() + &amp;quot;]&amp;quot;, ex);
   }
   catch (InvocationTargetException ex) {
      throw ex.getTargetException();
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这一句，其实通过反射调用对应通知的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此有关于通知的调用完成，然后执行一条语句，正是我们刚刚在调用拦截器的invoke方法时传过来的ReflectiveMethodInvocation对象，也就是说，这里继续调用下一个拦截器的invoke方法，知道所有的拦截器调用完毕，然后执行目标方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return mi.proceed();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，代理对象方法调用过程讲解完毕。当然，还是有一些细节不太清楚它的用意， 但整体脉络已经非常清楚了，影响不大，在使用的时候慢慢体会也行。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>SpringIOC</title>
      <link>https://www.spilledyear.cn/post/springioc/</link>
      <pubDate>Tue, 31 Jul 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/springioc/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/302.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;概述&#34;&gt;概述&lt;/h1&gt;

&lt;p&gt;IOC，全称&amp;rdquo;Inverse Of Control&amp;rdquo;，中文意思为控制反转，简单来讲，就是将创建对象的权限交给IOC容，在IOC中的这些对象，有一个统一的名称，叫做Bean；DI，全程&amp;rdquo;Dependence Injection&amp;rdquo;，中文意思为依赖注入。那依赖注入又是什么？当一个Bean实例引用到了另外一个Bean实例的时候，IOC容器帮助我们创建依赖Bean实例并注入到需要依赖Bean的那个Bean中。&lt;/p&gt;

&lt;p&gt;上面已经说了IOC是干嘛的，那么它是怎么实现的？它为我们创建Bean的具体流程是什么？抛开框架来讲，如果我们要实现这么一个功能，会怎么做？大概就是先读取配置文件，然后解析配置文件，然后根据解析结果创建对象吧？其实也就是这样的，不过Spring这个框架除了它本省提供的功能之外，更可贵的是它的设计，而设计这种东西，并不是你dbug一下就能理解的，也许要你要阅读源码很多遍才能体会，也许有一天你突然就明白了，本文的主要目的是弄清楚它的工作流程。&lt;/p&gt;

&lt;p&gt;如果对Bean生命周期稍有了解的同学都会知道，Bean实例化的时机其实是和你所使用的工厂类有关系的。如果你使用的是DefaultListableBeanFactory，那么它的实例化时机是在第一次使用该Bean的时候。第一次使用它的时候事什么意思？比如这样：factory.getBean(&amp;ldquo;simpleMethodInterceptor&amp;rdquo;)，就是第一次要用到它的时候就会实例化；如果你使用的是ApplicationContext，有关于Bean实例化的时机是要分情况的：
- 如果bean的scope是singleton的，并且lazy-init为false(默认是false，所以可以不用设置)，则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取
- 如果bean的scope是singleton的，并且lazy-init为true，则是在第一次使用该Bean的时候进行实例化
- 如果bean的scope是prototype的，则是在第一次使用该Bean的时候进行实例化&lt;/p&gt;

&lt;p&gt;可以看出，使用ApplicationContext的情况内部流程会复杂一些，但是对我们使用者而言，肯定是使用ApplicationContext更方便。接下来两种情况我都会介绍，其实很多东西都是一样，比如bean解析这一块，肯定是一样的，但我们的目的是研究其内部流程，所以先从简单的开始，简单的理解之后，复杂的理解起来也更容易了。&lt;/p&gt;

&lt;p&gt;这里再强调一下，本文的主要目的是分析其内部流程，如果想完完全全的弄懂其源码，还是挺困难的：一方面，你需要对Spring中的各种各样的配置非常熟悉，这样才能很快猜测出代码是什么意思；另一方面，你需要有足够多的时间和耐心去研究。源码值得读，但也不至于这样每行都揪着不放，而且代码这种东西，看第一遍和看第二遍感觉是完全不一样的。刚看一个框架的源码的时候，不要一下子就想着把它每行代码都弄得清清楚楚，了解整个框架的脉络比这更有意义，对感兴趣的地方，再去细读。&lt;/p&gt;

&lt;h1 id=&#34;bean生命周期&#34;&gt;Bean生命周期&lt;/h1&gt;

&lt;p&gt;为什么这里会先介绍Bean的生命周期？因为Bean生命周期是IOC中非常核心的内容，这里也体现了Spring这个框架的设计能力，它为我们预留了很多的接口，让我们在bean实例化前后、初始化前后可以写入一些自己的逻辑，有些情况下，这是非常重要的。&lt;/p&gt;

&lt;p&gt;那么什么是bean的生命周期呢？即在我们将xml配置文件中的一个个&amp;lt;bean&amp;gt;标签解析成一个个BeanDefinition之后，我们需要根据BeanDefinition进行bean的实例化(BeanDefinition也是一个非常重要的概念，它是用来做什么的？可以这样理解：xml配置文件中的一个个标签，我们可以认为它是一种描述信息，即它描述了一个bean应该是什么样子，注解的效果也基本是类似，然后在Spring对xml配置文件进行解析的时候，会将里面的一个个标签解析成一个个BeanDefinition对象，然后在Spring创建bean实例的时候，直接根据BeanDefinition就可以很方便的创建bean实例了，可以认为BeanDefinition是对xml标签的一种抽象)，bean的实例化的简单来讲就是new对象，但是在new对象的前后、初始化对象的前后，Spring为我们预留了非常多的接口，让我们而可以插入自己的逻辑，而整个流程下来，就可以称为bean的生命周期。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 根据BeanDefinition信息，实例化对象;

2. 根据BeanDefinition信息，配置Bean的所有属性;

3. 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName，参数为Bean的Id;

4. 如果Bean实现BeanFactoryAware或者ApplicationContextAware接口，设置工厂setBeanFactory 或者上下文对象 setApplicationContext

5. 如果存在类实现了BeanPostProcessor接口，执行这些实现类的postProcessBeforeInitialization方法，这相当于在Bean初始化之前插入逻辑

6. 如果Bean实现InitializingBean接口， 执行afterPropertiesSet方法

7. 如果Bean指定了init-method方法，就会调用该方法。例：\&amp;lt;bean init-method=&amp;quot;init&amp;quot;&amp;gt;

8. 如果存在类实现了BeanPostProcessor接口，执行这些实现类的postProcessAfterInitialization方法，这相当于在Bean初始化之后插入逻辑

9. 这个阶段Bean已经可以使用了，scope为singleton的Bean会被缓存在IOC容器中

10. 如果Bean实现了DisposableBean接口， 在容器销毁的时候执行destroy方法。

11. 如果配置了destory-method方法，就调用该方法。例：\&amp;lt;bean destroy-method=&amp;quot;customerDestroy&amp;quot;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里将Bean生命周期这块内容放到最前面，是为了提前让大家对这块内容有个印象。&lt;/p&gt;

&lt;h1 id=&#34;beanfactory流程&#34;&gt;BeanFactory流程&lt;/h1&gt;

&lt;p&gt;前面我们说到，主要流程包括 状态配置文件、解析配置文件、创建Bean，那我们现在就按照这个流程来分析吧。在网上看了一些IOC源码解析的文档，大部会从这行代码开始&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;quot;bean.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是我们上面说到的使用ApplicationContext方式，这是我们第二大章节要介绍的。ApplicationContext在Spring中是一个非常高级的接口了，它继承了很多接口，有非常多的方法，所以我们在使用的是时候，这么一行代码就帮我们创建好了IOC容器。使用的时候肯定很舒服了，但是一上来就用来做源码分析，不太好，里面的功能太多了，看着就怕。&lt;/p&gt;

&lt;p&gt;我们就按前面说到的那三个流程来解析，因为Spring中本来也就是这样做的呀，ApplicationContext只不过是为了方便我们使用而封装出的一个更高级的接口。我们先把这三个流程弄清楚，之后再来分析ApplicationContext，这样就很舒服了。&lt;/p&gt;

&lt;p&gt;有关于本大章节的测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TestBeanFactory {
    public static void main(String[] args) {
        // 资源加载器
        ResourceLoader resLoaderr = new DefaultResourceLoader();
        // 获取资源
        Resource resource = resLoaderr.getResource(&amp;quot;config.xml&amp;quot;);

        // 工程实现类
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
        // XML解析器，将解析后的BeanDefinition 放到 factory 的Map中缓存起来
        BeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(factory);
        // 解析XML入口
        beanDefinitionReader.loadBeanDefinitions(resource);
        
        // 获取Bean实例。实际上，Bean在上面的流程中并没有实例话，只有在首次使用它的时候才会实例化
        Object o = factory.getBean(&amp;quot;simpleMethodInterceptor&amp;quot;);
        System.out.println(o);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;加载配置文件&#34;&gt;加载配置文件&lt;/h3&gt;

&lt;p&gt;加载配置文件大家首先会想到什么？应该是IO流吧。Spring肯定会做封装，先不要关心这些，以下代码就会为我们加载配置文件到Resource中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 资源加载器
ResourceLoader resLoaderr = new DefaultResourceLoader();
// 获取资源
Resource resource = resLoaderr.getResource(&amp;quot;config.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于这两行代码，没有什么特别的东西，可以看一下getResource方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final Set&amp;lt;ProtocolResolver&amp;gt; protocolResolvers = new LinkedHashSet&amp;lt;ProtocolResolver&amp;gt;(4);

public Resource getResource(String location) {
    Assert.notNull(location, &amp;quot;Location must not be null&amp;quot;);

    for (ProtocolResolver protocolResolver : this.protocolResolvers) {
        Resource resource = protocolResolver.resolve(location, this);
        if (resource != null) {
            return resource;
        }
    }

    // 判断是不是 &amp;quot;/&amp;quot; 开头， 例如 /aa/bb/bean.xml
    if (location.startsWith(&amp;quot;/&amp;quot;)) {
        return getResourceByPath(location);
    }

    // 判断是不是 &amp;quot;classpath:&amp;quot; 开头， 例如 classpath:aplication.xml
    else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
    }

    else {
        try {
            // 尝试通过URL的方式解析这个路径，在我们这个例子会抛出异常
            URL url = new URL(location);
            return new UrlResource(url);
        }
        catch (MalformedURLException ex) {
            // 在我们这个Demo中，实际会走这里
            // No URL -&amp;gt; resolve as resource path.
            return getResourceByPath(location);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ProtocolResolver是一个资源解析器接口，我们可以通过实现ProtocolResolver接口来自定义资源解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ProtocolResolver {
	/**
	 * Resolve the given location against the given resource loader
	 * if this implementation&#39;s protocol matches.
	 */
	Resource resolve(String location, ResourceLoader resourceLoader);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看一下 getResourceByPath 方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Resource getResourceByPath(String path) {
    return new ClassPathContextResource(path, getClassLoader());
}


protected static class ClassPathContextResource extends ClassPathResource implements ContextResource {

    public ClassPathContextResource(String path, ClassLoader classLoader) {
        super(path, classLoader);
    }
}



// ClassPathResource 构造方法
public ClassPathResource(String path, ClassLoader classLoader) {
    Assert.notNull(path, &amp;quot;Path must not be null&amp;quot;);
    // 将 window下的 路径符 &amp;quot;\\&amp;quot; 换成 &amp;quot;/&amp;quot;
    String pathToUse = StringUtils.cleanPath(path);
    if (pathToUse.startsWith(&amp;quot;/&amp;quot;)) {
        pathToUse = pathToUse.substring(1);
    }
    this.path = pathToUse;
    this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;解析配置文件&#34;&gt;解析配置文件&lt;/h3&gt;

&lt;p&gt;有关于这一阶段的时序图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-2a6240ae8a2f9af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;post_002&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// BeanDefinitionReader 就是XML解析器
BeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(factory);
beanDefinitionReader.loadBeanDefinitions(resource);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析配置我们这里使用了XmlBeanDefinitionReader，有关于XmlBeanDefinitionReader，创建它的时候需要指定一个BeanDefinitionRegistry对象。但是这里为什么传一个DefaultListableBeanFactory对象进去，可以看看他们的继承关系图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-a374443ea031df2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;post_003&#34; /&gt;&lt;/p&gt;

&lt;p&gt;DefaultListableBeanFactory实现了非常多的接口，其中就包括BeanFactory和 XmlBeanDefinitionReader。&lt;/p&gt;

&lt;p&gt;解析配置文件的入口，就在loadBeanDefinitions方法中，接收刚刚创建的Resource对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final ThreadLocal&amp;lt;Set&amp;lt;EncodedResource&amp;gt;&amp;gt; resourcesCurrentlyBeingLoaded =
			new NamedThreadLocal&amp;lt;Set&amp;lt;EncodedResource&amp;gt;&amp;gt;(&amp;quot;XML bean definition resources currently being loaded&amp;quot;);


public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    // 转换成 EncodedResource
    return loadBeanDefinitions(new EncodedResource(resource));
}

public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
    Assert.notNull(encodedResource, &amp;quot;EncodedResource must not be null&amp;quot;);
    if (logger.isInfoEnabled()) {
        logger.info(&amp;quot;Loading XML bean definitions from &amp;quot; + encodedResource.getResource());
    }

    // 相当于是个缓存
    Set&amp;lt;EncodedResource&amp;gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
    if (currentResources == null) {
        currentResources = new HashSet&amp;lt;EncodedResource&amp;gt;(4);
        this.resourcesCurrentlyBeingLoaded.set(currentResources);
    }
    if (!currentResources.add(encodedResource)) {
        throw new BeanDefinitionStoreException(
                &amp;quot;Detected cyclic loading of &amp;quot; + encodedResource + &amp;quot; - check your import definitions!&amp;quot;);
    }

    try {
        // 获取到资源文件输入流
        InputStream inputStream = encodedResource.getResource().getInputStream();
        try {
            InputSource inputSource = new InputSource(inputStream);
            if (encodedResource.getEncoding() != null) {
                inputSource.setEncoding(encodedResource.getEncoding());
            }

            // 开始执行真正的解析操作
            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
        }
        finally {
            inputStream.close();
        }
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(
                &amp;quot;IOException parsing XML document from &amp;quot; + encodedResource.getResource(), ex);
    }
    finally {
        currentResources.remove(encodedResource);
        if (currentResources.isEmpty()) {
            this.resourcesCurrentlyBeingLoaded.remove();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EncodedResource是用来设置编码的，即设置以什么样的编码格式读取文件，这里默认为null&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public EncodedResource(Resource resource) {
    this(resource, null, null);
}

private EncodedResource(Resource resource, String encoding, Charset charset) {
    super();
    Assert.notNull(resource, &amp;quot;Resource must not be null&amp;quot;);
    this.resource = resource;
    this.encoding = encoding;
    this.charset = charset;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码中我们可以发现，真正的解析逻辑在doLoadBeanDefinitions方法中。你多阅读一些代码就会发现，在Spring中，干实事的方法都是以 do 开始的。接下来分析一下doLoadBeanDefinitions方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
        throws BeanDefinitionStoreException {
    try {
        // 获取xml dom树
        Document doc = doLoadDocument(inputSource, resource);

        // 根据dom树 注册 BeanDefinition
        return registerBeanDefinitions(doc, resource);
    }
    catch (BeanDefinitionStoreException ex) {
        throw ex;
    }
    catch (SAXParseException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &amp;quot;Line &amp;quot; + ex.getLineNumber() + &amp;quot; in XML document from &amp;quot; + resource + &amp;quot; is invalid&amp;quot;, ex);
    }
    catch (SAXException ex) {
        throw new XmlBeanDefinitionStoreException(resource.getDescription(),
                &amp;quot;XML document from &amp;quot; + resource + &amp;quot; is invalid&amp;quot;, ex);
    }
    catch (ParserConfigurationException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &amp;quot;Parser configuration exception parsing XML from &amp;quot; + resource, ex);
    }
    catch (IOException ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &amp;quot;IOException parsing XML document from &amp;quot; + resource, ex);
    }
    catch (Throwable ex) {
        throw new BeanDefinitionStoreException(resource.getDescription(),
                &amp;quot;Unexpected exception parsing XML document from &amp;quot; + resource, ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实主要就两行代码，首先就是获取xml文件 dom 树，就是将xml 文件解析成一个Document对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
        ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Using JAXP provider [&amp;quot; + factory.getClass().getName() + &amp;quot;]&amp;quot;);
    }
    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
    return builder.parse(inputSource);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个解析dom没什么好说的，主要看看registerBeanDefinitions方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
    // 用于从 xml document 对象中 获取 BeanDefinition
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
    int countBefore = getRegistry().getBeanDefinitionCount();
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
    return getRegistry().getBeanDefinitionCount() - countBefore;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里引出了一个新对象BeanDefinitionDocumentReader，它的主要功能就是从 document 对象中获取bean，简单来说，就是找到document dom树中的bean对象。那个方法还是有点不一样的&lt;/p&gt;

&lt;p&gt;BeanUtils.instantiateClass方法通过无参构造函数创建一个对象，Class.cast 方法用于将一个对象装换为类或者接口，法只能转换当前类型或其子类下的对象，只是简单进行强转。但我不知道这里为啥要这样写啊！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
    return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;getRegistry()方法就是返回我们一开始传进去的DefaultListableBeanFactory。这行代码就是返回DefaultListableBeanFactory中beanDefinitionMap中的元素个数，beanDefinitionMap是啥？它缓存当前容器内的BeanDefinition，BeanDefinition是Bean的描述，Spring会先将 xml document 中的节点解析成一个个BeanDefinition，然后在后续阶段将BeanDefinition生成 真正的Bean。也就是说，这里是返回“此刻当前容器中的BeanDefinition个数”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int countBefore = getRegistry().getBeanDefinitionCount();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条return语句，代表返回本次创建的 BeanDefinition 个数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return getRegistry().getBeanDefinitionCount() - countBefore;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，主要的逻辑代码，在registerBeanDefinitions方法中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;createReaderContext返回一个XmlReaderContext对象，这个对象里面主要是包括一些参数吧。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public XmlReaderContext createReaderContext(Resource resource) {
    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
            this.sourceExtractor, this, getNamespaceHandlerResolver());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于xml命名空间处理解析器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public NamespaceHandlerResolver getNamespaceHandlerResolver() {
    if (this.namespaceHandlerResolver == null) {
        this.namespaceHandlerResolver = createDefaultNamespaceHandlerResolver();
    }
    return this.namespaceHandlerResolver;
}

protected NamespaceHandlerResolver createDefaultNamespaceHandlerResolver() {
    return new DefaultNamespaceHandlerResolver(getResourceLoader().getClassLoader());
}

/**
    * The location to look for the mapping files. Can be present in multiple JAR files.
    */
public static final String DEFAULT_HANDLER_MAPPINGS_LOCATION = &amp;quot;META-INF/spring.handlers&amp;quot;;

public DefaultNamespaceHandlerResolver(ClassLoader classLoader) {
    this(classLoader, DEFAULT_HANDLER_MAPPINGS_LOCATION);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概知道有这么些东西就可以了。接下来看看 DefaultBeanDefinitionDocumentReader 中的 registerBeanDefinitions 方法具体实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    this.readerContext = readerContext;
    logger.debug(&amp;quot;Loading bean definitions&amp;quot;);
    Element root = doc.getDocumentElement();
    doRegisterBeanDefinitions(root);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了吗？又是一个do开头的方法，说明这里是干实事的地方&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void doRegisterBeanDefinitions(Element root) {
    // parent是为了处理 &amp;lt;beans&amp;gt; 中嵌套 &amp;lt;beans&amp;gt; 的情况
    BeanDefinitionParserDelegate parent = this.delegate;
    this.delegate = createDelegate(getReaderContext(), root, parent);

    // 是否是默认 命名空间 &amp;quot;http://www.springframework.org/schema/beans&amp;quot;
    if (this.delegate.isDefaultNamespace(root)) {
        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
        if (StringUtils.hasText(profileSpec)) {
            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
                if (logger.isInfoEnabled()) {
                    logger.info(&amp;quot;Skipped XML bean definition file due to specified profiles [&amp;quot; + profileSpec +
                            &amp;quot;] not matching: &amp;quot; + getReaderContext().getResource());
                }
                return;
            }
        }
    }

    preProcessXml(root);
    parseBeanDefinitions(root, this.delegate);
    postProcessXml(root);

    this.delegate = parent;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里又引出一个新对象BeanDefinitionParserDelegate，这是一个委托类，所有解析DOM的逻辑都交给这个类来处理。&lt;/p&gt;

&lt;p&gt;第一行代码就值得分析一下。Spring解析XML的时候，是以&lt;beans&gt;&lt;/beans&gt;为最外层标签进行解析的，但是&lt;beans&gt;可以嵌套 &lt;beans&gt;，这种情况下，外层&lt;beans&gt;对应的BeanDefinitionParserDelegate委托类就是里层&lt;beans&gt;中的parent，因为可以从parent中继承一些默认属性。下面举一个例子来说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xmlns:jee=&amp;quot;http://www.springframework.org/schema/jee&amp;quot;
       xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xmlns:task=&amp;quot;http://www.springframework.org/schema/task&amp;quot;
       xsi:schemaLocation=&amp;quot;
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd&amp;quot;&amp;gt;

    &amp;lt;bean id=&amp;quot;BookInterceptor&amp;quot; class=&amp;quot;aop.BookInterceptor&amp;quot; /&amp;gt;   

    &amp;lt;beans&amp;gt;
        &amp;lt;bean id=&amp;quot;simpleMethodInterceptor2&amp;quot; class=&amp;quot;aop.SimpleMethodInterceptor&amp;quot; &amp;gt;&amp;lt;/bean&amp;gt;
    &amp;lt;/beans&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析最外层&lt;beans&gt;的时候，parent为null，这时候会创建一个BeanDefinitionParserDelegate委托类 delegate1，然后先解析 &lt;bean id=&#34;BookInterceptor&#34; ... /&gt; ，解析完这个标签之后，又遇到一个&lt;beans&gt;，这时候又会调用doRegisterBeanDefinitions方法，将 delegate1 作为parent，同时创建一个 BeanDefinitionParserDelegate委托类 delegate2，这时候的一些默认属性会从delegate1中继承。
这里相当于有个递归调用，遇到&lt;beans&gt;标签就调用doRegisterBeanDefinitionsf方法，同时将外层的委托类赋值给本次调用中的parent，如果没有外层，parent就为nulll&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanDefinitionParserDelegate parent = this.delegate;

protected BeanDefinitionParserDelegate createDelegate(
        XmlReaderContext readerContext, Element root, BeanDefinitionParserDelegate parentDelegate) {
    BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
    delegate.initDefaults(root, parentDelegate);
    return delegate;
}

public void initDefaults(Element root, BeanDefinitionParserDelegate parent) {
    // 设置一些默认属性
    populateDefaults(this.defaults, (parent != null ? parent.defaults : null), root);
    this.readerContext.fireDefaultsRegistered(this.defaults);
}



public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = &amp;quot;default-lazy-init&amp;quot;;
public static final String DEFAULT_MERGE_ATTRIBUTE = &amp;quot;default-merge&amp;quot;;
public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = &amp;quot;default-autowire&amp;quot;;
public static final String DEFAULT_DEPENDENCY_CHECK_ATTRIBUTE = &amp;quot;default-dependency-check&amp;quot;;
public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = &amp;quot;default-autowire-candidates&amp;quot;;
public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = &amp;quot;default-init-method&amp;quot;;
public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = &amp;quot;default-destroy-method&amp;quot;;

// 设置一些默认属性
protected void populateDefaults(DocumentDefaultsDefinition defaults, DocumentDefaultsDefinition parentDefaults, Element root) {
    String lazyInit = root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);
    if (DEFAULT_VALUE.equals(lazyInit)) {
        // Potentially inherited from outer &amp;lt;beans&amp;gt; sections, otherwise falling back to false.
        lazyInit = (parentDefaults != null ? parentDefaults.getLazyInit() : FALSE_VALUE);
    }
    defaults.setLazyInit(lazyInit);

    String merge = root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);
    if (DEFAULT_VALUE.equals(merge)) {
        // Potentially inherited from outer &amp;lt;beans&amp;gt; sections, otherwise falling back to false.
        merge = (parentDefaults != null ? parentDefaults.getMerge() : FALSE_VALUE);
    }
    defaults.setMerge(merge);

    String autowire = root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);
    if (DEFAULT_VALUE.equals(autowire)) {
        // Potentially inherited from outer &amp;lt;beans&amp;gt; sections, otherwise falling back to &#39;no&#39;.
        autowire = (parentDefaults != null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);
    }
    defaults.setAutowire(autowire);

    // Don&#39;t fall back to parentDefaults for dependency-check as it&#39;s no longer supported in
    // &amp;lt;beans&amp;gt; as of 3.0. Therefore, no nested &amp;lt;beans&amp;gt; would ever need to fall back to it.
    defaults.setDependencyCheck(root.getAttribute(DEFAULT_DEPENDENCY_CHECK_ATTRIBUTE));

    if (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) {
        defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));
    }
    else if (parentDefaults != null) {
        defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());
    }

    if (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) {
        defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));
    }
    else if (parentDefaults != null) {
        defaults.setInitMethod(parentDefaults.getInitMethod());
    }

    if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) {
        defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));
    }
    else if (parentDefaults != null) {
        defaults.setDestroyMethod(parentDefaults.getDestroyMethod());
    }

    defaults.setSource(this.readerContext.extractSource(root));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;preProcessXml 和 postProcessXml 这两个方法是空的，用户可以通过继承来添加自己的逻辑。主要是parseBeanDefinitions方法，这里面主要就是遍历DOM中的所有Element节点，即标签。如果是默认命名空间下的标签，就调用parseDefaultElement方法，如果不是默认命名空间下的标签，就调用委托类的parseCustomElement方法。其实这里主要即使委托类来实现那了，parseDefaultElement方法里面的主要逻辑也是调用了委托类的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i &amp;lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;root 就相当于是的&lt;beans&gt;标签，经常会看到判断是否是命名空间，这里的命名空间指的是  &amp;ldquo;&lt;a href=&#34;http://www.springframework.org/schema/beans&amp;quot;，bean&#34;&gt;http://www.springframework.org/schema/beans&amp;quot;，bean&lt;/a&gt; 和 beans 标签都属于默认命名空间。&lt;/p&gt;

&lt;p&gt;有关于 org.w3c.dom.Document 下的 Node，Node是一个顶层接口，它下面有几个子接口。在DOM树中，所有东西都可以叫Node，标签也是一种Node，但它实际上上叫Element。举个例子说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;book price=&amp;quot;100&amp;quot;&amp;gt;
    &amp;lt;chineseBook&amp;gt;哈利波特.哈哈哈&amp;lt;chineseBook&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在以上的代码片段中，price 是属性节点；哈利波特.哈哈哈  是 文本节点；&amp;lt;book price=&amp;ldquo;100&amp;rdquo;&amp;gt;..&amp;lt;/book&amp;gt; 和 &amp;lt;chineseBook&amp;gt;哈利波特.哈哈哈&amp;lt;chineseBook&amp;gt; 是Element节点。所以，不要被Node搞晕了&lt;/p&gt;

&lt;p&gt;这里主要以/&lt;bean&gt; 标签进行说明，所以主要关注parseDefaultElement方法，可以看到，当是&amp;lt;beans/&amp;gt;标签的时候，又调用了doRegisterBeanDefinitions方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {

    // &amp;lt;import/&amp;gt; 标签
    if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
        importBeanDefinitionResource(ele);
    }

    // &amp;lt;alias/&amp;gt; 标签
    else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
        processAliasRegistration(ele);
    }

    // &amp;lt;bean/&amp;gt; 标签
    else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
        processBeanDefinition(ele, delegate);
    }

    // &amp;lt;beans/&amp;gt; 标签 
    else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
        doRegisterBeanDefinitions(ele);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析&amp;lt;bean&amp;gt; 标签的processBeanDefinition方法源码如下，这里主要就是委托类BeanDefinitionParserDelegate的主场了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 返回一个 BeanDefinition 持有者
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);

    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
        try {
            // Register the final decorated instance.
            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
        }
        catch (BeanDefinitionStoreException ex) {
            getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; +
                    bdHolder.getBeanName() + &amp;quot;&#39;&amp;quot;, ele, ex);
        }
        // Send registration event.
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BeanDefinitionParserDelegate # parseBeanDefinitionElement&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
    return parseBeanDefinitionElement(ele, null);
}

public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
    // 如果没有定义name属性，就以id属性的值作为beanName；如果定义了beanName，就以name属性的值作为beanName
    String id = ele.getAttribute(ID_ATTRIBUTE);
    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

    List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;String&amp;gt;();
    if (StringUtils.hasLength(nameAttr)) {
        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
        aliases.addAll(Arrays.asList(nameArr));
    }

    String beanName = id;
    if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
        beanName = aliases.remove(0);
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;No XML &#39;id&#39; specified - using &#39;&amp;quot; + beanName +
                    &amp;quot;&#39; as bean name and &amp;quot; + aliases + &amp;quot; as aliases&amp;quot;);
        }
    }

    // 校验 beanName的唯一性
    if (containingBean == null) {
        checkNameUniqueness(beanName, aliases, ele);
    }

    // 主要的解析逻辑就是在这个方法中，解析成功返回一个 AbstractBeanDefinition；解析失败返回 null
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);

    // 下面主要就是一些后置处理
    if (beanDefinition != null) {
        if (!StringUtils.hasText(beanName)) {
            try {
                if (containingBean != null) {
                    beanName = BeanDefinitionReaderUtils.generateBeanName(
                            beanDefinition, this.readerContext.getRegistry(), true);
                }
                else {
                    beanName = this.readerContext.generateBeanName(beanDefinition);
                    // Register an alias for the plain bean class name, if still possible,
                    // if the generator returned the class name plus a suffix.
                    // This is expected for Spring 1.2/2.0 backwards compatibility.
                    String beanClassName = beanDefinition.getBeanClassName();
                    if (beanClassName != null &amp;amp;&amp;amp;
                            beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
                            !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
                        aliases.add(beanClassName);
                    }
                }
                if (logger.isDebugEnabled()) {
                    logger.debug(&amp;quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &amp;quot; +
                            &amp;quot;using generated bean name [&amp;quot; + beanName + &amp;quot;]&amp;quot;);
                }
            }
            catch (Exception ex) {
                error(ex.getMessage(), ele);
                return null;
            }
        }
        String[] aliasesArray = StringUtils.toStringArray(aliases);

        // 通过上面生成的 beanDefinition 构造一个 BeanDefinitionHolder
        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建AbstractBeanDefinition的主要逻辑又是调用了parseBeanDefinitionElement的一个重载方法，其中有很大一部分逻辑是这是BeanDefinition属性，如果想弄的清清楚楚，还是需要花一点时间的，这里就跳过吧，只要明白：这里为BeanDefinition设置这么多属性，都是因为之后生成Bean实例的时候，需要BeanDefinition中维护的信息，BeanDefinition是生成Bean实例的根本，很重要！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public AbstractBeanDefinition parseBeanDefinitionElement(
        Element ele, String beanName, BeanDefinition containingBean) {

    this.parseState.push(new BeanEntry(beanName));

    String className = null;
    if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
    }

    try {
        String parent = null;
        if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
            parent = ele.getAttribute(PARENT_ATTRIBUTE);
        }

        // 生成一个GenericBeanDefinition并返回，同时根据className创建一个对应的Class对象设置为GenericBeanDefinition的beanClass属性。
        AbstractBeanDefinition bd = createBeanDefinition(className, parent);

        // 下面这些就是有关于一些属性啥的解析，如果想弄的清清楚楚，还是需要花一点时间的，这里就跳过吧，只要明白：这里为BeanDefinition设置这么多属性，都是因为之后生成Bean实例的时候，需要BeanDefinition中维护的信息，BeanDefinition是生成Bean实例的根本，很重要！
        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

        parseMetaElements(ele, bd);
        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

        parseConstructorArgElements(ele, bd);
        parsePropertyElements(ele, bd);
        parseQualifierElements(ele, bd);

        bd.setResource(this.readerContext.getResource());
        bd.setSource(extractSource(ele));

        return bd;
    }
    catch (ClassNotFoundException ex) {
        error(&amp;quot;Bean class [&amp;quot; + className + &amp;quot;] not found&amp;quot;, ele, ex);
    }
    catch (NoClassDefFoundError err) {
        error(&amp;quot;Class that bean class [&amp;quot; + className + &amp;quot;] depends on not found&amp;quot;, ele, err);
    }
    catch (Throwable ex) {
        error(&amp;quot;Unexpected failure during bean definition parsing&amp;quot;, ele, ex);
    }
    finally {
        this.parseState.pop();
    }

    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成之后就返回到DefaultBeanDefinitionDocumentReader 中的 processBeanDefinition 方法中,然后又调用BeanDefinitionParserDelegate的decorateBeanDefinitionIfRequiredf方法进行装饰BeanDefinitionHolder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (bdHolder != null) {
    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
  ......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;decorateBeanDefinitionIfRequired主要实现如下，具体的不太了解&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) {
	return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);
}

public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
        Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd) {

    BeanDefinitionHolder finalDefinition = definitionHolder;

    //装饰自定义属性
    // Decorate based on custom attributes first.
    NamedNodeMap attributes = ele.getAttributes();
    for (int i = 0; i &amp;lt; attributes.getLength(); i++) {
        Node node = attributes.item(i);
        finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
    }

    //装饰自定义标签
    // Decorate based on custom nested elements.
    NodeList children = ele.getChildNodes();
    for (int i = 0; i &amp;lt; children.getLength(); i++) {
        Node node = children.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
        }
    }
    return finalDefinition;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;装饰完成之后，继续返回到 DefaultBeanDefinitionDocumentReader 的processBeanDefinition方法，然后注册最终的BeanDefinition。注意该方法的第二个参数，其实就是我们一开始传进去的DefaultListableBeanFactory对象，主要流程就是将当前生成的BeanDefinition放到DefaultListableBeanFactory的一个Map中缓存起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());


public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
        throws BeanDefinitionStoreException {

    // 通过beanName注册 BeanDefinition
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // 如果该bean有别名，为该bean注册别名
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以具体看看DefaultListableBeanFactory对象中的registerBeanDefinition方法，大概就是将BeanDefinition放到beanDefinitionMap中缓存起来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** Map of bean definition objects, keyed by bean name */
private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt;(256);


public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
        throws BeanDefinitionStoreException {

    Assert.hasText(beanName, &amp;quot;Bean name must not be empty&amp;quot;);
    Assert.notNull(beanDefinition, &amp;quot;BeanDefinition must not be null&amp;quot;);

    if (beanDefinition instanceof AbstractBeanDefinition) {
        try {
            // 简单校验,检验啥 overridden 方法，不太清楚，没用过
            ((AbstractBeanDefinition) beanDefinition).validate();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &amp;quot;Validation of bean definition failed&amp;quot;, ex);
        }
    }

    BeanDefinition oldBeanDefinition;

    oldBeanDefinition = this.beanDefinitionMap.get(beanName);
    if (oldBeanDefinition != null) {
        // 检查该BeanDefinition是否在容器中已经存在，如果已经存在，bing且不允许覆盖已经注册的BeanDefinitio，则报错
        if (!isAllowBeanDefinitionOverriding()) {
            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
                    &amp;quot;Cannot register bean definition [&amp;quot; + beanDefinition + &amp;quot;] for bean &#39;&amp;quot; + beanName +
                    &amp;quot;&#39;: There is already [&amp;quot; + oldBeanDefinition + &amp;quot;] bound.&amp;quot;);
        }
        else if (oldBeanDefinition.getRole() &amp;lt; beanDefinition.getRole()) {
            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
            if (this.logger.isWarnEnabled()) {
                this.logger.warn(&amp;quot;Overriding user-defined bean definition for bean &#39;&amp;quot; + beanName +
                        &amp;quot;&#39; with a framework-generated bean definition: replacing [&amp;quot; +
                        oldBeanDefinition + &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
            }
        }
        else if (!beanDefinition.equals(oldBeanDefinition)) {
            if (this.logger.isInfoEnabled()) {
                this.logger.info(&amp;quot;Overriding bean definition for bean &#39;&amp;quot; + beanName +
                        &amp;quot;&#39; with a different definition: replacing [&amp;quot; + oldBeanDefinition +
                        &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
            }
        }
        else {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(&amp;quot;Overriding bean definition for bean &#39;&amp;quot; + beanName +
                        &amp;quot;&#39; with an equivalent definition: replacing [&amp;quot; + oldBeanDefinition +
                        &amp;quot;] with [&amp;quot; + beanDefinition + &amp;quot;]&amp;quot;);
            }
        }

        // 如果允许覆盖，根据 beanName，用新的 BeanDefinition 覆盖老的 BeanDefinition
        this.beanDefinitionMap.put(beanName, beanDefinition);
    }

    // 首次创建的 BeanDefinition
    else {
        // 检查此工厂的bean创建阶段是否已经开始？检查当前是不是已经开始实例化了？
        if (hasBeanCreationStarted()) {
            // 无法修改启动时的元素?
            // Cannot modify startup-time collection elements anymore (for stable iteration)
            synchronized (this.beanDefinitionMap) {
                this.beanDefinitionMap.put(beanName, beanDefinition);
                List&amp;lt;String&amp;gt; updatedDefinitions = new ArrayList&amp;lt;String&amp;gt;(this.beanDefinitionNames.size() + 1);
                updatedDefinitions.addAll(this.beanDefinitionNames);
                updatedDefinitions.add(beanName);
                this.beanDefinitionNames = updatedDefinitions;
                if (this.manualSingletonNames.contains(beanName)) {
                    Set&amp;lt;String&amp;gt; updatedSingletons = new LinkedHashSet&amp;lt;String&amp;gt;(this.manualSingletonNames);
                    updatedSingletons.remove(beanName);
                    this.manualSingletonNames = updatedSingletons;
                }
            }
        }
        else {
            // Still in startup registration phase
            this.beanDefinitionMap.put(beanName, beanDefinition);
            this.beanDefinitionNames.add(beanName);
            this.manualSingletonNames.remove(beanName);
        }
        this.frozenBeanDefinitionNames = null;
    }

    if (oldBeanDefinition != null || containsSingleton(beanName)) {
        // 如果有覆盖的情况，就刷新缓存
        resetBeanDefinition(beanName);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，在DefaultBeanDefinitionDocumentReader对象的processBeanDefinition 方法中发出响应事件，通知相关监听器这个 Bean 已经被加载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 通过 fireComponentRegistered 方法进行通知监听器解析及注册完成工作，这里的实现只为扩展，当程序开发人员需要对注册BeanDefinition事件进行监听时，可以通过注册监听器的方式并将处理逻辑写入监听器中，目前 Spring 中并没有对此事件做任何处理。

getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，有关于解析XML文件的内容就算完事了，接着就是按照方法调用栈返回，最后返回一个该配置文件对应生成BeanDefinition个数。&lt;/p&gt;

&lt;h3 id=&#34;生成bean实例&#34;&gt;生成Bean实例&lt;/h3&gt;

&lt;p&gt;有关于这一阶段的时序图，这个图画的不太好，凑合看一下吧，哭&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-3d5d90308f874d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;post_004&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在第一次使用该Bean的时候进行实例化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 获取Bean实例。实际上，Bean在上面的流程中并没有实例话，只有在首次使用它的时候才会实例化
Object o = factory.getBean(&amp;quot;simpleMethodInterceptor&amp;quot;);
System.out.println(o);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DefaultListableBeanFactory 类继承了 AbstractAutowireCapableBeanFactory 抽象类，getBean方法就是在该抽象类中进行实例化的。追踪该方法可以发现，又是一个do开头的方法，说明里面就是具体逻辑了。这个方法还挺长，接下来我们分步解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public Object getBean(String name) throws BeansException {
    return doGetBean(name, null, null, false);
}

protected &amp;lt;T&amp;gt; T doGetBean(
        final String name, final Class&amp;lt;T&amp;gt; requiredType, final Object[] args, boolean typeCheckOnly)
        throws BeansException {

    // 去除前缀 &amp;amp;；如果名称是别名，则跟进别名返回 name
    final String beanName = transformedBeanName(name);
    Object bean;

    // 据beanName从 Map缓存 中获取单例Bean实例
    Object sharedInstance = getSingleton(beanName);
    if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
        if (logger.isDebugEnabled()) {
            if (isSingletonCurrentlyInCreation(beanName)) {
                logger.debug(&amp;quot;Returning eagerly cached instance of singleton bean &#39;&amp;quot; + beanName +
                        &amp;quot;&#39; that is not fully initialized yet - a consequence of a circular reference&amp;quot;);
            }
            else {
                logger.debug(&amp;quot;Returning cached instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
            }
        }
        // 如果指定名称的Bean在容器中已有单态模式的Bean被创建，直接返回已经创建的Bean实例。当这个bean时FactoryBean的时候，需要特别处理
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
    }

    // 缓存中没有，就创建
    else {
        // 尝试解决循环依赖问题
        // Fail if we&#39;re already creating this bean instance:
        // We&#39;re assumably within a circular reference.
        if (isPrototypeCurrentlyInCreation(beanName)) {
            throw new BeanCurrentlyInCreationException(beanName);
        }

        //对IoC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否  
58      //能在当前的BeanFactory中获取的所需要的Bean，如果不能则委托当前容器  
59      //的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找 
        // Check if bean definition exists in this factory.
        BeanFactory parentBeanFactory = getParentBeanFactory();
        // 当前容器的父级容器存在，且当前容器中不存在指定名称的Bean  
        if (parentBeanFactory != null &amp;amp;&amp;amp; !containsBeanDefinition(beanName)) {
            // Not found -&amp;gt; check parent.
            // 解析指定Bean名称的原始名称 
            String nameToLookup = originalBeanName(name);
            if (args != null) {
                // Delegation to parent with explicit args.
                // 委派父级容器根据指定名称和显式的参数查找 
                return (T) parentBeanFactory.getBean(nameToLookup, args);
            }
            else {
                // No args -&amp;gt; delegate to standard getBean method.
                // 委派父级容器根据指定名称和类型查找  
                return parentBeanFactory.getBean(nameToLookup, requiredType);
            }
        }
        //typeCheckOnly 默认是false，表示是否需要进行类型验证
        if (!typeCheckOnly) {
            // 这里用于标记该bean已经被创建，其实就是将beanName 放到一个专门用来标记 Bean 是否创建的map中
            markBeanAsCreated(beanName);
        }

        try {
            // 将GernericBeanDefinition 转换成 RootBeanDefinition，因为xml解析之后是GernericBeanDefinition，而后续处理是针对RootBeanDefinition
            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
            checkMergedBeanDefinition(mbd, beanName, args);

            // 获取当前Bean的依赖Bean，然后实例化依赖Bean，会递归调用
            String[] dependsOn = mbd.getDependsOn();
            if (dependsOn != null) {
                for (String dependsOnBean : dependsOn) {
                    if (isDependent(beanName, dependsOnBean)) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dependsOnBean + &amp;quot;&#39;&amp;quot;);
                    }
                    registerDependentBean(dependsOnBean, beanName);
                    getBean(dependsOnBean);
                }
            }

            // Create bean instance.
            if (mbd.isSingleton()) {
                sharedInstance = getSingleton(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
                   // 回调方法，创建Bean实例的逻辑就在这个方法中
                    @Override
                    public Object getObject() throws BeansException {
                        try {
                            //创建一个指定Bean实例对象，如果有父级继承，则合并子类和父类的定义
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
                            // 出错了就要从缓存中清除
                            destroySingleton(beanName);
                            throw ex;
                        }
                    }
                });
                // 获取给定Bean的实例对象，如果时FactoryBean需要特殊处理
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
            }

            // scorp 为 原型模式，每次请求都会创建一个
            else if (mbd.isPrototype()) {
                // It&#39;s a prototype -&amp;gt; create a new instance.
                Object prototypeInstance = null;
                try {
                    //回调beforePrototypeCreation方法，默认的功能是注册当前创建的原型对象  
                    beforePrototypeCreation(beanName);
                    //创建指定Bean对象实例 
                    prototypeInstance = createBean(beanName, mbd, args);
                }
                finally {
                    /回调afterPrototypeCreation方法，默认的功能告诉IoC容器指定Bean的原型对象不再创建了  
                    afterPrototypeCreation(beanName);
                }

                //如果是FactoryBean，特殊处理
                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
            }

            // scorp 为其它情况，例如 request session 
            else {
                String scopeName = mbd.getScope();
                final Scope scope = this.scopes.get(scopeName);
                if (scope == null) {
                    throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + scopeName + &amp;quot;&#39;&amp;quot;);
                }
                try {
                    Object scopedInstance = scope.get(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
                        @Override
                        public Object getObject() throws BeansException {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        }
                    });
                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                }
                catch (IllegalStateException ex) {
                    throw new BeanCreationException(beanName,
                            &amp;quot;Scope &#39;&amp;quot; + scopeName + &amp;quot;&#39; is not active for the current thread; consider &amp;quot; +
                            &amp;quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&amp;quot;,
                            ex);
                }
            }
        }
        catch (BeansException ex) {
            cleanupAfterBeanCreationFailure(beanName);
            throw ex;
        }
    }

    // 对创建的Bean实例对象进行类型检查 
    // Check if required type matches the type of the actual bean instance.
    if (requiredType != null &amp;amp;&amp;amp; bean != null &amp;amp;&amp;amp; !requiredType.isAssignableFrom(bean.getClass())) {
        try {
            return getTypeConverter().convertIfNecessary(bean, requiredType);
        }
        catch (TypeMismatchException ex) {
            if (logger.isDebugEnabled()) {
                logger.debug(&amp;quot;Failed to convert bean &#39;&amp;quot; + name + &amp;quot;&#39; to required type [&amp;quot; +
                        ClassUtils.getQualifiedName(requiredType) + &amp;quot;]&amp;quot;, ex);
            }
            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
        }
    }
    return (T) bean;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下主要是为了在必要时去除 &amp;amp; 前缀。我们知道，当我们通过factory.getBean(&amp;amp;+beanName) 方式获取一个Bean的时候，实际上获取的是beanFactory，而不是我们需要的那个bean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final String beanName = transformedBeanName(name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尝试根据beanName从map缓存中获取bean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object sharedInstance = getSingleton(beanName);

public Object getSingleton(String beanName) {
    return getSingleton(beanName, true);
}

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
Object singletonObject = this.singletonObjects.get(beanName);
if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
    synchronized (this.singletonObjects) {
        singletonObject = this.earlySingletonObjects.get(beanName);
        if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
            ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
            if (singletonFactory != null) {
                singletonObject = singletonFactory.getObject();
                this.earlySingletonObjects.put(beanName, singletonObject);
                this.singletonFactories.remove(beanName);
            }
        }
    }
}
return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就是一些判断，主要是处理当缓存中有bean的情况，创建新bean的时候，不走那些流程，所以直接到标记处。在开始创建bean实例之前，需要先标记一下，即将该beanName缓存到一个map中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;markBeanAsCreated(beanName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后就是创建依赖bean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String[] dependsOn = mbd.getDependsOn();
if (dependsOn != null) {
    for (String dependsOnBean : dependsOn) {
        if (isDependent(beanName, dependsOnBean)) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &amp;quot;Circular depends-on relationship between &#39;&amp;quot; + beanName + &amp;quot;&#39; and &#39;&amp;quot; + dependsOnBean + &amp;quot;&#39;&amp;quot;);
        }
        registerDependentBean(dependsOnBean, beanName);
        getBean(dependsOnBean);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果Bean是单例模式，就先从 this.singletonObjects 缓存中获取，缓存中有则直接返回，否则创建。在下面的这堆代码中，最核心的就是 singletonFactory.getObject() 这个方法了，创建Bean实例的逻辑在在这个方法中调用的，然后还有Bean的生命周期，需要重点关注一下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (mbd.isSingleton()) {
    sharedInstance = getSingleton(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
        @Override
        public Object getObject() throws BeansException {
            try {
                return createBean(beanName, mbd, args);
            }
            catch (BeansException ex) {
                // Explicitly remove instance from singleton cache: It might have been put there
                // eagerly by the creation process, to allow for circular reference resolution.
                // Also remove any beans that received a temporary reference to the bean.
                destroySingleton(beanName);
                throw ex;
            }
        }
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}

public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
    Assert.notNull(beanName, &amp;quot;&#39;beanName&#39; must not be null&amp;quot;);
    synchronized (this.singletonObjects) {
        // 先从缓存中获取
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            if (this.singletonsCurrentlyInDestruction) {
                throw new BeanCreationNotAllowedException(beanName,
                        &amp;quot;Singleton bean creation not allowed while the singletons of this factory are in destruction &amp;quot; +
                        &amp;quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&amp;quot;);
            }
            if (logger.isDebugEnabled()) {
                logger.debug(&amp;quot;Creating shared instance of singleton bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
            }

            // 将当前Bean设置为正在加载状态并放到缓存中，可以对循环依赖进行检查。inCreationCheckExclusions 里面应该是缓存了一些再创建Bean时需要排除的Bean？
            beforeSingletonCreation(beanName);

            boolean newSingleton = false;
            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
            if (recordSuppressedExceptions) {
                this.suppressedExceptions = new LinkedHashSet&amp;lt;Exception&amp;gt;();
            }
            try {

                // 回调方法，真正的实例化Bean逻辑。
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                // Has the singleton object implicitly appeared in the meantime -&amp;gt;
                // if yes, proceed with it since the exception indicates that state.
                singletonObject = this.singletonObjects.get(beanName);
                if (singletonObject == null) {
                    throw ex;
                }
            }
            catch (BeanCreationException ex) {
                if (recordSuppressedExceptions) {
                    for (Exception suppressedException : this.suppressedExceptions) {
                        ex.addRelatedCause(suppressedException);
                    }
                }
                throw ex;
            }
            finally {
                if (recordSuppressedExceptions) {
                    this.suppressedExceptions = null;
                }

                // Bean创建完成之后，将它的正在创建状态从缓存中移除
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                // 添加到缓存中
                addSingleton(beanName, singletonObject);
            }
        }

        return (singletonObject != NULL_OBJECT ? singletonObject : null);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Bean实例的操作就在getObject方法里面，可以看出这是一个回调方法，在这个方法内部，调用了 AbstractAutowireCapableBeanFactory 类的 createBean方法，在这方方法总，主要需要关注两个方法 resolveBeforeInstantiation 和 doCreateBean，前者是试图根据初始化前后处理器返回一个代理实例，后者即真正的创建实例逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {
    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
    }
    RootBeanDefinition mbdToUse = mbd;

    // Make sure bean class is actually resolved at this point, and
    // clone the bean definition in case of a dynamically resolved Class
    // which cannot be stored in the shared merged bean definition.
    // 锁定class，根据设置的class属性或者根据className来解析class  
    Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
    if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
        mbdToUse = new RootBeanDefinition(mbd);
        mbdToUse.setBeanClass(resolvedClass);
    }

    // Prepare method overrides.
    try {
        // 方法覆盖？具体不太清楚
        mbdToUse.prepareMethodOverrides();
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                beanName, &amp;quot;Validation of method overrides failed&amp;quot;, ex);
    }

    try {
        // 如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象，如果成功就直接返回了，下面的流程就不执行了。
        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        if (bean != null) {
            return bean;
        }
    }
    catch (Throwable ex) {
        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                &amp;quot;BeanPostProcessor before instantiation of bean failed&amp;quot;, ex);
    }

    // 创建Bean实例
    Object beanInstance = doCreateBean(beanName, mbdToUse, args);

    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Finished creating instance of bean &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
    }
    return beanInstance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于&lt;strong&gt;resolveBeforeInstantiation&lt;/strong&gt;这个方法，重点解释一下。方法体看起来很简单，如果Bean配置了初始化前和初始化后的处理器，则试图返回一个需要创建Bean的代理对象，如果成功就直接返回了，下面的流程就不执行了。我想了很久才明白到它这里说的代理是什么意思，这里确实要结合AOP这一块的内容。简单从方法体上来看，一个就是在实例化前调用InstantiationAwareBeanPostProcessor是实现类的postProcessBeforeInstantiation方法；在实例化后，调用BeanPostProcessor实现类的postProcessAfterInitialization方法，就相当于是给我们预留的两个修改Bean信息的入口，这是没有什么疑问的。但这里为什么要扯到什么代理呢？这是因为如果我们用了AOP的时候，是需要为一些Bean生成代理类类，resolveBeforeInstantiation方法中就想到了这种情况。因为如果需要为某个Bean生成代理对象的话，在调用BeanPostProcessor是实现类的postProcessAfterInitialization方法之后，代理类就已经生成了，而我们需要的就是代理对象，就没必要再执行下面的实例化、初始化的流程了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
    Object bean = null;
    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
        // Make sure bean class is actually resolved at this point.
        if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
            Class&amp;lt;?&amp;gt; targetType = determineTargetType(beanName, mbd);
            if (targetType != null) {
                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
                if (bean != null) {
                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
                }
            }
        }
        mbd.beforeInstantiationResolved = (bean != null);
    }
    return bean;
}

// 实例化前
protected Object applyBeanPostProcessorsBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName)
        throws BeansException {

    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);
            if (result != null) {
                return result;
            }
        }
    }
    return null;
}

// 实例化后 但是这个方法调用不是应该再初始化后吗，为什么在这里调用。可是如果不在这里调用，那就没办法为生成的代理对象处理了，不太懂
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
        throws BeansException {

    Object result = existingBean;
    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
        result = beanProcessor.postProcessAfterInitialization(result, beanName);
        if (result == null) {
            return result;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就是创建Bean实例的doCreateBean方法，里面又有很多的逻辑，分很多步骤，每个步骤都很繁琐。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
    // 实例化之前，将BeanDefinition转换为Wrapper
    // Instantiate the bean.
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 根据指定Bean使用对应的策略创建新的实例，如：构造函数、工厂方法、简单初始化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }

    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
    Class&amp;lt;?&amp;gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);

    // 允许 MergedBeanDefinitionPostProcessors 实现类修改 Bean 的定义信息,Bean合并后的处理
    // Allow post-processors to modify the merged bean definition.
    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            mbd.postProcessed = true;
        }
    }

    // 涉及到循环依赖，看不太懂
    // Eagerly cache singletons to be able to resolve circular references
    // even when triggered by lifecycle interfaces like BeanFactoryAware.
    boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
            isSingletonCurrentlyInCreation(beanName));
    if (earlySingletonExposure) {
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Eagerly caching bean &#39;&amp;quot; + beanName +
                    &amp;quot;&#39; to allow for resolving potential circular references&amp;quot;);
        }
        addSingletonFactory(beanName, new ObjectFactory&amp;lt;Object&amp;gt;() {
            @Override
            public Object getObject() throws BeansException {
                // 针对 SmartInstantiationAwareBeanPostProcessor 实现类，不太清楚想要干嘛
                return getEarlyBeanReference(beanName, mbd, bean);
            }
        });
    }

    // 准备初始化Bean了
    // Initialize the bean instance.
    Object exposedObject = bean;
    try {
        // 将各个属性值注入Bean中，可能存在依赖于其它Bean的属性，会递归调用
        populateBean(beanName, mbd, instanceWrapper);
        if (exposedObject != null) {

            // 调用初始化方法，比如 init-method
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
    }
    catch (Throwable ex) {
        if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
            throw (BeanCreationException) ex;
        }
        else {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Initialization of bean failed&amp;quot;, ex);
        }
    }

    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);

        // earlySingletonReference只有在检测到有循环依赖的情况下才会不为空
        if (earlySingletonReference != null) {
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            }
            else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;String&amp;gt;(dependentBeans.length);
                for (String dependentBean : dependentBeans) {
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }

                // actualDependentBeans 不为空表示当前的Bean创建后其依赖的Bean却没有创建完成，也就是说存在循环依赖
                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName,
                            &amp;quot;Bean with name &#39;&amp;quot; + beanName + &amp;quot;&#39; has been injected into other beans [&amp;quot; +
                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                            &amp;quot;] in its raw version as part of a circular reference, but has eventually been &amp;quot; +
                            &amp;quot;wrapped. This means that said other beans do not use the final version of the &amp;quot; +
                            &amp;quot;bean. This is often the result of over-eager type matching - consider using &amp;quot; +
                            &amp;quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&amp;quot;);
                }
            }
        }
    }

    // Register bean as disposable.
    try {
        // 注册 Bean销毁方法
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Invalid destruction signature&amp;quot;, ex);
    }

    return exposedObject;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在Spring中解决循环依赖对单例有效，而对于prototype的bean，Spring没有好的解决办法，唯一要做的就是抛出异常。假如A含有B的属性，B又含有A的属性，这就形成了一个循环依赖，此时如果A和B都是单例，那么在Spring中的处理方式就是在创建B的时候，涉及自动注入A的步骤时，并不是直接去再次创建A，而是通过放入缓存的ObjectFactory来创建实例，这样就解决了循环依赖的问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接下来看看createBeanInstance方法，这个方法里面很复杂，我就省略了一些代码,看看最关键实例化那个步骤的处理。首先判断BeanDefinition.getMethodOverrides()为空也就是用户没有使用replace或者lookup的配置方法，那么直接使用反射的技术;如果有配置这两个方法，就是用CGLIB进行动态代理，因为可以在创建代理的同时将动态方法织入代理类中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
    ......
    return instantiateBean(beanName, mbd);
    ......
}

protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    try {
        Object beanInstance;
        final BeanFactory parent = this;
        if (System.getSecurityManager() != null) {
            beanInstance = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
                @Override
                public Object run() {
                    return getInstantiationStrategy().instantiate(mbd, beanName, parent);
                }
            }, getAccessControlContext());
        }
        else {
            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
        }
        BeanWrapper bw = new BeanWrapperImpl(beanInstance);
        initBeanWrapper(bw);
        return bw;
    }
    catch (Throwable ex) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &amp;quot;Instantiation of bean failed&amp;quot;, ex);
    }
}

@Override
public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
    // Don&#39;t override the class with CGLIB if no overrides.
    if (bd.getMethodOverrides().isEmpty()) {
        Constructor&amp;lt;?&amp;gt; constructorToUse;
        synchronized (bd.constructorArgumentLock) {
            constructorToUse = (Constructor&amp;lt;?&amp;gt;) bd.resolvedConstructorOrFactoryMethod;
            if (constructorToUse == null) {
                final Class&amp;lt;?&amp;gt; clazz = bd.getBeanClass();
                if (clazz.isInterface()) {
                    throw new BeanInstantiationException(clazz, &amp;quot;Specified class is an interface&amp;quot;);
                }
                try {
                    if (System.getSecurityManager() != null) {
                        constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt;() {
                            @Override
                            public Constructor&amp;lt;?&amp;gt; run() throws Exception {
                                return clazz.getDeclaredConstructor((Class[]) null);
                            }
                        });
                    }
                    else {
                        constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);
                    }
                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                }
                catch (Throwable ex) {
                    throw new BeanInstantiationException(clazz, &amp;quot;No default constructor found&amp;quot;, ex);
                }
            }
        }
        return BeanUtils.instantiateClass(constructorToUse);
    }
    else {
        // Must generate CGLIB subclass.
        return instantiateWithMethodInjection(bd, beanName, owner);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于属性填充这一块内容就略过了，直接看初始化方法initializeBean吧&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
            @Override
            public Object run() {
                invokeAwareMethods(beanName, bean);
                return null;
            }
        }, getAccessControlContext());
    }
    else {
        // 对特殊Bean处理：Aware、BeanClassLoaderAware、BeanFactoryAware
        invokeAwareMethods(beanName, bean);
    }

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 初始化之前调用
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

    try {
        invokeInitMethods(beanName, wrappedBean, mbd);
    }
    catch (Throwable ex) {
        throw new BeanCreationException(
                (mbd != null ? mbd.getResourceDescription() : null),
                beanName, &amp;quot;Invocation of init method failed&amp;quot;, ex);
    }

    if (mbd == null || !mbd.isSynthetic()) {
        // 初始化之后调用
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
    return wrappedBean;
}

private void invokeAwareMethods(final String beanName, final Object bean) {
    if (bean instanceof Aware) {
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        if (bean instanceof BeanClassLoaderAware) {
            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
        }
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}

// 初始化之前，会调用所有BeanPostProcessor所有实现类的postProcessBeforeInitialization方法
public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
        throws BeansException {

    Object result = existingBean;
    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
        result = beanProcessor.postProcessBeforeInitialization(result, beanName);
        if (result == null) {
            return result;
        }
    }
    return result;
}

// 初始化之后，会调用所有BeanPostProcessor所有实现类的postProcessAfterInitialization方法
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
        throws BeansException {

    Object result = existingBean;
    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
        result = beanProcessor.postProcessAfterInitialization(result, beanName);
        if (result == null) {
            return result;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Spring中提供了一些Aware相关接口，比如BeanFacrotyAware、ApplicationContextAware、ResourceLoaderAware、ServletContextAware等，实现这些Aware接口的Bean在被初始化前可以获得一些资源，例如实现BeanFacrotyAware的Bean在初始化后，Spring容器会注入BeanFactory的实例。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后就是激活自定义init方法invokeInitMethods。客户定制的初始化方法除了我们熟知的init-method方法之外，还可以让Bean实现InitializingBean接口，并在afterPropertiesSet方法中实现自定义初始化逻辑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
        throws Throwable {

    // 先检查是否实现了InitializingBean接口，实现了就调用afterPropertiesSet方法      
    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean &amp;amp;&amp;amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&amp;quot;afterPropertiesSet&amp;quot;))) {
        if (logger.isDebugEnabled()) {
            logger.debug(&amp;quot;Invoking afterPropertiesSet() on bean with name &#39;&amp;quot; + beanName + &amp;quot;&#39;&amp;quot;);
        }
        if (System.getSecurityManager() != null) {
            try {
                AccessController.doPrivileged(new PrivilegedExceptionAction&amp;lt;Object&amp;gt;() {
                    @Override
                    public Object run() throws Exception {
                        ((InitializingBean) bean).afterPropertiesSet();
                        return null;
                    }
                }, getAccessControlContext());
            }
            catch (PrivilegedActionException pae) {
                throw pae.getException();
            }
        }
        else {
            ((InitializingBean) bean).afterPropertiesSet();
        }
    }

    if (mbd != null) {
        String initMethodName = mbd.getInitMethodName();
        if (initMethodName != null &amp;amp;&amp;amp; !(isInitializingBean &amp;amp;&amp;amp; &amp;quot;afterPropertiesSet&amp;quot;.equals(initMethodName)) &amp;amp;&amp;amp;
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            // 调用自定义初始化方法 就是 method.invoke(bean)
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;registerDisposableBeanIfNecessary用于 注册 Bean销毁方法。除了可以配置属性destory-method外，还可以通过实现DestructionAwareBeanpostprocessor接口来统一处理Bean的销毁方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
    AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
    if (!mbd.isPrototype() &amp;amp;&amp;amp; requiresDestruction(bean, mbd)) {
        if (mbd.isSingleton()) {
            // 单例模式下注册需要销毁的Bean，此方法中会处理实现DisposableBean接口的Bean，b并且对所有Bean使用 DestructionAwareBeanpostprocessor 是实现类 处理
            registerDisposableBean(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
        else {
            // A bean with a custom scope...
            Scope scope = this.scopes.get(mbd.getScope());
            if (scope == null) {
                throw new IllegalStateException(&amp;quot;No Scope registered for scope name &#39;&amp;quot; + mbd.getScope() + &amp;quot;&#39;&amp;quot;);
            }
            scope.registerDestructionCallback(beanName,
                    new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里，一个Bean身上该发生的基本上都介绍了，也包括Bean的生命周期，现在返回的Bean，就是我们能够正常使用的Bean了。&lt;/p&gt;

&lt;h1 id=&#34;applicationcontext流程&#34;&gt;ApplicationContext流程&lt;/h1&gt;

&lt;p&gt;前面有说到过，ApplicationContext是一个非常高级的接口，实现了非常多的接口，可以看看它的继承关系图，很庞大&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-50d4c71ec09c5097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;post_005&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这一大章节我们主要以ClassPathXmlApplicationContext为切入点，测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TestApplicationContext {
    public static void main(String[] args) {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;quot;config.xml&amp;quot;);

        Object o = applicationContext.getBean(&amp;quot;simpleMethodInterceptor&amp;quot;);
        System.out.println(o);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;入口&#34;&gt;入口&lt;/h3&gt;

&lt;p&gt;ClassPathXmlApplicationContext构造函数非常简单，为application contex设置好文件路径后，直接就调用了refresh方法，该方法中几乎包含了ApplicationContext中的所有功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
    this(new String[] {configLocation}, true, null);
}

public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
        throws BeansException {

    super(parent);
    setConfigLocations(configLocations);

    if (refresh) {
        // 容器初始化入口
        refresh();
    }
}

// 为application contex 设置配置文件路径
public void setConfigLocations(String... locations) {
    if (locations != null) {
        Assert.noNullElements(locations, &amp;quot;Config locations must not be null&amp;quot;);
        this.configLocations = new String[locations.length];
        for (int i = 0; i &amp;lt; locations.length; i++) {
            this.configLocations[i] = resolvePath(locations[i]).trim();
        }
    }
    else {
        this.configLocations = null;
    }
}


// 以下是抽象类的 AbstractApplicationContext 的方法
public AbstractApplicationContext(ApplicationContext parent) {
    this();
    setParent(parent);
}
public AbstractApplicationContext() {
    this.resourcePatternResolver = getResourcePatternResolver();
}
// 创建一个资源解析器？
protected ResourcePatternResolver getResourcePatternResolver() {
    return new PathMatchingResourcePatternResolver(this);
}

public void setParent(ApplicationContext parent) {
    this.parent = parent;
    if (parent != null) {
        Environment parentEnvironment = parent.getEnvironment();
        if (parentEnvironment instanceof ConfigurableEnvironment) {
            getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;refresh的默认实现在AbstractApplicationContext抽象类中，它是一个模板方法，refresh方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  
        prepareRefresh();

        // 初始化beanFactory，并读取解析XML配置文件
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 对BeanFactory各种填充，例如类加载器、事件处理器等
        prepareBeanFactory(beanFactory);

        try {
            // 子类覆盖方法做额外的处理
            postProcessBeanFactory(beanFactory);

            // 激活各种BeanFactory处理器
            invokeBeanFactoryPostProcessors(beanFactory);

            // 注册 拦截Bean创建的Beanc处理器，这里只是注册，起作用是在调用getBean方法的时候
            registerBeanPostProcessors(beanFactory);

            // 为上下文初始化Message源，即国际化处理
            initMessageSource();

            // 初始化消息广播器，并插入 &#39;applicationEventMulticaster&amp;quot; Bean中
            initApplicationEventMulticaster();

            // 留给子类来初始化其它的Bean
            onRefresh();

            // 在注册的Bean中查找Listener Bean，注册到消息广播中
            registerListeners();

            // 初始化剩下的单实例(非惰性)
            finishBeanFactoryInitialization(beanFactory);

            // 完成刷新过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发布ContextRefreshEvent通知别人
            finishRefresh();
        }

        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn(&amp;quot;Exception encountered during context initialization - &amp;quot; +
                        &amp;quot;cancelling refresh attempt: &amp;quot; + ex);
            }

            // 销毁以创建的单态Bean
            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();

            // 取消refresh操作，重置容器的同步标识
            // Reset &#39;active&#39; flag.
            cancelRefresh(ex);

            // Propagate exception to caller.
            throw ex;
        }

        finally {
            // 重置Spring 的常见核心缓存
            // Reset common introspection caches in Spring&#39;s core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;obtainfreshbeanfactory&#34;&gt;obtainFreshBeanFactory&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // 初始化BeanFactory，并进行xml文件读取解析，并将得到的BeanFactory记录在当前实体的属性中
    refreshBeanFactory();

    // 返回当前实体的 BeanFactory 属性
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (logger.isDebugEnabled()) {
        logger.debug(&amp;quot;Bean factory for &amp;quot; + getDisplayName() + &amp;quot;: &amp;quot; + beanFactory);
    }
    return beanFactory;
}


// AbstractRefreshableApplicationContext # refreshBeanFactory
protected final void refreshBeanFactory() throws BeansException {

    // 如果beanFactory 存在，就先销毁，然后再重新创建
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 创建 DefaultListableBeanFactory
        DefaultListableBeanFactory beanFactory = createBeanFactory();

        // 为序列号指定id
        beanFactory.setSerializationId(getId());

        //定制BeanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖，以及设置@Autowired 、 @Qualifier 注解解析器 QualifierAnnotationAutowireCandidateResolver
        customizeBeanFactory(beanFactory);

        // 初始化DocumentReader，并进行XML文件读取解析
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException(&amp;quot;I/O error parsing bean definition source for &amp;quot; + getDisplayName(), ex);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AbstractXmlApplicationContext # loadBeanDefinitions&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    // 老面孔
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    // Configure the bean definition reader with this context&#39;s
    // resource loading environment.
    beanDefinitionReader.setEnvironment(this.getEnvironment());
    beanDefinitionReader.setResourceLoader(this);
    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

    // 这是设置啥？可以覆盖
    // Allow a subclass to provide custom initialization of the reader,
    // then proceed with actually loading the bean definitions.
    initBeanDefinitionReader(beanDefinitionReader);


    loadBeanDefinitions(beanDefinitionReader);

protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    Resource[] configResources = getConfigResources();
    if (configResources != null) {
        reader.loadBeanDefinitions(configResources);
    }
    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        reader.loadBeanDefinitions(configLocations);
    }
}

public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException {
    Assert.notNull(resources, &amp;quot;Resource array must not be null&amp;quot;);
    int counter = 0;
    for (Resource resource : resources) {
        counter += loadBeanDefinitions(resource);
    }
    return counter;
}

// 到这里就完全和我们上面介绍的 Bean解析一模一样了
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
    return loadBeanDefinitions(new EncodedResource(resource));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先消化一下，以后再写吧，待续。。。&lt;/p&gt;

&lt;p&gt;有很多很多内容都是直接跳过的，可以看到Spring对Bean处理这一块真的是太复杂了，不过主要的流程也基本上清楚了，也许看第二遍的似乎就会舒服很多了。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://www.spilledyear.cn/post/jvm/</link>
      <pubDate>Sun, 22 Jul 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/jvm/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/297.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;类加载机制&#34;&gt;类加载机制&lt;/h1&gt;

&lt;p&gt;一般来说，Java虚拟机使用Java类的方式如下：.java 文件在经过 Java 编译器编译之后就被转换成 .class 文件。类加载器负责读取Java字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。流程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/JVM/post_002.png&#34; alt=&#34;post_002&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;加载&#34;&gt;加载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件格式的验证
主要验证字节流是否符合Class文件格式的规范，如果符合则把字节流加载到方法区中进行存储。文件头、主次版本验证等等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;元数据验证
主要对字节码描述的信息进行语义分析，保证其描述符合Java语言的要求。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字节码验证
最复杂的一个阶段。主要目的是通过数据量和控制流分析，确定程序语义是合法的，符合逻辑的。保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;

&lt;p&gt;准备阶段正式为类变量分配内存并设置初始值阶段。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static int value=123; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上语句，value初始值为0。只有在初始化阶段才会给 value 初始化为 23&lt;/p&gt;

&lt;p&gt;对于static final类型，在准备阶段会被赋予正确的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static final value=123;v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上语句，value初始值为123。&lt;/p&gt;

&lt;p&gt;如果是boolean值默认赋值为：false。
如果是对象引用默认赋值为：null。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，此阶段只设置类中的静态变量(方法区中)，不包括实例变量(堆内存中)，实例变量是在对象实例化的时候初始化分配值的&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;解析&#34;&gt;解析&lt;/h3&gt;

&lt;p&gt;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
- 符号引用：简单的理解就是字符串，比如引用一个类，java.util.ArrayList 这就是一个符号引用，字符串引用的对象不一定被加载。
- 直接引用：指针或者地址偏移量。引用对象一定在内存(已经加载)&lt;/p&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;1、执行类构造器&lt;clinit&gt;
2、初始化静态变量、静态块中的数据等(一个类加载器只会初始化一次)
3、子类的&lt;clinit&gt;调用前保证父类的&lt;clinit&gt;被调用&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;clinit&gt;是线程安全的，执行&lt;clinit&gt;的线程需要先获取锁才能进行初始化操作，保证只有一个线程能执行&lt;clinit&gt;(利用此特性可以实现线程安全的懒汉单例模式)。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;jvm中的类加载器&#34;&gt;JVM中的类加载器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动类加载器(BootStrap ClassLoader)：引导类装入器是用本地代码实现的类装入器，它负责将 jdk中jre/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;扩展类加载器(Extension ClassLoader)：扩展类加载器是由Sun的ExtClassLoader(sun.misc.Launcher$ExtClassLoader)实现的。它负责将jdk中jre/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;系统类加载器(System ClassLoader)：系统类加载器是由Sun的AppClassLoader(sun.misc.Launcher$AppClassLoader)实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;加载的时候使用双亲委派机制：如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。&lt;/p&gt;

&lt;h6 id=&#34;classloader加载class文件方式&#34;&gt;ClassLoader加载Class文件方式：&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;从本地系统中直接加载&lt;/li&gt;
&lt;li&gt;通过网络下载.class文件&lt;/li&gt;
&lt;li&gt;从zip，jar等归档文件中加载.class文件&lt;/li&gt;
&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;
&lt;li&gt;将Java源文件动态编译为.class文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;垃圾回收&#34;&gt;垃圾回收&lt;/h1&gt;

&lt;p&gt;常见的垃圾回收算法有&lt;/p&gt;

&lt;h3 id=&#34;引用计数法&#34;&gt;引用计数法&lt;/h3&gt;

&lt;p&gt;引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1(a = b,则b引用的对象实例的计数器+1)，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。&lt;/p&gt;

&lt;p&gt;缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。&lt;/p&gt;

&lt;h3 id=&#34;标记清除算法&#34;&gt;标记清除算法&lt;/h3&gt;

&lt;p&gt;标记清除算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。Java中可作为GC Root的对象有：
1、虚拟机栈中引用的对象（本地变量表）
2、方法区中静态属性引用的对象
3、方法区中常量引用的对象
4、本地方法栈中引用的对象(Native对象)&lt;/p&gt;

&lt;p&gt;标记-清除算法的主要不足有两个：
- 效率问题：标记和清除两个过程的效率都不高。
- 空间问题：标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;

&lt;h3 id=&#34;复制算法&#34;&gt;复制算法&lt;/h3&gt;

&lt;p&gt;复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。&lt;/p&gt;

&lt;p&gt;事实上，现在商用的虚拟机都采用这种算法来回收新生代。因为研究发现，新生代中的对象每次回收都基本上只有10%左右的对象存活，所以需要复制的对象很少，效率还不错。实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 (如下图所示)，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% (80%+10%)，只有10% 的内存会被“浪费”。&lt;/p&gt;

&lt;h3 id=&#34;标记整理算法&#34;&gt;标记整理算法&lt;/h3&gt;

&lt;p&gt;复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景(老年代)。&lt;/p&gt;

&lt;h3 id=&#34;分代收集算法&#34;&gt;分代收集算法&lt;/h3&gt;

&lt;p&gt;对于一个大型的系统，当创建的对象和方法变量比较多时，堆内存中的对象也会比较多，如果逐一分析对象是否该回收，那么势必造成效率低下。分代收集算法是基于这样一个事实：不同的对象的生命周期(存活情况)是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。当代商用虚拟机使用的都是分代收集算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法。Java堆内存一般可以分为新生代、老年代和永久代三个模块。&lt;/p&gt;

&lt;p&gt;Java堆内存一般可以分为新生代、老年代和永久代三个模块&lt;/p&gt;

&lt;h3 id=&#34;新生代&#34;&gt;新生代&lt;/h3&gt;

&lt;p&gt;新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色(即下次垃圾回收时会扫描Eden区和survivor1区)，即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。&lt;/p&gt;

&lt;h3 id=&#34;老年代&#34;&gt;老年代&lt;/h3&gt;

&lt;p&gt;老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是2:1)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。&lt;/p&gt;

&lt;h3 id=&#34;永久代&#34;&gt;永久代&lt;/h3&gt;

&lt;p&gt;永久代主要用于存放静态文件，如Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。&lt;/p&gt;

&lt;h3 id=&#34;垃圾收集器&#34;&gt;垃圾收集器&lt;/h3&gt;

&lt;p&gt;如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。以下7种作用于不同分代的收集器，其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge，回收老年代的收集器包括Serial Old、Parallel Old、CMS，还有用于回收整个Java堆的G1收集器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;内存分配与回收策略&#34;&gt;内存分配与回收策略&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对象优先在Eden分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;大对象直接进入老年代&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;长期存活的对象将进入老年代
当对象在新生代中经历过一定次数（默认为15）的Minor GC后，就会被晋升到老年代中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态对象年龄判定
为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;jmm&#34;&gt;JMM&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/javazejian/article/details/72772461&#34;&gt;Java内存模型&lt;/a&gt; (即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图&lt;/p&gt;

&lt;p&gt;需要注意的是，JMM与Java内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开的(稍后会分析)。JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。或许在某些地方，我们可能会看见主内存被描述为堆内存，工作内存被称为线程栈，实际上他们表达的都是同一个含义。关于JMM中的主内存和工作内存说明如下&lt;/p&gt;

&lt;h3 id=&#34;主内存&#34;&gt;主内存&lt;/h3&gt;

&lt;p&gt;主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。&lt;/p&gt;

&lt;h3 id=&#34;工作内存&#34;&gt;工作内存&lt;/h3&gt;

&lt;p&gt;主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。&lt;/p&gt;

&lt;p&gt;弄清楚主内存和工作内存后，接了解一下主内存与工作内存的数据存储类型以及操作方式，根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存，简单示意图如下所示：&lt;/p&gt;

&lt;h3 id=&#34;jmm的承诺&#34;&gt;JMM的承诺&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性
原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。有点要注意的是，对于32位系统的来说，long类型数据和double类型数据(对于基本数据类型，byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可见性
理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。【volatile】&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有序性
有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。【volatile】&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;重排序&#34;&gt;重排序&lt;/h3&gt;

&lt;h3 id=&#34;as-if-serial-语义&#34;&gt;as-if-serial 语义&lt;/h3&gt;

&lt;p&gt;as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。&lt;/p&gt;

&lt;h3 id=&#34;happens-before&#34;&gt;happens- before&lt;/h3&gt;

&lt;h1 id=&#34;java内存区域&#34;&gt;Java内存区域&lt;/h1&gt;

&lt;p&gt;Java虚拟机在运行程序时会把其自动管理的内存划分为以上几个区域，每个区域都有其用途以及创建销毁的时机。&lt;/p&gt;

&lt;h3 id=&#34;方法区-method-area&#34;&gt;方法区(Method Area)&lt;/h3&gt;

&lt;p&gt;方法区属于线程共享的内存区域，又称Non-Heap(非堆)，主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，这些内容将在类加载后存放到运行时常量池中，以便后续使用。(共享)
&lt;strong&gt;虚拟机加载的类信息、常量、静态变量、常量池&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;jvm堆-java-heap&#34;&gt;JVM堆(Java Heap)&lt;/h3&gt;

&lt;p&gt;Java 堆也是属于线程共享的内存区域，它在虚拟机启动时创建，是Java 虚拟机所管理的内存中最大的一块，主要用于存放对象实例，几乎所有的对象实例都在这里分配内存，注意Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC堆，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。(共享)&lt;/p&gt;

&lt;h3 id=&#34;程序计数器-program-counter-register&#34;&gt;程序计数器(Program Counter Register)&lt;/h3&gt;

&lt;p&gt;属于线程私有的数据区域，是一小块内存空间，主要代表当前线程所执行的字节码行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。&lt;/p&gt;

&lt;h3 id=&#34;虚拟机栈-java-virtual-machine-stacks&#34;&gt;虚拟机栈(Java Virtual Machine Stacks)&lt;/h3&gt;

&lt;p&gt;属于线程私有的数据区域，与线程同时创建，总数与线程关联，代表Java方法执行的内存模型。每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程&lt;/p&gt;

&lt;h3 id=&#34;本地方法栈-native-method-stacks&#34;&gt;本地方法栈(Native Method Stacks)&lt;/h3&gt;

&lt;p&gt;本地方法栈属于线程私有的数据区域，这部分主要与虚拟机用到的 Native 方法相关，一般情况下，我们无需关心此区域。&lt;/p&gt;

&lt;h3 id=&#34;class常量池-todo&#34;&gt;class常量池 todo&lt;/h3&gt;

&lt;p&gt;在Class文件结构中，最头的4个字节用于存储魔数Magic Number，用于确定一个文件是否能被JVM接受；再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号；再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。
常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：
- 类和接口的全限定名
- 字段名称和描述符
- 方法名称和描述符&lt;/p&gt;

&lt;h3 id=&#34;方法区常量池-todo&#34;&gt;方法区常量池  todo&lt;/h3&gt;

&lt;p&gt;class中的常量池将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。&lt;/p&gt;

&lt;p&gt;运行时常量池是把Class文件常量池加载进来，每个类有一个独立的。刚开始运行时常量池里的链接都是符号链接，跟在Class文件里一样；边运行边就会把用到的常量转换成直接链接，例如说要Class A调用Foo.bar()方法，A.class文件里就会有对该方法的Methodref常量，是个符号链接（只有名字没有实体），加载到运行时常量池也还是一样是符号链接，等真的要调用该方法的时候该常量就会被resolve为一个直接链接(直接指向要调用的方法的实体)。&lt;/p&gt;

&lt;p&gt;又听说常量池在Java堆啊，怎么回事？&lt;/p&gt;

&lt;h3 id=&#34;搞不清楚的string-todo&#34;&gt;搞不清楚的String todo&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String a = &amp;quot;我在哪&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找了很多博客，看了很多文章，还是没搞懂。上面这行代码，到底代表了什么？
我能够理解的是：在栈中创建了一个引用变量a，它占有4个字节，它在内存中对应一个地址，我们暂且把这个地址叫做x001，现在不明白的的x001这个地址的对应的内存空间中，到底存了什么？是存了真实值 &amp;ldquo;我在哪&amp;rdquo;？还是又存了一个地址x002，然后 x002对应的内存空间中 才是存了真实值 &amp;ldquo;我在哪&amp;rdquo;？&lt;/p&gt;

&lt;p&gt;查了一些资料，觉得 x001对应的内存空间 里面 存的应该是 x002这个地址，然后 x002对应的内存空间里面存了真实值 &amp;ldquo;我在哪&amp;rdquo;。因为String 不是基本类型啊，不是基本类型那就是引用类型咯，引用类型不就是要new 出来吗？new 的时候不就会返回一个引用吗？所以，是不是可以这样理解：在执行 String a = &amp;ldquo;我在哪&amp;rdquo;; 的时候，jvm 在堆中自动 new 了一个String 变量， String o = new String(&amp;ldquo;我在哪&amp;rdquo;); o 在内存中对应的地址是 x111，x111对应的地址空间存的是 x002, x002对应的地址空间里面 寸的是 &amp;ldquo;我在哪&amp;rdquo;，然后新建一个引用变量a，然后在a对应的内存空间存 o 的地址，即 x111？瞎扯把，应该不是这样吧？如果这样不是得  x111 &amp;ndash;&amp;gt; x002 才能找到值？
不过又有点像，假如现在又一条语句 String b = &amp;ldquo;我在哪&amp;rdquo;；这时候根据 &amp;ldquo;我在哪&amp;rdquo; 找到了 o, 然后将o赋值给b。只是因为new 出来的那个 o 没有被回收，所以叫做常量池吗？&lt;/p&gt;

&lt;p&gt;如果上面的代码换成这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int a = 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个应该比较好理解：在栈中创建了一个变量a，a对应得存储空间内 存放的值是1000。这就是所谓的基础类型，a指向的是 字面值对应的真实地址。&lt;/p&gt;

&lt;p&gt;不管啦不管啦，还是自己看书吧，先把疑问抛在这里 。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只要使用new方法，就会在堆中创建新对象，返回一个4字节的引用，该引用的内存空间内 存放的是一个地址，那个地址指向真正在堆中new出来的那个实例。&lt;/li&gt;
&lt;li&gt;只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String str1 = &amp;quot;str&amp;quot;;
String str2 = &amp;quot;ing&amp;quot;;

String str3 = &amp;quot;str&amp;quot; + &amp;quot;ing&amp;quot;;
String str4 = str1 + str2;
System.out.println(str3 == str4);//false

String str5 = &amp;quot;string&amp;quot;;
System.out.println(str3 == str5);//true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。
String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    String s1 = new String(&amp;quot;计算机&amp;quot;);
    String s2 = s1.intern();
    String s3 = &amp;quot;计算机&amp;quot;;
    System.out.println(&amp;quot;s1 == s2? &amp;quot; + (s1 == s2));
    System.out.println(&amp;quot;s3 == s2? &amp;quot; + (s3 == s2));
}
s1 == s2? false
s3 == s2? true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;不过，那个常量池到底在内存中是什么样的啊？常量池到底在哪个位置呢？堆里面一个独立的内存空间吗？String a = &amp;ldquo;666&amp;rdquo;; 在执行这行代码的时候，先去常量池里面找 &amp;ldquo;666&amp;rdquo;，如果没找到，就在堆中new 一个String 对象， 同时将 &amp;ldquo;666&amp;rdquo; 维护到常量池中吗？ 那这样不就相当于有两份了吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。
java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。&lt;/p&gt;

&lt;p&gt;什么是常量? 常量是用final修饰的成员变量!常量在类编译时期载入类的常量池中。即final修饰的成员变量（实例变量）和静态变量（静态变量也只能是用static修饰的成员变量），那么用final修饰的局部变量(方法内)，我们也可以称之为不可变变量(存储在栈中)。
Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池：
- 静态常量池 ：*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间(编译时期)。
- 运行时常量池 ：jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池(运行时期)。运行时常量池中的常量，基本来源于各个class文件中的常量池(即每个class文件都有对应的常量池)&lt;/p&gt;

&lt;h3 id=&#34;双等号-的含义&#34;&gt;双等号==的含义&lt;/h3&gt;

&lt;p&gt;基本数据类型之间应用双等号，比较的是他们的数值。
复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。&lt;/p&gt;

&lt;h3 id=&#34;包装类型&#34;&gt;包装类型&lt;/h3&gt;

&lt;p&gt;同时，Java中基本类型的包装类的大部分都实现了常量池技术：Byte，Short，Integer，Long，Character，Boolean
这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//Integer 缓存代码 ：
public static Integer valueOf(int i) {
    assert IntegerCache.high &amp;gt;= 127;
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}


// 示例
Integer i1 = 40;
Integer i2 = 40;
System.out.println(i1==i2);//输出TRUE


Integer i1 = 400;
Integer i2 = 400;
System.out.println(i1==i2);//输出false
- Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。
- Integer i1 = new Integer(40);这种情况下会创建新的对象。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是更丰富的示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

System.out.println(&amp;quot;i1=i2   &amp;quot; + (i1 == i2));
System.out.println(&amp;quot;i1=i2+i3   &amp;quot; + (i1 == i2 + i3));
System.out.println(&amp;quot;i1=i4   &amp;quot; + (i1 == i4));
System.out.println(&amp;quot;i4=i5   &amp;quot; + (i4 == i5));
System.out.println(&amp;quot;i4=i5+i6   &amp;quot; + (i4 == i5 + i6));   
System.out.println(&amp;quot;40=i5+i6   &amp;quot; + (40 == i5 + i6));


i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。&lt;/p&gt;

&lt;p&gt;两种浮点数类型的包装类Float,Double并没有实现常量池技术&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Double i1=1.2;
Double i2=1.2;
System.out.println(i1==i2);//输出false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;final&#34;&gt;final&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当final修饰类
final修饰类，更多从设计（Design）的角度去考虑吧，一个被final修饰的类无法子类化，即不能被继承。并且，final修饰类，类中的方法默认都是final 修饰的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当final修饰在方法上
对于Java虚拟机来说编译器在编译期间会自动进行内联优化，这是由编译器决定的，对于我们开发人员来说，我们一定要设计好break-even的平衡，不要滥用final。内联就相当于是优化，是一种替换，消除了更多方法的调用，以空间换时间的优化，例如：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化前的原始代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static class Car {
    double price;
    final double getPrice() {
        return price;
    }
}

public void countDiscount() {
    y = car.getPrice();
    // ...
    z = car.getPrice();
    discount = y - z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内联后的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void countDiscount() {
    y = car.price;
    // ...
    z = car.price;
    discount = y - z;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;final修饰静态变量
当我们用final来修饰一个基本数据类型的时候，一般有以下两种情况：&lt;/li&gt;
&lt;li&gt;程序编译期间的常量，它永远不会变。&lt;/li&gt;
&lt;li&gt;在运行期间为一个final修饰的域初始化一个值，不希望它会发生变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在编译后得到的.class文件中，有这么一块内容，叫常量池。那么一个类中被final修饰的域在这个时候就会被放入这个大池子中。至于为什么这么做？原因很简单，为了效率。
一个编译期间的类文件中，常量池中的基本数据类型的常量是不知道具体的值是什么，换句话说，在文件编译过后，虽然知道一个域是常量，但是至于这个常量的具体内容是什么，此时是无从知晓的，只有当运行时，常量才会真正的被赋值。
对于static和没有static修饰的基本数据类型来说，是有差异的，差异就在于static修饰的域是在类载入的时候进行初始化的，所有实例共享同一个常量，同时Java虚拟机没有把它当作类变量，在使用它的任何类的常量池或者字节码流中直接存放的是它表示的常量值。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Proxy</title>
      <link>https://www.spilledyear.cn/post/proxy/</link>
      <pubDate>Thu, 05 Jul 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/proxy/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/298.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍代理在Java中的应用，代理包括两种：静态代理 和 动态代理，其中动态代理又分为 JDK动态代理和 CGLIB动态代理。为什么要学习Java代理，因为它是很多框架的基础，理解了它，在阅读其它框架源码的时候，才会更得心应手。&lt;/p&gt;

&lt;h1 id=&#34;代理概念&#34;&gt;代理概念&lt;/h1&gt;

&lt;h1 id=&#34;反射机制&#34;&gt;反射机制&lt;/h1&gt;

&lt;p&gt;要理解java中的反射机制，需要理解java中的Class对象，它包含了与类有关的信息，事实Class对象就是用来创建类的所有“常规对象”的。类是程序的一部分，每个类都有一个Class对象。换而言之，每当编写并且编译一个新类时，就会产生一个Class对象(更恰当的说，是保存在一个同名的.class文件中)，为了生成这个类的对象，运行这个程序的java虚拟机将使用被称为“类加载器”的子系统。
Class的使用也和其他对象一样，我们可以获取并操作它的引用。其中有一个forName()静态方法，可以返回一个Class对象的引用：Class.forName(全类名)，通过该返回的Class对象引用，你可以做很多事情。例如：有一个类A , 通过 Class clazz = Class.forName(“A”)，你拿到了A对应的class对象 clazz，然后通过clazz可以做很多事情，比如，实创建一个A实例，或者是得到A的接口，方法等类信息。下面演示一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class ToyTest {
    public static void main(String[] args) throws Exception{
        Class c = null;
        c = Class.forName(&amp;quot;com.sxy.reflect.FancyToy&amp;quot;);
        printInfo(c);

        for(Class face : c.getInterfaces())
            printInfo(face);

        Class up = c.getSuperclass();
        Object obj = up.newInstance( );
        printInfo(obj.getClass());
    }

    static void printInfo(Class cc){
        System.out.println(&amp;quot;className &amp;quot; + cc.getName() + &amp;quot; is interface? [ &amp;quot; + cc.isInterface() + &amp;quot; ]&amp;quot;);
        System.out.println(&amp;quot;simpleName &amp;quot; + cc.getSimpleName());
        System.out.println(&amp;quot;CanonicalName &amp;quot; + cc.getCanonicalName());
    }
}

interface HasBatteries{}
interface Waterproof{}
interface  Shoots{}

class Toy{
    Toy(){}
    Toy(int i){}
}

class FancyToy extends Toy implements HasBatteries, Waterproof, Shoots{
    FancyToy(){ super(1);}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-53266bdea7814417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其实，反射机制也并没有什么神奇之处，我们普通的调用，是在编译的时候打开和检查.class文件，但是，对于反射而言，.class文件在编译时是不可获取的，所以在运行时打开和运行.class文件。&lt;/p&gt;

&lt;h1 id=&#34;静态代理&#34;&gt;静态代理&lt;/h1&gt;

&lt;p&gt;静态代理比较简单，大体的流程如下：
1)  定义目标接口。
2)  实现目标类接口。
3)  定义代理类，实现目标接口，目标类接口作为其私有属性。
4)  基本完成，新建一个测试类就可以了。&lt;/p&gt;

&lt;p&gt;下面用代码演示一遍静态代理的实现过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Learn {
    void learnEnglish();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class LearnImpl implements Learn{
    @Override
    public void learnEnglish() {
        System.out.println(&amp;quot; learn english&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class LearnProxy implements Learn{
    private Learn target;

    public LearnProxy(Learn target){
        this.target = target;
    }

    @Override
    public void learnEnglish() {
        System.out.println(&amp;quot;执行目标方法之前&amp;quot;);
        target.learnEnglish();
        System.out.println(&amp;quot;执行目标方法之后&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class TestProxy {

    public static void main(String[] args){
        LearnImpl target = new LearnImpl();
        LearnProxy proxy = new LearnProxy(target);
        proxy.learnEnglish();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-a48a639a3936860b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;静态感觉更像是一种单纯的设计模式，用任何语言都可以达到这样的效果。优点就是在不修改目标对象的时候，完成了对目标对象的扩展，但是缺点也非常那个明显，代理类需要实现目标对象一样的接口，因此不便于维护。&lt;/p&gt;

&lt;h1 id=&#34;jdk原生动态代理&#34;&gt;JDK原生动态代理&lt;/h1&gt;

&lt;p&gt;Java中实现动态代理有两种方法，一种是JDK提供的原生动态代理；还有一种是CGLIB动态代理。动态代理比静态代理的思想更进一步，因为他可以动态的创建代理并且动态的处理对所代理方法的调用。就比如上提到的静态代理，如果要代理的类太多，那么代理类的代码量是十分庞大的，很多重复的代码。动态代理就是为了解决这个问题的。
直接演示一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Learn {

    void learnEnglish();

    void learnChinese();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class LearnImpl implements Learn{


    public void learnEnglish() {
        System.out.print(&amp;quot;I want to learn English&amp;quot;);
    }

    public void learnChinese() {
        System.out.print(&amp;quot;I want to learn Chinese&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class LogInvocationHandler implements InvocationHandler {

    /**
     * the target that we want to be proxy
     */
    private Learn target;

    public LogInvocationHandler(Learn target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&amp;quot;执行代理方法之前&amp;quot;);

        method.invoke(target, args);

        System.out.println(&amp;quot;执行代理方法之后&amp;quot;);
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class JDKProxyTest {
    public static void main(String[] args) {
        // 允许生成代理类的class文件
        System.getProperties().put(&amp;quot;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;quot;, &amp;quot;true&amp;quot;);

        Learn learnReal = new LearnImpl();

        InvocationHandler handler = new LogInvocationHandler(learnReal);

        Learn learn = (Learn) Proxy.newProxyInstance(
                learnReal.getClass().getClassLoader(),
                learnReal.getClass().getInterfaces(),
                handler);

        System.out.println(learn.getClass().getName());

        learn.learnChinese();

//        Class clazzProxy = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class);
//        System.out.println(clazzProxy);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里主要介绍 Proxy.newProxyinstance() 方法，这是JDK中为我们提供的API，可以动态的创建代理。这个方法需要传递3个参数，第一个是代理对象的类加载器（通常可以从已经被加载过的对象中获取其类加载器，然后传递给它），第二个是代理对象需要实现的接口，可以同时指定多个接口；第三个方法调用的实际处理者，代理对象的方法调用都会转发到这里，这是一个方法委托类，我们通过代理调用被代理类的方法时，就可以将方法名和方法参数都委托给这个委托类。执行结果如下：&lt;br /&gt;
&amp;gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-caf23a7a6b6a7298.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从上图中可以看到，代理已经生效了？那么，它究竟是如何实现动态代理的呢？动态代理的流程是什么？我们关注最核心的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Learn learnReal = new LearnImpl();

        InvocationHandler handler = new LogInvocationHandler(learnReal);

        Learn learn = (Learn) Proxy.newProxyInstance(
                learnReal.getClass().getClassLoader(),
                learnReal.getClass().getInterfaces(),
                handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先是 InvocationHandler ， 这是个啥东西？其源码如下，只有一个invoke方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package java.lang.reflect;

public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有关于这个接口的解释如下：
&amp;gt;InvocationHandler is the interface implemented by  the invocation handler of a proxy instance.
Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.&lt;/p&gt;

&lt;p&gt;哎哟喂，这这这啥意思？先换成国语看看吧：
&amp;gt;InvocationHandler是由代理实例的调用处理程序实现的接口。每个代理实例都有一个关联的调用处理程序。当在代理实例上调用方法时，方法调用将被编码并分派给其调用处理程序的invoke方法。&lt;/p&gt;

&lt;p&gt;额，好像还是不太好理解哦。不过其中有两个名词：proxy instance、invocation handler。
- proxy instance：在代码中没有直观的表现，可以代表以下语句的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Learn)Proxy.newProxyInstance(learnReal.getClass().getClassLoader(), learnReal.getClass().getInterfaces(),handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不纠结了，至于它到底返回的是什么，接下来会介绍。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;invocation handler：InvocationHandler 接口的实现类，即代码中的 LogInvocationHandler，并且和 proxy instance 相关联。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结一下大概的意思就是：当我们通过代理实例调用方法时，实际上调用的是LogInvocationHandler的invoke方法。正常理解下也肯定是这样的，因为我们得日志就是织入在 invoke 方法里面的，肯定是内部通过什么花里胡哨得手法调用了invoke方法。&lt;/p&gt;

&lt;p&gt;那么，它究竟是如何花里胡哨的调用了 invoke 方法呢？
回到刚刚的问题上来，proxy instance ，上面说了它是如下语句的返回值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Learn learn = (Learn) Proxy.newProxyInstance(
                learnReal.getClass().getClassLoader(),
                learnReal.getClass().getInterfaces(),
                handler);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Proxy.newProxyInstance 方法我们知道它是 通过拼接字节码的方式来创建代理类 就可以了，不能再深入了，要不然没玩没了。
观察我们打印的一条日志，我们打印返回值的 全类名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.out.println(learn.getClass().getName());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现得到的是这么一个玩意，这是啥？这就是动态创建得代理实例
&amp;gt;com.sun.proxy.$Proxy0&lt;/p&gt;

&lt;p&gt;为了得到 com.sun.proxy.$Proxy0 得全貌，在 我们得代码中添加这么一句，这样就可以看到 对应得class 文件了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;System.getProperties().put(&amp;quot;sun.misc.ProxyGenerator.saveGeneratedFiles&amp;quot;, &amp;quot;true&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-b63a2f3b6464b2bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再次运行程序，发现生成了这个文件
&amp;gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-23bfc329f032cc81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.sun.proxy;

import com.hand.hsp.proxy.Learn;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Learn {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m4;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  {
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void learnEnglish() throws  {
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void learnChinese() throws  {
        try {
            super.h.invoke(this, m4, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {
        try {
            m1 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;equals&amp;quot;, Class.forName(&amp;quot;java.lang.Object&amp;quot;));
            m2 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;toString&amp;quot;);
            m3 = Class.forName(&amp;quot;com.hand.hsp.proxy.Learn&amp;quot;).getMethod(&amp;quot;learnEnglish&amp;quot;);
            m4 = Class.forName(&amp;quot;com.hand.hsp.proxy.Learn&amp;quot;).getMethod(&amp;quot;learnChinese&amp;quot;);
            m0 = Class.forName(&amp;quot;java.lang.Object&amp;quot;).getMethod(&amp;quot;hashCode&amp;quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察其中的 learnChinese 方法，发现内部最终调用的就是  LogInvocationHandler 的 invoke 方法，LogInvocationHandler 的 invoke又通过反射技术调用了目标类(realLearn)的 learnChinese 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;method.invoke(target, args);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JDK动态代理的流程大概就是这样了，核心就是动态生成一个代理实例。不过这种方式有一个我呢提，Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？这时候就应用用CGLIB动态代理技术了。&lt;/p&gt;

&lt;h1 id=&#34;cglib动态代理&#34;&gt;CGLIB动态代理&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;CGLIB的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用CGLIB需要导入以下两个jar文件：
-  asm.jar：CGLIB的底层实现。
- cglib.jar：CGLIB的核心jar包。&lt;/p&gt;

&lt;p&gt;有关于引入包的时候，需要注意版本问题。如果没有引入 asm.jar，会报错如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.NoClassDefFoundError: org/objectweb/asm/Type
	at net.sf.cglib.core.TypeUtils.parseType(TypeUtils.java:184)
	at net.sf.cglib.core.KeyFactory.&amp;lt;clinit&amp;gt;(KeyFactory.java:66)
	at net.sf.cglib.proxy.Enhancer.&amp;lt;clinit&amp;gt;(Enhancer.java:69)
	at com.hand.hsp.proxy.CGProxyTest.main(CGProxyTest.java:11)
Caused by: java.lang.ClassNotFoundException: org.objectweb.asm.Type
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	... 4 more
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果引入的 cglib.jar 和 asm.jar 的版本有问题，如这里以 cglib.jar 3.1 和 asm.jar 3.2 为例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IncompatibleClassChangeError: class net.sf.cglib.core.DebuggingClassWriter has interface org.objectweb.asm.ClassVisitor as super class
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最终我引入的版本：  cglib.jar 3.1 和 asm.jar 5.0.4。&lt;/p&gt;

&lt;p&gt;下面是测试案例：接口和实现类保持不变，新增两个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LogMethodInterceptor implements MethodInterceptor {
    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println(&amp;quot;执行代理方法之前&amp;quot;);


        Object invoke = methodProxy.invokeSuper(object, args);

        System.out.println(&amp;quot;执行代理方法之后&amp;quot;);

        return invoke;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;public class CGProxyTest {
    public static void main(String[] args) {

        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(LearnImpl.class);
        enhancer.setCallback(new LogMethodInterceptor());

        Learn realLearn = (LearnImpl) enhancer.create();
        realLearn.learnChinese();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动程序，观察控制台输出
&amp;gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-6e05be98de552439.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CGLIB动态代理要比JDK动态代理速度更快，因为它不是通过反射技术来执行目标类方法的，但也比JDK动态代理更难理解一些。
为了更好的理解生成的代理类，设置如下属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// com/sun/proxy 表示class文件要输出到的文件夹
System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &amp;quot;com/sun/proxy&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次运行程序，生鲜生成了一下class文件，这里主要关注这三个：
&amp;gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/3744244-03f0a2ea32da5832.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中LearnImpl$$EnhancerByCGLIB$$e1c74c1d.class 就是动态生成的代理类，其源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.hand.hsp.proxy;

import java.lang.reflect.Method;
import net.sf.cglib.core.ReflectUtils;
import net.sf.cglib.core.Signature;
import net.sf.cglib.proxy.Callback;
import net.sf.cglib.proxy.Factory;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class LearnImpl$$EnhancerByCGLIB$$e1c74c1d extends LearnImpl implements Factory {
    private boolean CGLIB$BOUND;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private static final Method CGLIB$learnEnglish$0$Method;
    private static final MethodProxy CGLIB$learnEnglish$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$learnChinese$1$Method;
    private static final MethodProxy CGLIB$learnChinese$1$Proxy;
    private static final Method CGLIB$finalize$2$Method;
    private static final MethodProxy CGLIB$finalize$2$Proxy;
    private static final Method CGLIB$equals$3$Method;
    private static final MethodProxy CGLIB$equals$3$Proxy;
    private static final Method CGLIB$toString$4$Method;
    private static final MethodProxy CGLIB$toString$4$Proxy;
    private static final Method CGLIB$hashCode$5$Method;
    private static final MethodProxy CGLIB$hashCode$5$Proxy;
    private static final Method CGLIB$clone$6$Method;
    private static final MethodProxy CGLIB$clone$6$Proxy;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        Class var0 = Class.forName(&amp;quot;com.hand.hsp.proxy.LearnImpl$$EnhancerByCGLIB$$e1c74c1d&amp;quot;);
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{&amp;quot;finalize&amp;quot;, &amp;quot;()V&amp;quot;, &amp;quot;equals&amp;quot;, &amp;quot;(Ljava/lang/Object;)Z&amp;quot;, &amp;quot;toString&amp;quot;, &amp;quot;()Ljava/lang/String;&amp;quot;, &amp;quot;hashCode&amp;quot;, &amp;quot;()I&amp;quot;, &amp;quot;clone&amp;quot;, &amp;quot;()Ljava/lang/Object;&amp;quot;}, (var1 = Class.forName(&amp;quot;java.lang.Object&amp;quot;)).getDeclaredMethods());
        CGLIB$finalize$2$Method = var10000[0];
        CGLIB$finalize$2$Proxy = MethodProxy.create(var1, var0, &amp;quot;()V&amp;quot;, &amp;quot;finalize&amp;quot;, &amp;quot;CGLIB$finalize$2&amp;quot;);
        CGLIB$equals$3$Method = var10000[1];
        CGLIB$equals$3$Proxy = MethodProxy.create(var1, var0, &amp;quot;(Ljava/lang/Object;)Z&amp;quot;, &amp;quot;equals&amp;quot;, &amp;quot;CGLIB$equals$3&amp;quot;);
        CGLIB$toString$4$Method = var10000[2];
        CGLIB$toString$4$Proxy = MethodProxy.create(var1, var0, &amp;quot;()Ljava/lang/String;&amp;quot;, &amp;quot;toString&amp;quot;, &amp;quot;CGLIB$toString$4&amp;quot;);
        CGLIB$hashCode$5$Method = var10000[3];
        CGLIB$hashCode$5$Proxy = MethodProxy.create(var1, var0, &amp;quot;()I&amp;quot;, &amp;quot;hashCode&amp;quot;, &amp;quot;CGLIB$hashCode$5&amp;quot;);
        CGLIB$clone$6$Method = var10000[4];
        CGLIB$clone$6$Proxy = MethodProxy.create(var1, var0, &amp;quot;()Ljava/lang/Object;&amp;quot;, &amp;quot;clone&amp;quot;, &amp;quot;CGLIB$clone$6&amp;quot;);
        var10000 = ReflectUtils.findMethods(new String[]{&amp;quot;learnEnglish&amp;quot;, &amp;quot;()V&amp;quot;, &amp;quot;learnChinese&amp;quot;, &amp;quot;()V&amp;quot;}, (var1 = Class.forName(&amp;quot;com.hand.hsp.proxy.LearnImpl&amp;quot;)).getDeclaredMethods());
        CGLIB$learnEnglish$0$Method = var10000[0];
        CGLIB$learnEnglish$0$Proxy = MethodProxy.create(var1, var0, &amp;quot;()V&amp;quot;, &amp;quot;learnEnglish&amp;quot;, &amp;quot;CGLIB$learnEnglish$0&amp;quot;);
        CGLIB$learnChinese$1$Method = var10000[1];
        CGLIB$learnChinese$1$Proxy = MethodProxy.create(var1, var0, &amp;quot;()V&amp;quot;, &amp;quot;learnChinese&amp;quot;, &amp;quot;CGLIB$learnChinese$1&amp;quot;);
    }

    final void CGLIB$learnEnglish$0() {
        super.learnEnglish();
    }

    public final void learnEnglish() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$learnEnglish$0$Method, CGLIB$emptyArgs, CGLIB$learnEnglish$0$Proxy);
        } else {
            super.learnEnglish();
        }
    }

    final void CGLIB$learnChinese$1() {
        super.learnChinese();
    }

    public final void learnChinese() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$learnChinese$1$Method, CGLIB$emptyArgs, CGLIB$learnChinese$1$Proxy);
        } else {
            super.learnChinese();
        }
    }

    final void CGLIB$finalize$2() throws Throwable {
        super.finalize();
    }

    protected final void finalize() throws Throwable {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$finalize$2$Method, CGLIB$emptyArgs, CGLIB$finalize$2$Proxy);
        } else {
            super.finalize();
        }
    }

    final boolean CGLIB$equals$3(Object var1) {
        return super.equals(var1);
    }

    public final boolean equals(Object var1) {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var2 = var10000.intercept(this, CGLIB$equals$3$Method, new Object[]{var1}, CGLIB$equals$3$Proxy);
            return var2 == null ? false : (Boolean)var2;
        } else {
            return super.equals(var1);
        }
    }

    final String CGLIB$toString$4() {
        return super.toString();
    }

    public final String toString() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$4$Method, CGLIB$emptyArgs, CGLIB$toString$4$Proxy) : super.toString();
    }

    final int CGLIB$hashCode$5() {
        return super.hashCode();
    }

    public final int hashCode() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var1 = var10000.intercept(this, CGLIB$hashCode$5$Method, CGLIB$emptyArgs, CGLIB$hashCode$5$Proxy);
            return var1 == null ? 0 : ((Number)var1).intValue();
        } else {
            return super.hashCode();
        }
    }

    final Object CGLIB$clone$6() throws CloneNotSupportedException {
        return super.clone();
    }

    protected final Object clone() throws CloneNotSupportedException {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? var10000.intercept(this, CGLIB$clone$6$Method, CGLIB$emptyArgs, CGLIB$clone$6$Proxy) : super.clone();
    }

    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {
        String var10000 = var0.toString();
        switch(var10000.hashCode()) {
        case -1574182249:
            if (var10000.equals(&amp;quot;finalize()V&amp;quot;)) {
                return CGLIB$finalize$2$Proxy;
            }
            break;
        case -508378822:
            if (var10000.equals(&amp;quot;clone()Ljava/lang/Object;&amp;quot;)) {
                return CGLIB$clone$6$Proxy;
            }
            break;
        case 4351180:
            if (var10000.equals(&amp;quot;learnChinese()V&amp;quot;)) {
                return CGLIB$learnChinese$1$Proxy;
            }
            break;
        case 800444521:
            if (var10000.equals(&amp;quot;learnEnglish()V&amp;quot;)) {
                return CGLIB$learnEnglish$0$Proxy;
            }
            break;
        case 1826985398:
            if (var10000.equals(&amp;quot;equals(Ljava/lang/Object;)Z&amp;quot;)) {
                return CGLIB$equals$3$Proxy;
            }
            break;
        case 1913648695:
            if (var10000.equals(&amp;quot;toString()Ljava/lang/String;&amp;quot;)) {
                return CGLIB$toString$4$Proxy;
            }
            break;
        case 1984935277:
            if (var10000.equals(&amp;quot;hashCode()I&amp;quot;)) {
                return CGLIB$hashCode$5$Proxy;
            }
        }

        return null;
    }

    public LearnImpl$$EnhancerByCGLIB$$e1c74c1d() {
        CGLIB$BIND_CALLBACKS(this);
    }

    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        LearnImpl$$EnhancerByCGLIB$$e1c74c1d var1 = (LearnImpl$$EnhancerByCGLIB$$e1c74c1d)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (CGLIB$STATIC_CALLBACKS == null) {
                    return;
                }
            }

            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];
        }

    }

    public Object newInstance(Callback[] var1) {
        CGLIB$SET_THREAD_CALLBACKS(var1);
        LearnImpl$$EnhancerByCGLIB$$e1c74c1d var10000 = new LearnImpl$$EnhancerByCGLIB$$e1c74c1d();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Callback var1) {
        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});
        LearnImpl$$EnhancerByCGLIB$$e1c74c1d var10000 = new LearnImpl$$EnhancerByCGLIB$$e1c74c1d();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        CGLIB$SET_THREAD_CALLBACKS(var3);
        LearnImpl$$EnhancerByCGLIB$$e1c74c1d var10000 = new LearnImpl$$EnhancerByCGLIB$$e1c74c1d;
        switch(var1.length) {
        case 0:
            var10000.&amp;lt;init&amp;gt;();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
            return var10000;
        default:
            throw new IllegalArgumentException(&amp;quot;Constructor not found&amp;quot;);
        }
    }

    public Callback getCallback(int var1) {
        CGLIB$BIND_CALLBACKS(this);
        MethodInterceptor var10000;
        switch(var1) {
        case 0:
            var10000 = this.CGLIB$CALLBACK_0;
            break;
        default:
            var10000 = null;
        }

        return var10000;
    }

    public void setCallback(int var1, Callback var2) {
        switch(var1) {
        case 0:
            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;
        default:
        }
    }

    public Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(this);
        return new Callback[]{this.CGLIB$CALLBACK_0};
    }

    public void setCallbacks(Callback[] var1) {
        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];
    }

    static {
        CGLIB$STATICHOOK1();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码比较多，所以这里只关注我们在 main函数中调用到的方法learnChinese，其对应在代理类中的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public final void learnChinese() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$learnChinese$1$Method, CGLIB$emptyArgs, CGLIB$learnChinese$1$Proxy);
        } else {
            super.learnChinese();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CGLIB$CALLBACK_0是代理类的一个成员变量，就一个变量，无关紧要&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private MethodInterceptor CGLIB$CALLBACK_0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来梳理一下这段逻辑：
当 CGLIB$BIND_CALLBACKS 为空的时候，调用 CGLIB$BIND_CALLBACKS 方法，方法源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
......

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        LearnImpl$$EnhancerByCGLIB$$e1c74c1d var1 = (LearnImpl$$EnhancerByCGLIB$$e1c74c1d)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (CGLIB$STATIC_CALLBACKS == null) {
                    return;
                }
            }

            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CGLIB$BIND_CALLBACKS 方法内部先从ThreadLocal里面获取值(CGLIB$THREAD_CALLBACKS.get())，如果没有获取到值，就使用 CGLIB$STATIC_CALLBACKS  的值，如果还是没有值，直接返回；否则，将获取到的值赋值给 CGLIB$CALLBACK_0。&lt;strong&gt;【先不要管各个变量的值是怎么来的，之后会详细介绍】&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CGLIB$CALLBACK_0获取值返回到learnChinese方法之后，接着调用 intercept 方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var10000.intercept(this, CGLIB$learnChinese$1$Method, CGLIB$emptyArgs, CGLIB$learnChinese$1$Proxy);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不去纠结细节，大概可以猜测得出，这里调用的就是 LogMethodInterceptor 的 intercept 方法。如果我们没有设置MethodInterceptor， 就直接执行目标类的learnChinese，否则的话，执行intercept方法，逻辑上是可以走通的，但是不够严谨，所以接下来解释一下这些变量值是怎么来的。&lt;/p&gt;

&lt;p&gt;在 main 方法内，我们使用到了 Enhancer 类，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(LearnImpl.class);
        enhancer.setCallback(new LogMethodInterceptor());

        Learn realLearn = (LearnImpl) enhancer.create();

        realLearn.learnChinese();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置 父类。&lt;/li&gt;
&lt;li&gt;设置 MethodInterceptor。&lt;/li&gt;
&lt;li&gt;调用create方法创建 代理实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;create 方法源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public Object create() {
        classOnly = false;
        argumentTypes = null;
        return createHelper();
    }


    private Object createHelper() {
        validate();
        if (superclass != null) {
            setNamePrefix(superclass.getName());
        } else if (interfaces != null) {
            setNamePrefix(interfaces[ReflectUtils.findPackageProtected(interfaces)].getName());
        }
        return super.create(KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
                                                    ReflectUtils.getNames(interfaces),
                                                    filter,
                                                    callbackTypes,
                                                    useFactory,
                                                    interceptDuringConstruction,
                                                    serialVersionUID));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现调用了父类(AbstractClassGenerator)的create方法，源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    protected Object create(Object key) {
        try {
        	Class gen = null;
        	
            synchronized (source) {
                ClassLoader loader = getClassLoader();
                Map cache2 = null;
                cache2 = (Map)source.cache.get(loader);
                if (cache2 == null) {
                    cache2 = new HashMap();
                    cache2.put(NAME_KEY, new HashSet());
                    source.cache.put(loader, cache2);
                } else if (useCache) {
                    Reference ref = (Reference)cache2.get(key);
                    gen = (Class) (( ref == null ) ? null : ref.get()); 
                }
                if (gen == null) {
                    Object save = CURRENT.get();
                    CURRENT.set(this);
                    try {
                        this.key = key;
                        
                        if (attemptLoad) {
                            try {
                                gen = loader.loadClass(getClassName());
                            } catch (ClassNotFoundException e) {
                                // ignore
                            }
                        }
                        if (gen == null) {
                            byte[] b = strategy.generate(this);
                            String className = ClassNameReader.getClassName(new ClassReader(b));
                            getClassNameCache(loader).add(className);
                            gen = ReflectUtils.defineClass(className, b, loader);
                        }
                       
                        if (useCache) {
                            cache2.put(key, new WeakReference(gen));
                        }
                        return firstInstance(gen);
                    } finally {
                        CURRENT.set(save);
                    }
                }
            }
            return firstInstance(gen);
        } catch (RuntimeException e) {
            throw e;
        } catch (Error e) {
            throw e;
        } catch (Exception e) {
            throw new CodeGenerationException(e);
        }
    }

    abstract protected Object firstInstance(Class type) throws Exception;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就暂时就认为 create方法 通过字节码技术创建了一个 Class，在得到Class之后，它是通过 firstInstance(gen) 得到一个代理实例的。firstInstance 在 AbstractClassGenerator中是一个抽象方法，其在Enhancer类中的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static final String SET_THREAD_CALLBACKS_NAME = &amp;quot;CGLIB$SET_THREAD_CALLBACKS&amp;quot;;
......

    protected Object firstInstance(Class type) throws Exception {
        if (classOnly) {
            return type;
        } else {
            return createUsingReflection(type);
        }
    }

    private Object createUsingReflection(Class type) {
        setThreadCallbacks(type, callbacks);
        try{
        
        if (argumentTypes != null) {
        	
             return ReflectUtils.newInstance(type, argumentTypes, arguments);
             
        } else {
        	
            return ReflectUtils.newInstance(type);
            
        }
        }finally{
         // clear thread callbacks to allow them to be gc&#39;d
         setThreadCallbacks(type, null);
        }
    }

    private static void setThreadCallbacks(Class type, Callback[] callbacks) {
        setCallbacksHelper(type, callbacks, SET_THREAD_CALLBACKS_NAME);
    }

    private static void setCallbacksHelper(Class type, Callback[] callbacks, String methodName) {
        // TODO: optimize
        try {
            Method setter = getCallbacksSetter(type, methodName);
            setter.invoke(null, new Object[]{ callbacks });
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(type + &amp;quot; is not an enhanced class&amp;quot;);
        } catch (IllegalAccessException e) {
            throw new CodeGenerationException(e);
        } catch (InvocationTargetException e) {
            throw new CodeGenerationException(e);
        }
    }

    private static Method getCallbacksSetter(Class type, String methodName) throws NoSuchMethodException {
        return type.getDeclaredMethod(methodName, new Class[]{ Callback[].class });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就比较明朗了，Enhancer类 在通过父类AbstractClassGenerator 的 create 方法得到一个 Class对象之后，在通过自己的firstInstance(Class type) 方法得到一个实例(即代理对象)。在生成代理实例的过程中，通过反射技术，调用了代理类的 CGLIB$SET_THREAD_CALLBACKS 方法。
**这里可能有人会有疑惑：在代理实例生成之前，怎么能通过反射调用方法呢？这是因为 CGLIB$SET_THREAD_CALLBACKS  方法在代理类(LearnImpl$$EnhancerByCGLIB$$e1c74c1d.class)中是一个静态方法，而静态方法的调用是可以不依赖实例的 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Method setter = getCallbacksSetter(type, methodName);
    setter.invoke(null, new Object[]{ callbacks });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代理类(LearnImpl$$EnhancerByCGLIB$$e1c74c1d.class)中的CGLIB$SET_THREAD_CALLBACKS 源码如下，就是给 ThreadLocal 设置了一个值，这个值就是我们在main方法中传进去的 LogMethodInterceptor 实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，有关于代理类中的各个变量值来源已经真相大白，唯一还需要解释的就是 intercept 方法。&lt;/p&gt;

&lt;p&gt;之前我们说过，CGLIB动态代理速度比JDK动态代理运行速度更快，那么它为什么可以更快呢？我们知道，JDK动态代理是通过放射调用目标类的方法的，反射的速度很慢，所以CGLIB并没有采用反射的技术调用目标方法，&lt;strong&gt;而是通过建立方法与下标的映射来调用方法&lt;/strong&gt;，所以这里很有必要研究一下 intercept 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class var0 = Class.forName(&amp;quot;com.hand.hsp.proxy.LearnImpl$$EnhancerByCGLIB$$e1c74c1d&amp;quot;);
Class var1;
Method[] var10000 = ReflectUtils.findMethods(new String[]{&amp;quot;finalize&amp;quot;, &amp;quot;()V&amp;quot;, &amp;quot;equals&amp;quot;, &amp;quot;(Ljava/lang/Object;)Z&amp;quot;, &amp;quot;toString&amp;quot;, &amp;quot;()Ljava/lang/String;&amp;quot;, &amp;quot;hashCode&amp;quot;, &amp;quot;()I&amp;quot;, &amp;quot;clone&amp;quot;, &amp;quot;()Ljava/lang/Object;&amp;quot;}, (var1 = Class.forName(&amp;quot;java.lang.Object&amp;quot;)).getDeclaredMethods());

CGLIB$learnChinese$1$Method = var10000[1];

CGLIB$learnChinese$1$Proxy = MethodProxy.create(var1, var0, &amp;quot;()V&amp;quot;, &amp;quot;learnChinese&amp;quot;, &amp;quot;CGLIB$learnChinese$1&amp;quot;);
.....


var10000.intercept(this, CGLIB$learnChinese$1$Method, CGLIB$emptyArgs, CGLIB$learnChinese$1$Proxy)
......

public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    System.out.println(&amp;quot;执行代理方法之前&amp;quot;);


    Object invoke = methodProxy.invokeSuper(object, args);

    System.out.println(&amp;quot;执行代理方法之后&amp;quot;);

    return invoke;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，intercept 接收 4个参数
- Object object：代理实例(LearnImpl$$EnhancerByCGLIB$$e1c74c1d.class 实例)
- Method method：代理实例中的方法(CGLIB$learnChinese$1$Method)
- Object[] args：参数(这里为空)
- MethodProxy methodProxy：MethodProxy实例(CGLIB$learnChinese$1$Proxy)
&amp;gt;()V 表示 该方法的参数类表为空，返回类型为 void。
(Ljava/lang/Object;)Z 表示该方法接收一个 Object类型的参数，返回类型为 boolean&lt;/p&gt;

&lt;p&gt;其中最关键的可能就是 MethodProxy实例了，也就是CGLIB$learnChinese$1$Proxy ，发现它是通过MethodProxy.create方法创建的，该方法实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
        MethodProxy proxy = new MethodProxy();
        proxy.sig1 = new Signature(name1, desc);
        proxy.sig2 = new Signature(name2, desc);
        proxy.createInfo = new CreateInfo(c1, c2);
        return proxy;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解释一下sig1 和 sig2 。在代理类的源码中我们已经发现，除了生成一个与目标类的同名的learnChinese方法，还生成了一个对应 CGLIB$learnChinese$1 方法，而 CGLIB$learnChinese$1 方法内部仅仅是调用了目标类的learnChinese方法。这里的sig1 和 sig2 就分别对象这两个方法。
&lt;strong&gt;其实调用 invokeSuper 方法的逻辑大致如下：先执行方法内部的逻辑，当执行  methodProxy.invokeSuper(object, args); 的时候，通过下标的方式找到CGLIB$learnChinese$1 方法，然后调用，这样就间接达到调用目标类方法的目的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MethodProxy 的 invokeSuper方法实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public Object invokeSuper(Object obj, Object[] args) throws Throwable {
        try {
            init();
            FastClassInfo fci = fastClassInfo;
            return fci.f2.invoke(fci.i2, obj, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }

    private void init()
    {
        /* 
         * Using a volatile invariant allows us to initialize the FastClass and
         * method index pairs atomically.
         * 
         * Double-checked locking is safe with volatile in Java 5.  Before 1.5 this 
         * code could allow fastClassInfo to be instantiated more than once, which
         * appears to be benign.
         */
        if (fastClassInfo == null)
        {
            synchronized (initLock)
            {
                if (fastClassInfo == null)
                {
                    CreateInfo ci = createInfo;

                    FastClassInfo fci = new FastClassInfo();
                    fci.f1 = helper(ci, ci.c1);
                    fci.f2 = helper(ci, ci.c2);
                    fci.i1 = fci.f1.getIndex(sig1);
                    fci.i2 = fci.f2.getIndex(sig2);
                    fastClassInfo = fci;
                    createInfo = null;
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;init方法中，先生成LearnImpl$$FastClassByCGLIB$$c714789 类，然后根据 sig1 和 sig2 获取到对应方法的下标。所谓方法和下标映射，就是以下形式，这是在 LearnImpl$$FastClassByCGLIB$$c714789 的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public int getIndex(Signature var1) {
        String var10000 = var1.toString();
        switch(var10000.hashCode()) {
        case -1725733088:
            if (var10000.equals(&amp;quot;getClass()Ljava/lang/Class;&amp;quot;)) {
                return 8;
            }
            break;
        case -1026001249:
            if (var10000.equals(&amp;quot;wait(JI)V&amp;quot;)) {
                return 3;
            }
            break;
        case 4351180:
            if (var10000.equals(&amp;quot;learnChinese()V&amp;quot;)) {
                return 1;
            }
            break;
        case 243996900:
            if (var10000.equals(&amp;quot;wait(J)V&amp;quot;)) {
                return 4;
            }
            break;
        case 800444521:
            if (var10000.equals(&amp;quot;learnEnglish()V&amp;quot;)) {
                return 0;
            }
            break;
        case 946854621:
            if (var10000.equals(&amp;quot;notifyAll()V&amp;quot;)) {
                return 10;
            }
            break;
        case 1116248544:
            if (var10000.equals(&amp;quot;wait()V&amp;quot;)) {
                return 2;
            }
            break;
        case 1826985398:
            if (var10000.equals(&amp;quot;equals(Ljava/lang/Object;)Z&amp;quot;)) {
                return 5;
            }
            break;
        case 1902039948:
            if (var10000.equals(&amp;quot;notify()V&amp;quot;)) {
                return 9;
            }
            break;
        case 1913648695:
            if (var10000.equals(&amp;quot;toString()Ljava/lang/String;&amp;quot;)) {
                return 6;
            }
            break;
        case 1984935277:
            if (var10000.equals(&amp;quot;hashCode()I&amp;quot;)) {
                return 7;
            }
        }

        return -1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fci.f2.invoke(fci.i2, obj, args);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码就是调用了 LearnImpl$$FastClassByCGLIB$$c714789 中的 invoke 方法
- fci.i2 对应的下标，其实就是 CGLIB$learnChinese$1 对应的下标
- obj 代理实例，LearnImpl$$EnhancerByCGLIB$$e1c74c1d.class
- args 参数，这里为空&lt;/p&gt;

&lt;p&gt;至此，整体流程已经很明了，整体梳理一遍：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(LearnImpl.class);
enhancer.setCallback(new LogMethodInterceptor());
Learn realLearn = (LearnImpl) enhancer.create();
realLearn.learnChinese();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Enhancer在创建代理实例的时候，维护了新生成代理实例与LogMethodInterceptor的关系。然后通过代理实例调用learnChinese方法的时候，代理实例的learnChinese 方法内部调用了 LogMethodInterceptor 的 intercept 方法，而 intercept 方法内部又调用了MethodProxy的invokeSuper方法，invokeSuper 方法通过下标的形式调用了代理实例的CGLIB$learnChinese$1方法，而CGLIB$learnChinese$1方法内部调用了父类的learnChinese方法(即目标类的learnChinese方法)，这样就实现了不通过反射的方式间接的调用目标类的learnChinese方法。&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>ThreadPool</title>
      <link>https://www.spilledyear.cn/post/threadpool/</link>
      <pubDate>Fri, 29 Jun 2018 18:49:01 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/threadpool/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/262.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;synchronized&#34;&gt;synchronized&lt;/h1&gt;

&lt;h3 id=&#34;修饰于实例方法&#34;&gt;修饰于实例方法&lt;/h3&gt;

&lt;p&gt;这时候锁住的是类的实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private synchronized void test1(){
    count++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修饰于静态方法&#34;&gt;修饰于静态方法&lt;/h3&gt;

&lt;p&gt;这时候锁住的是Class对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static synchronized  void test2(){
    .......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修饰于实例对象&#34;&gt;修饰于实例对象&lt;/h3&gt;

&lt;p&gt;这时候锁住的是类的实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void test3(){
    synchronized(this){

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修饰于class对象&#34;&gt;修饰于Class对象&lt;/h3&gt;

&lt;p&gt;这时候锁住的是Class对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void test4(){
    synchronized(SyncTest.class){

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当作用于实例方法和实例对象时，锁住的即是当前实例；当作用于静态代码块和静态方法时，锁住的时Class对象。如果锁的是Class对象的，不管该类 new 出了多少实例，都可以保证线程之间保证同步。&lt;/p&gt;

&lt;h3 id=&#34;synchronized的可重入性&#34;&gt;synchronized的可重入性&lt;/h3&gt;

&lt;p&gt;从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private synchronized void test1(){
    count++;
}

private void test3(){
    synchronized(this){
        test1();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。&lt;/p&gt;

&lt;h1 id=&#34;volatile&#34;&gt;volatile&lt;/h1&gt;

&lt;p&gt;volatile相当于synchronized的弱实现，也就是说volatile实现了类似synchronized的语义，却又没有锁机制。如果使用了volatile修饰某个共享变量，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。&lt;/p&gt;

&lt;p&gt;Java 存储模型不会对valatile指令的操作进行重排序：这个保证对volatile变量的操作时按照指令的出现顺序执行的。&lt;/p&gt;

&lt;h1 id=&#34;cas&#34;&gt;CAS&lt;/h1&gt;

&lt;p&gt;独占锁就是线程获取锁后其他的线程都需要挂起，直到持有独占锁的线程释放锁；乐观锁是先假定没有冲突直接进行操作，如果因为有冲突而失败就重试，直到操作成功。乐观锁用到的机制就是CAS。&lt;/p&gt;

&lt;p&gt;例如 AtomicInteger类中的 compareAndSet 方法，调用了unsafe包，该方法的其作用是每次从内存中根据内存偏移量(valueOffset)取出数据，将取出的值跟expect 比较，如果数据一致就把内存中的值改为update&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;aqs&#34;&gt;AQS&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000008471362&#34;&gt;AQS &lt;/a&gt; 即AbstractQueuedSynchronizer，队列同步器基础框架。&lt;/p&gt;

&lt;p&gt;AQS的实现依赖内部的同步队列（FIFO双向队列），如果当前线程获取同步状态失败，AQS会将该线程以及等待状态等信息构造成一个Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_002.png&#34; alt=&#34;post_002&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所，state 用于表示同步状态，假设state=0表示同步状态可用(如果用于锁，则表示锁可用)，state=1表示同步状态已被占用(锁被占用)；head 和 tail 表示队列的头节点和尾节点。大致思路就是通过一个状态和一个Node队列来达到线程阻塞的效果。&lt;/p&gt;

&lt;p&gt;假设初始状态下state==0，表示锁可用。这时候有一个线程A过来了，因为这时候state==0，所以线程A顺利的拿到了锁，然后将state=state + 1；在A还没有释放锁的期间，线程B也过来的，因为此时state==1，线程锁被占用，所以B的线程信息就被封装成一个Node节点，并放入到同步队列中，同事阻塞线程B。在A没有释放锁的期间，如果又有其它线程过来，都会被假如到队列中。当线程A释放锁时，会将state置为0，此时A会唤醒头节点的后继节点，即B线程，此时B发现state已经为0，所以B线程可以顺利获取锁，B获取锁后B的Node节点随之出队。&lt;/p&gt;

&lt;h1 id=&#34;线程池流程&#34;&gt;线程池流程&lt;/h1&gt;

&lt;p&gt;我们知道，在Java中实现多线程的方式一般有两种：
- 继承Thread类。
- 实现Runable接口。&lt;/p&gt;

&lt;p&gt;但是同通过以上两种方式实现多线程有一些问题，比如每次在使用的时候都要new 一个实例，当线程的执行时间很短却又很频繁的时候，这就很不划算了；然后就是这种方式开启的线程，执行完任务之后无法获取执行结果，如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，也很难做到对线程的管理，比如中断一个线程、或者判断该线程是否已经完成这样使用起来就比较麻烦。所以Java 才提供了这么一个线程管理框架，用线程池来管理线程，当一个任务执行完毕之后，不会销毁这个线程，而是继续等待，当下一个任务到来的时候，使用该线程实例执行。其中又涉及到一些概念：Callable、Future、Executor。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Callable：该接口与Runable类似，只有一个call()方法，但是它可以有返回值，并且出现异常能抛出来。可以把它的实现类当作是一个任务，即每个子线程想要处理什么事情，执行怎样的逻辑，在它的是西安类中写。&lt;/li&gt;
&lt;li&gt;Future：Future就是对于具体的调度任务的执行结果进行查看，最为关键的是Future可以检查对应的任务是否已经完成，也可以阻塞在get方法上一直等待任务返回结果。Future的目的很明确，就是用来监视管管理任务的。&lt;/li&gt;
&lt;li&gt;Executor：通过Executor来调度执行任务。将任务提交给Executor，然后Executor在执行时使用其内部的线程池来完成操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样说，并不是很清楚，下面通过一个小例子来看线程池的使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class CallableTest {
    public static void main(String[] args) throws Exception{
        ExecutorService executor = Executors.newCachedThreadPool();

        Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() {
            @Override
            public String call() throws Exception {
                System.out.println(&amp;quot;call&amp;quot;);
                TimeUnit.SECONDS.sleep(1);
                return &amp;quot;str&amp;quot;;
            }
        });
        System.out.println(future.get());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;future&#34;&gt;Future&lt;/h3&gt;

&lt;p&gt;先来看看Future的继承关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_003.png&#34; alt=&#34;post_003&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在Future接口中，定义了以下方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {

    /**
     * Attempts to cancel execution of this task. 
     */
    boolean cancel(boolean mayInterruptIfRunning);

    /**
     * Returns {@code true} if this task was cancelled before it completed
     * normally.
     *
     * @return {@code true} if this task was cancelled before it completed
     */
    boolean isCancelled();

    /**
     * Returns {@code true} if this task completed.
     *
     * @return {@code true} if this task completed
     */
    boolean isDone();

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     */
    V get() throws InterruptedException, ExecutionException;

    /**
     * Waits if necessary for at most the given time for the computation
     * to complete, and then retrieves its result, if available.
     */
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RunnableFuture实现了Future接口和Runable接口&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而FutureTask类实现了RunnableFuture接口，即：FutureTask类实现了Future接口和Runable接口。我觉得在Java这个线程框架中，FutureTask真的是一个非常重要的角色。一方面，它是一个Future，于是它就而可以管理任务；另一方面，它是一个Runable实现，说明它可以被线程池中的工作线程调用；同时，它持有一个Callable引用，而这个引用刚好就是主线程中传进来的，所以，他可以管理我们传进去的那个Callable，而至于它具体怎么管理，则是它自己内部的逻辑，很巧妙的一个设计。&lt;/p&gt;

&lt;h3 id=&#34;executor&#34;&gt;Executor&lt;/h3&gt;

&lt;p&gt;先来看看Executor体系的继承关系图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_004.png&#34; alt=&#34;post_004&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Executor是线程执行这一块的顶层接口，其实它只有一个方法，人家的分工非常明确：我就是负责执行线程的，其它的我不需要。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface Executor {

    /**
     * Executes the given command at some time in the future.  The command
     * may execute in a new thread, in a pooled thread, or in the calling
     * thread, at the discretion of the {@code Executor} implementation.
     *
     * @param command the runnable task
     * @throws RejectedExecutionException if this task cannot be
     * accepted for execution
     * @throws NullPointerException if command is null
     */
    void execute(Runnable command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而有关于ExecutorService，除了继承了Executor的execute方法，还提供了很多其它的方法，其中submit就是我们常用的一个方法，有关于具体用途，在下面的源码分析中会解析，现在我们的首要目的是了解这个框架的运作流程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public interface ExecutorService extends Executor {

    void shutdown();

    List&amp;lt;Runnable&amp;gt; shutdownNow();

    boolean isShutdown();

    boolean isTerminated();

    boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException;

    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);

    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);

    Future&amp;lt;?&amp;gt; submit(Runnable task);

    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException;

    &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                                  long timeout, TimeUnit unit)
        throws InterruptedException;

    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)
        throws InterruptedException, ExecutionException;

    &amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AbstractExecutorService实现了ExecutorService接口，是一个抽象类，里面提供了一些默认实现方法，比如非常重要的submit方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ThreadPoolExecutor继承了AbstractExecutorService抽象类，它是一个非常核心的类,它实现了最核心的execute方法，从上面的代码中我们可以看出，AbstractExecutorService中的submit方法，其实最后还是调用了子类的execute方法来启动线程，有关于这个方类我们在下面重点介绍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我们再来说说示例代码中的Executors类，其实可以把它当作是一个工作类，这个类里面封装了一些常见的创建线程池的方法，可以让你根据不同的场景拆个创建不用的类型的线程池。可以发现，很多方法里面都返回了ThreadPoolExecutor&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Executors {

    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }

    public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }


    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                      threadFactory);
    }


    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }

    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;(),
                                      threadFactory);
    }


    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
        return new ScheduledThreadPoolExecutor(corePoolSize);
    }

    public static ScheduledExecutorService newScheduledThreadPool(
            int corePoolSize, ThreadFactory threadFactory) {
        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);
    }

    public static ExecutorService unconfigurableExecutorService(ExecutorService executor) {
        if (executor == null)
            throw new NullPointerException();
        return new DelegatedExecutorService(executor);
    }

    public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) {
        if (executor == null)
            throw new NullPointerException();
        return new DelegatedScheduledExecutorService(executor);
    }

    public static ThreadFactory defaultThreadFactory() {
        return new DefaultThreadFactory();
    }

    ......

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;执行流程&#34;&gt;执行流程&lt;/h3&gt;

&lt;p&gt;在使用这个框架的时候，可以说是非常方便了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception{
    ExecutorService executor = Executors.newCachedThreadPool();
    Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;xxx&amp;gt;() {......});
    System.out.println(future.get());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那有没有想过，它内部是怎么实现的呢？&lt;/p&gt;

&lt;p&gt;这样来理解：我们把main方法中的主流程当作是我们的主线程，将executor.submit当作是开启一个子线程去处理一些事情，future.get()相当于是获取子线程的执行结果。这里其实可以引出一些问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;executor.submit(Callable)需要开启一个子线程，但这个方法接收的是一个Callable对象，可是Thread方法需要接收的是Runable对象，那么他们之间必然存在某种转换关系吧。&lt;/li&gt;
&lt;li&gt;future.get()可以返回子线程的执行结果，说明future和子线程之间必然有一些关联。根据我们前面的介绍，这个Future实现类很可能就是FutureTask，因为它不不仅实现了Runable，而是也实现了Future。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么实际上，他们的关系是怎么样的呢？先看一下下面UML图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_005.png&#34; alt=&#34;post_005&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不太会用这个工具，这图画的不太好，但也大致说明了它们之间的关系：&lt;/p&gt;

&lt;p&gt;1、ThreadPoolExecutor中的execute(Runable r)需要接收一个Runable对象作为参数，在其方法内将Runable对象转换成Worker对象。有关于Worker，它是ThreadPoolExecutor中的一个内部类，同时实现了Runnable接口和继承了AQS(AbstractQueuedSynchronizer)。Worker构造函数中，将外部类中的execute(Runable r)方法中传进来的Runable对象赋值给自身的firstTask属性，然后以自身为参数构建了一个Thread对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    ......
    addWorker(command, true)
}
private boolean addWorker(Runnable firstTask, boolean core) {
    ......
    try {
        w = new Worker(firstTask);
        ......
        if (workerAdded) {
            t.start();
            workerStarted = true;
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}


Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
public void run() {
    runWorker(this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Worker中的run方法，调用了外部类的runWorker()方法。而在runWorker方法内，则调用了firstTask对象的run方法，也就是execute(Runable r)方法中传进来那个Runable对象的run方法，也就是说这时候是真正的开始执行我们的业务逻辑单元。&lt;/p&gt;

&lt;p&gt;那么Worker中额run方法是什么时候调用的呢？前面我们已经说过，Worker实现了Runable接口，并且在其构造函数中以自身为参数创建了一个Thread对象，然后将创建的这个Thread对象赋值给自身的thread属性。而在ThreadPoolExecutord的execute方法中，先是将该方法上的Runable参数转换成一个Worker对象，然后再获取到Worker上的thread属性，然后再通过thread.start()启动一个线程。&lt;/p&gt;

&lt;p&gt;也就是说，在执行thread.start()启动线程的时候，会先调用Worker对象的run方法，进而带调用外部类的
runWorker方法，进而调用execute(Runable r)方法传进来的Runable对象的run方法。&lt;/p&gt;

&lt;p&gt;说了这么多，肯定有点绕。上面给出的代码中，我省略了大部分逻辑代码，所以现在涉及到并没有涉及到其内部的代码实现细节，只是介绍了它的运作流程。通过这些我们可以发现，Worker才是这个真正的子线程。&lt;/p&gt;

&lt;p&gt;2、接下来需要明白的的就是，execute(Runable r)中需要的Runable对象是从哪里的？在代码示例中，我们调用了ExecutorService的submit的方法，前面已经说过，这个方法是在AbstractExecutorService抽象类中实现的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}

protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
    return new FutureTask&amp;lt;T&amp;gt;(callable);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;果不其然，在newTaskFor方法中将Callable对象转换成了一个FutureTask对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
    /**
     * The run state of this task, initially NEW.  The run state
     * transitions to a terminal state only in methods set,
     * setException, and cancel.  During completion, state may take on
     * transient values of COMPLETING (while outcome is being set) or
     * INTERRUPTING (only while interrupting the runner to satisfy a
     * cancel(true)). Transitions from these intermediate to final
     * states use cheaper ordered/lazy writes because values are unique
     * and cannot be further modified.
     *
     * Possible state transitions:
     * NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL
     * NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL
     * NEW -&amp;gt; CANCELLED
     * NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED
     */
    private volatile int state;
    private static final int NEW          = 0;
    private static final int COMPLETING   = 1;
    private static final int NORMAL       = 2;
    private static final int EXCEPTIONAL  = 3;
    private static final int CANCELLED    = 4;
    private static final int INTERRUPTING = 5;
    private static final int INTERRUPTED  = 6;

    /** The underlying callable; nulled out after running */
    private Callable&amp;lt;V&amp;gt; callable;
    /** The result to return or exception to throw from get() */
    private Object outcome; // non-volatile, protected by state reads/writes
    /** The thread running the callable; CASed during run() */
    private volatile Thread runner;
    /** Treiber stack of waiting threads */
    private volatile WaitNode waiters;


    public void run() {
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                            null, Thread.currentThread()))
            return;
        try {
            Callable&amp;lt;V&amp;gt; c = callable;
            if (c != null &amp;amp;&amp;amp; state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s &amp;gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }

    ......

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在FutureTask的run方法中，调用了Callable的call方法。&lt;/p&gt;

&lt;p&gt;转换成FutureTask对象之后，然后以FutureTask为参数，调用ThreadPoolExecutor中的execute方法，并且将FutureTask返回到主线程中。&lt;/p&gt;

&lt;p&gt;所以，结合我们前面分析的，在调用ThreadPoolExecutor中的execute方法时，通过开启一个Worker子线程(并不是说直接new 一个线程，要不然这样做就没有意义了，这其实属于线程池的内容，下面会有详细介绍)，然后在该子线程中调用FutureTask的run方法，而FutureTask中的run方法中调用了Callable对象的call方法。&lt;/p&gt;

&lt;p&gt;下面总结一下：
- ThreadPoolExecutor中的Worker调用了FutureTask中的run方法。
- FutureTask中的run方法调用了Callable对象的call方法。
- 因为FutureTask持有Callable的引用，所以在主线程中启动子线程之后，还是可以FutureTask来感知子线程的状态，而有关于子线程的监视管理：比如中断或者返回子线程状态，则是FutureTask自己实现的逻辑。&lt;/p&gt;

&lt;p&gt;对于这里面的调用流程，现在已经很清楚了，也可以很容易猜测的出，这样绕来绕去的调用，肯定是为了方便对子线程的管理，但究竟是怎样做到的对子线程的管理，我们现在并不清楚，所以接下来就来分析一下这部分内容，这才是线程池的核心。&lt;/p&gt;

&lt;h1 id=&#34;线程池原理&#34;&gt;线程池原理&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://juejin.im/entry/58fada5d570c350058d3aaad&#34;&gt;ThreadPoolExecutor&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;threadpoolexecutor创建&#34;&gt;ThreadPoolExecutor创建&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ExecutorService executor = Executors.newCachedThreadPool();

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&amp;lt;Runnable&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面也已经介绍过Executors类中提供了很多创建线程池的方法，发现其中用到了一些参数，这些参数是用来干嘛的？简单看看ThreadPoolExecutor中的一些属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

// runState is stored in the high-order bits
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

// Packing and unpacking ctl
private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }


// 记录着线程池中出现过的最大线程数量
private int largestPoolSize;

// 工厂类，用于创建Thread
private volatile ThreadFactory threadFactory;

// 空闲线程的存活时间，空闲线程 = maximumPoolSize - corePoolSize
private volatile long keepAliveTime;

// 核心线程数量
private volatile int corePoolSize;

// 最大线程数量
private volatile int maximumPoolSize;

// 用来存放用户提交的、尚未开始执行的Runnable任务
private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;

// RejectedExecution的捕获器
private volatile RejectedExecutionHandler handler;


public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                            ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
            threadFactory, defaultHandler);
}

public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
    if (corePoolSize &amp;lt; 0 ||
        maximumPoolSize &amp;lt;= 0 ||
        maximumPoolSize &amp;lt; corePoolSize ||
        keepAliveTime &amp;lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ThreadPoolExecutor通过一个AtomicInteger类型变量ctl来记录workerCount的数量和当前线程池的运行过状态runState。因为AtomicInteger操作具有原子性。一个int类型有32位，高3位用于表示线程池运行状态，后面29位用于计数。在运行过程中，代码中会反复使用runStateOf方法和workerCountOf方法来获取runState和workerCount&lt;/p&gt;

&lt;p&gt;线程池的运行状态一共有5种：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*   RUNNING:  Accept new tasks and process queued tasks
*   SHUTDOWN: Don&#39;t accept new tasks, but process queued tasks
*   STOP:     Don&#39;t accept new tasks, don&#39;t process queued tasks,
*             and interrupt in-progress tasks
*   TIDYING:  All tasks have terminated, workerCount is zero,
*             the thread transitioning to state TIDYING
*             will run the terminated() hook method
*   TERMINATED: terminated() has completed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而有关于状态之间的切换，包括以下情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* RUNNING -&amp;gt; SHUTDOWN
*    On invocation of shutdown(), perhaps implicitly in finalize()
* (RUNNING or SHUTDOWN) -&amp;gt; STOP
*    On invocation of shutdownNow()
* SHUTDOWN -&amp;gt; TIDYING
*    When both queue and pool are empty
* STOP -&amp;gt; TIDYING
*    When pool is empty
* TIDYING -&amp;gt; TERMINATED
*    When the terminated() hook method has completed
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;threadpoolexecutor执行&#34;&gt;ThreadPoolExecutor执行&lt;/h3&gt;

&lt;h5 id=&#34;execute方法&#34;&gt;execute方法&lt;/h5&gt;

&lt;p&gt;前面已经介绍过，在main线程中提交一个任务的时候，会调用ThreadPoolExecuto的execute方法，而有关于execute内部的执行流程，在网上找了一些资料，如下：&lt;/p&gt;

&lt;p&gt;1、如果当前运行的线程少于corePoolSize，则创建新线程来执行任务(注意，执行这一步骤需要获取全局锁)。&lt;/p&gt;

&lt;p&gt;2、如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。&lt;/p&gt;

&lt;p&gt;3、如果无法将任务加入BlockingQueue(队列已满)，则在非corePool中创建新的线程来处理任务(注意，执行这一步骤需要获取全局锁)。&lt;/p&gt;

&lt;p&gt;4、如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用
RejectedExecutionHandler.rejectedExecution()方法。&lt;/p&gt;

&lt;p&gt;ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute方法时，尽可能地避免获取全局锁(那将会是一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后(当前运行的线程数大于等于corePoolSize)，几乎所有的execute方法调用都是执行步骤2，而步骤2不需要获取全局锁。&lt;/p&gt;

&lt;p&gt;有关于在提交任务时会如何处理，下面是网上找到的一张图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_006.png&#34; alt=&#34;post_006&#34; /&gt;&lt;/p&gt;

&lt;p&gt;execute方法的具体实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
        * Proceed in 3 steps:
        *
        * 1. If fewer than corePoolSize threads are running, try to
        * start a new thread with the given command as its first
        * task.  The call to addWorker atomically checks runState and
        * workerCount, and so prevents false alarms that would add
        * threads when it shouldn&#39;t, by returning false.
        *
        * 2. If a task can be successfully queued, then we still need
        * to double-check whether we should have added a thread
        * (because existing ones died since last checking) or that
        * the pool shut down since entry into this method. So we
        * recheck state and if necessary roll back the enqueuing if
        * stopped, or start a new thread if there are none.
        *
        * 3. If we cannot queue task, then we try to add a new
        * thread.  If it fails, we know we are shut down or saturated
        * and so reject the task.
        */
    int c = ctl.get();

    /**
     * 如果当前活动的线程数小于核心线程数，则新建一个线程放入线程池中， addWorker中的第二个参* 数表示限制添加线程的数量是根据
     * corePoolSize来判断还是maximumPoolSize来判断。
     * 如果为true，根据corePoolSize来判断：如果为false，则根据maximumPoolSize来判断。
     */
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }

    // 如果当前线程池是运行状态并且任务添加到队列成功
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();

        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，handler执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);

        // 这里没懂什么意思    
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }

    // 这里表示线程池已经不是RUNNING状态 或者 线程池是RUNNING状态，但workerCount &amp;gt;= corePoolSize并且workQueue已满。
    else if (!addWorker(command, false))
        reject(command);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来说，在执行execute方法时如果状态一直是RUNNING时，的执行过程如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果workerCount &amp;lt; corePoolSize，则创建并启动一个线程来执行新提交的任务；&lt;/li&gt;
&lt;li&gt;如果workerCount &amp;gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；&lt;/li&gt;
&lt;li&gt;如果workerCount &amp;gt;= corePoolSize &amp;amp;&amp;amp; workerCount &amp;lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；&lt;/li&gt;
&lt;li&gt;如果workerCount &amp;gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里要注意一下addWorker(null, false);也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。&lt;/p&gt;

&lt;p&gt;execute方法执行流程如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_007.png&#34; alt=&#34;post_007&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;addworker方法&#34;&gt;addWorker方法&lt;/h5&gt;

&lt;p&gt;addWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 这个判断有点绕。简单来说，rs &amp;gt;= SHUTDOWN 就不能继续添加新任务；但是当 rs == SHUTDOWN时，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;
                firstTask == null &amp;amp;&amp;amp;
                ! workQueue.isEmpty()))
            return false;

        // 无限循环
        for (;;) {
            int wc = workerCountOf(c);

            // 如果当前线程数大于 2^29，或者大于 corePoolSize 或者 maximumPoolSize(这个取决于core),就直接返回
            if (wc &amp;gt;= CAPACITY ||
                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                return false;

            // 尝试增加workerCount，如果成功，则跳出第一个for循环  
            if (compareAndIncrementWorkerCount(c))
                break retry;

            // 如果增加workerCount失败，则重新获取ctl的值 
            c = ctl.get();

            // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行
            if (runStateOf(c) != rs)
                continue retry;

            // 否则表示CAS失败，重新执行内循环
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {

        // 根据execute传进来的Runablek来创建Worker对象
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            // 这有个全局锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());

                // 如果rs==RUNNING 或者 rs==SHUTDOWN但是firstTask == null(啥意思？没懂)
                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    // workers是一个HashSet
                    workers.add(w);

                    //largestPoolSize记录着线程池中出现过的最大线程数量
                    int s = workers.size();
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                // 启动线程，其实Worker的构造函数中，以自身位参数构造了一个Thread对象并返回给Worker中的thread对象，所以这里实际上是执行Worker的run方法
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;worker类&#34;&gt;Worker类&lt;/h5&gt;

&lt;p&gt;线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private final class Worker extends AbstractQueuedSynchronizer implements Runnabl{
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前面已经说过了，Worker的构造函数中，以自身位参数构造了一个Thread对象并返回给Worker中的thread对象，所以在addWorker中启动线程的时候，实际上是执行Worke的run方法。&lt;/p&gt;

&lt;p&gt;Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;lock方法一旦获取了独占锁，表示当前线程正在执行任务中；&lt;/li&gt;
&lt;li&gt;如果正在执行任务，则不应该中断线程；&lt;/li&gt;
&lt;li&gt;如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。此外，在构造方法中执行了setState(-1);把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected boolean tryAcquire(int unused) {
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tryAcquire方法是根据state是否是0来判断的，所以setState(-1)将state设置为-1是为了禁止在执行任务前对线程进行中断。正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0。&lt;/p&gt;

&lt;h5 id=&#34;runworker方法&#34;&gt;runWorker方法&lt;/h5&gt;

&lt;p&gt;在Worker类中调用了外部类的runWorker方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;

    // allow interrupts 允许中断
    w.unlock(); 

    // 是否因为异常退出循环
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();

            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            // 如果线程池正在stop，确保当前线程是中断状态；如果不是的话，则要保证当前线程不是中断状态；
            if (
                ( runStateAtLeast(ctl.get(), STOP) ||
                    (Thread.interrupted() &amp;amp;&amp;amp; runStateAtLeast(ctl.get(), STOP))
                )  
                &amp;amp;&amp;amp; !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。&lt;/p&gt;

&lt;p&gt;总结一下runWorker方法的执行过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;while循环不断地通过getTask()方法获取任务；&lt;/li&gt;
&lt;li&gt;getTask()方法从阻塞队列中取任务；&lt;/li&gt;
&lt;li&gt;如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；&lt;/li&gt;
&lt;li&gt;调用task.run()执行任务；&lt;/li&gt;
&lt;li&gt;如果task为null则跳出循环，执行processWorkerExit()方法；&lt;/li&gt;
&lt;li&gt;runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。&lt;/li&gt;
&lt;li&gt;这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;gettask方法&#34;&gt;getTask方法&lt;/h5&gt;

&lt;p&gt;getTask方法用来从阻塞队列中取任务:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Runnable getTask() {
    // timeOut变量的值表示上次从阻塞队列中取任务时是否超时
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 如果rs &amp;gt;= SHUTDOW 并且 (线程池正在停止或者workQueue里面位空)，则当前活动线程数减1
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。&lt;/p&gt;

&lt;h5 id=&#34;processworkerexit方法&#34;&gt;processWorkerExit方法&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {
    if (completedAbruptly) // If abrupt, then workerCount wasn&#39;t adjusted
        decrementWorkerCount();

    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 统计完成的任务数
        completedTaskCount += w.completedTasks;
        // 从workers中移除，也就表示着从线程池中移除了一个工作线程
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    tryTerminate();

    int c = ctl.get();

    /*
     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；
     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；
     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。
     */
    if (runStateLessThan(c, STOP)) {
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) &amp;gt;= min)
                return; // replacement not needed
        }
        addWorker(null, false);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/ThreadPool/post_008.png&#34; alt=&#34;post_008&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;tryterminate方法&#34;&gt;tryTerminate方法&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;final void tryTerminate() {
    for (;;) {
        int c = ctl.get();

        /*
         * 当前线程池的状态为以下几种情况时，直接返回：
         * 1. RUNNING，因为还在运行中，不能停止；
         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；
         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；
         */
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty()))
            return;

        // 如果线程数量不为0，则中断一个空闲的工作线程，并返回
        if (workerCountOf(c) != 0) { // Eligible to terminate
            interruptIdleWorkers(ONLY_ONE);
            return;
        }

        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // 啥也不干，留给子类
                    terminated();
                } finally {
                    // 设置状态为TERMINATED
                    ctl.set(ctlOf(TERMINATED, 0));
                    termination.signalAll();
                }
                return;
            }
        } finally {
            mainLock.unlock();
        }
        // else retry on failed CAS
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;shutdown方法&#34;&gt;shutdown方法&lt;/h5&gt;

&lt;p&gt;shutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 安全策略判断
        checkShutdownAccess();
        // 切换状态为SHUTDOWN
        advanceRunState(SHUTDOWN);
        // 中断空闲线程
        interruptIdleWorkers();
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }

    // 尝试结束线程池
    tryTerminate();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？&lt;/p&gt;

&lt;p&gt;下面仔细分析一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；&lt;/li&gt;
&lt;li&gt;shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；
在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；&lt;/li&gt;
&lt;li&gt;如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；&lt;/li&gt;
&lt;li&gt;由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；&lt;/li&gt;
&lt;li&gt;解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；&lt;/li&gt;
&lt;li&gt;但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；&lt;/li&gt;
&lt;li&gt;所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;interruptidleworkers方法&#34;&gt;interruptIdleWorkers方法&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;interruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。&lt;/p&gt;

&lt;p&gt;为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。&lt;/p&gt;

&lt;h5 id=&#34;shutdownnow方法&#34;&gt;shutdownNow方法&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public List&amp;lt;Runnable&amp;gt; shutdownNow() {
    List&amp;lt;Runnable&amp;gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 中断所有工作线程，无论是否空闲
        advanceRunState(STOP);
        // 取出队列中没有被执行的任务
        interruptWorkers();
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shutdownNow方法与shutdown方法类似，不同的地方在于：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设置状态为STOP；&lt;/li&gt;
&lt;li&gt;中断所有工作线程，无论是否是空闲的；&lt;/li&gt;
&lt;li&gt;取出阻塞队列中没有被执行的任务并返回；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;shutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。&lt;/p&gt;

&lt;h3 id=&#34;线程池的监控&#34;&gt;线程池的监控&lt;/h3&gt;

&lt;p&gt;通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;getTaskCount：线程池已经执行的和未执行的任务总数；&lt;/li&gt;
&lt;li&gt;getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；&lt;/li&gt;
&lt;li&gt;getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；&lt;/li&gt;
&lt;li&gt;getPoolSize：线程池当前的线程数量；&lt;/li&gt;
&lt;li&gt;getActiveCount：当前线程池中正在执行任务的线程数量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。&lt;/p&gt;

&lt;h1 id=&#34;futuretask&#34;&gt;FutureTask&lt;/h1&gt;

&lt;p&gt;前面有说到，在Worker线程start之后，最终会调用FutureTask中的run方法。有关于的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
    /**
     * The run state of this task, initially NEW.  The run state
     * transitions to a terminal state only in methods set,
     * setException, and cancel.  During completion, state may take on
     * transient values of COMPLETING (while outcome is being set) or
     * INTERRUPTING (only while interrupting the runner to satisfy a
     * cancel(true)). Transitions from these intermediate to final
     * states use cheaper ordered/lazy writes because values are unique
     * and cannot be further modified.
     *
     * Possible state transitions:
     * NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL
     * NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL
     * NEW -&amp;gt; CANCELLED
     * NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED
     */
    private volatile int state;
    // 在构建FutureTask时设置，同时也表示内部成员callable已成功赋值，一直到worker thread完成FutureTask中的run()
    private static final int NEW          = 0;

    // woker thread在处理task时设定的中间状态，处于该状态时，说明worker thread正准备设置result
    private static final int COMPLETING   = 1;

    // 当设置result结果完成后，FutureTask处于该状态，代表过程结果，该状态为最终状态final state(正确完成的最终状态)
    private static final int NORMAL       = 2;

    // 同上，只不过task执行过程出现异常，此时结果设值为exception，也是最终状态
    private static final int EXCEPTIONAL  = 3;

    // 表明task被cancel，task还没有执行就被cancel的状态，也是最终状态
    private static final int CANCELLED    = 4;

    // 中间状态，task运行过程中被interrupt时，设置的中间状态
    private static final int INTERRUPTING = 5;

    // 中断完毕的最终状态，几种情况，下面具体分析
    private static final int INTERRUPTED  = 6;

    // 具体run运行时会调用其方法call()
    private Callable&amp;lt;V&amp;gt; callable;

    // 没必要为votaile,因为其是伴随state 进行读写，而state是FutureTask的主导因素
    private Object outcome; 

    // 具体的worker thread
    private volatile Thread runner;
    
    // 并发stack数据结构，用于存放阻塞在该futuretask#get方法的线程
    private volatile WaitNode waiters;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建一个FutureTask的时候，首先设置state为new&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    this.callable = callable;
    this.state = NEW;       // ensure visibility of callable
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;run方法&#34;&gt;run方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread()))
        return;
    try {
        Callable&amp;lt;V&amp;gt; c = callable;
        if (c != null &amp;amp;&amp;amp; state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s &amp;gt;= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先判断任务的状态，如果任务状态不是new，说明任务状态已经改变(说明他已经走了上面4种可能变化的一种，比如caller调用了cancel，此时状态为Interrupting, 也说明了上面的cancel方法，task没运行时，就interrupt, task得不到运行，总是返回)。&lt;/p&gt;

&lt;p&gt;如果状态是new, 判断runner是否为null, 如果为null, 则把当前执行任务的线程赋值给runner，如果runner不为null, 说明已经有线程在执行，返回。此处使用cas来赋值worker thread是保证多个线程同时提交同一个FutureTask时，确保该FutureTask的run只被调用一次， 如果想运行多次，使用runAndReset()方法。&lt;/p&gt;

&lt;p&gt;这里的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;!UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于，使用compareAndSwap能够保证原子性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (this.runner == null ){
    this.runner = Thread.currentThread();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着开始执行任务，如果要执行的任务不为空，并且state为New就执行，可以看到这里调用了Callable的call方法。如果执行成功则set结果，如果出现异常则setException。最后把runner设为null。&lt;/p&gt;

&lt;h3 id=&#34;set方法&#34;&gt;set方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;protected void set(V v) {
    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
        outcome = v;
        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
        finishCompletion();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果现在的状态是NEW就把状态设置成COMPLETING，然后设置成NORMAL。这个执行流程的状态变化就是： NEW-&amp;gt;COMPLETING-&amp;gt;NORMAL。&lt;/p&gt;

&lt;h3 id=&#34;finishcompletion方法&#34;&gt;finishCompletion方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;private void finishCompletion() {
    // assert state &amp;gt; COMPLETING;
    for (WaitNode q; (q = waiters) != null;) {
        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {
            for (;;) {
                Thread t = q.thread;
                if (t != null) {
                    q.thread = null;
                    LockSupport.unpark(t);
                }
                WaitNode next = q.next;
                if (next == null)
                    break;
                q.next = null; // unlink to help gc
                q = next;
            }
            break;
        }
    }

    done();

    callable = null;        // to reduce footprint
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;finishCompletion()会解除所有阻塞的worker thread， 调用done()方法，将成员变量callable设为null。这里使用了LockSupport类来解除线程阻塞。&lt;/p&gt;

&lt;h3 id=&#34;get方法&#34;&gt;get方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s &amp;lt;= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先判断FutureTask的状态是否为完成状态，如果是完成状态，说明已经执行过set或setException方法，返回report(s):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private V report(int s) throws ExecutionException {
    Object x = outcome;
    if (s == NORMAL)
        return (V)x;
    if (s &amp;gt;= CANCELLED)
        throw new CancellationException();
    throw new ExecutionException((Throwable)x);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，如果FutureTask的状态是NORMAL, 即正确执行了set方法，get方法直接返回处理的结果， 如果是取消状态，即执行了setException，则抛出CancellationException异常。&lt;/p&gt;

&lt;p&gt;如果get时,FutureTask的状态为未完成状态，则调用awaitDone方法进行阻塞。&lt;/p&gt;

&lt;h3 id=&#34;awaitdone方法&#34;&gt;awaitDone方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }

        int s = state;
        if (s &amp;gt; COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING) // cannot time out yet
            Thread.yield();
        else if (q == null)
            q = new WaitNode();
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                    q.next = waiters, q);
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &amp;lt;= 0L) {
                removeWaiter(q);
                return state;
            }
            LockSupport.parkNanos(this, nanos);
        }
        else
            LockSupport.park(this);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;awaitDone方法可以看成是不断轮询查看FutureTask的状态。在get阻塞期间：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果执行get的线程被中断，则移除FutureTask的所有阻塞队列中的线程（waiters）,并抛出中断异常；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果FutureTask的状态转换为完成状态（正常完成或取消），则返回完成状态；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果FutureTask的状态变为COMPLETING, 则说明正在set结果，此时让线程等一等；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果FutureTask的状态为初始态NEW，则将当前线程加入到FutureTask的阻塞线程中去；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果get方法没有设置超时时间，则阻塞当前调用get线程；如果设置了超时时间，则判断是否达到超时时间，如果到达，则移除FutureTask的所有阻塞列队中的线程，并返回此时FutureTask的状态，如果未到达时间，则在剩下的时间内继续阻塞当前线程。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 自定义管道</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E9%81%93/</link>
      <pubDate>Thu, 09 Nov 2017 21:42:38 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%A1%E9%81%93/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/035.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文根据官网的例子简单介绍Angular管道的创建和使用，&lt;a href=&#34;https://angular.cn/guide/quickstart&#34;&gt;Angular官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;创建管道&#34;&gt;创建管道&lt;/h2&gt;

&lt;p&gt;创建一个管道可以直接使用ionic cli 工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic g pipe sxypie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和创建 指令基本类似，导入导出也是一样的。&lt;/p&gt;

&lt;p&gt;sxypie.ts 代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Pipe, PipeTransform } from &#39;@angular/core&#39;;

@Pipe({
  name: &#39;sxypie&#39;,
  pure: true,       //true表示纯管道， false表示非纯管道
})
export class SxypiePipe implements PipeTransform {

  /**
   * 放大指数
   * {{2 | exponentialStrength: 10}}    2^10 = 1024
   * @param {number} value
   * @param {string} exponent
   * @returns {number}
   */
  transform(value: number, exponent: string): number {
    let exp = parseFloat(exponent);
    return Math.pow(value, isNaN(exp) ? 1 : exp);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用管道&#34;&gt;使用管道&lt;/h2&gt;

&lt;p&gt;主要模板代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;自定义管道&amp;lt;/p&amp;gt;
  &amp;lt;h1&amp;gt;{{2 | sxypie: 10}}&amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;2 和 10  分别就是那两个参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果如下
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-a4bdf34819c4057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;自定义管道&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 自定义指令</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Thu, 09 Nov 2017 21:42:23 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/005.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 Angular 中有三种类型的指令
- 组件 — 拥有模板的指令
- 结构型指令 — 通过添加和移除 DOM 元素改变 DOM 布局的指令
- 属性型指令 — 改变元素、组件或其它指令的外观和行为的指令。&lt;/p&gt;

&lt;p&gt;组件的概念比较大，本文讲解的是属性指令和结构指令的创建和使用，&lt;a href=&#34;https://angular.cn/guide/quickstart&#34;&gt;Angular官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;创建属性指令&#34;&gt;创建属性指令&lt;/h2&gt;

&lt;p&gt;创建一个指令可以直接使用ionic cli 工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic g directive sxylight 
//sxylight 是该属性指令的名称
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是首次执行该命令，会在 src 目录下生成一个 directives 目录，如同时在 directives 目录下生成 directives.module.ts 文件，该文件使用 @NgModule 注解，是一个模块，用于统一自定义的指令。同时生成的还有sxylight 指令，并且 ionic cli 会自动将指令的信息添加到 directives.module.ts 模块中。
&amp;gt;大概是这样子的，只看标记的地方，多余的东西和本文无关
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e81e38f61965d05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;sxylight.ts  就是指令的具体实现，代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {Directive, ElementRef, HostListener, Input} from &#39;@angular/core&#39;;

@Directive({
  selector: &#39;[sxylight]&#39;
})
export class SxylightDirective {

  constructor(private el: ElementRef) {
    el.nativeElement.style.backgroundColor = &#39;yellow&#39;;
  }

  @Input(&#39;sxylight&#39;) highlightColor: string;

  @Input() defaultColor: string;

  @HostListener(&#39;mouseenter&#39;) onMouseEnter() {
    this.highlight(this.highlightColor || this.defaultColor || &#39;red&#39;);
  }

  @HostListener(&#39;mouseleave&#39;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.el.nativeElement.style.backgroundColor = color;
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;该指令的主要功能是：当鼠标悬浮到使用该指令的元素上时，元素的背景色发生变化。当鼠标离开时，清除背景色。
背景色的颜色可由父组件传入。

selector: &#39;[sxylight]&#39; 是该指令在外部使用时的名称
@Input 表示一个输入属性，表示可以从父组件传值进来
@HostListener 可用于监听事件
ElementRef 可以 替代dom API 获取元素 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用属性指令&#34;&gt;使用属性指令&lt;/h2&gt;

&lt;p&gt;使用自定义指令，有几个地方需要注意：首先需要子在 directives.module.ts 文件中 导入和导出， 然后需要在你使用的模块中导入。如果时使用 Ionic CLI工具创建的指令，directives.module.ts 已经自动配置好了，可以不用理会，需要的就是在别的模块中 引入 DirectivesModule(directives.module.ts )模块。比如，我需要在自己的 table模块中引用这个指令，那么只需要子啊 table.module.ts中引入这个模块即可，不需要在 app.module.ts中引入
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-369f5162fe875ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;导入工作做好之后，就可以直接在模板中使用该指令了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;自定义属性指令&amp;lt;/p&amp;gt;
  &amp;lt;h1 [sxylight]=&amp;quot;&#39;cyan&#39;&amp;quot; defaultColor=&amp;quot;violet&amp;quot;&amp;gt;测试自定义属性指令&amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;效果如下
初始化的时候
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-dc85117ccc4f986a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
鼠标悬浮之后
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e2f9d035b566a55d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
鼠标离开之后
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-6a46c63de0fb620a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;创建结构指令&#34;&gt;创建结构指令&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;ionic g directive sxyunless
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sxyunless.ts 代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Directive, Input, TemplateRef, ViewContainerRef } from &#39;@angular/core&#39;;

@Directive({
  selector: &#39;[sxyunless]&#39;
})
export class SxyunlessDirective {

  private hasView = false;

  constructor(private templateRef: TemplateRef&amp;lt;any&amp;gt;,
              private viewContainer: ViewContainerRef) {
  }

  @Input()
  set sxyunless(condition: boolean) {
    if (!condition &amp;amp;&amp;amp; !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition &amp;amp;&amp;amp; this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;这里定义了与 *ngIf 功能相反的指令，即：当条件不成立的时候才会生成对应的 DOM
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用结构指令&#34;&gt;使用结构指令&lt;/h2&gt;

&lt;p&gt;因为在上面我们引进导入了 DirectivesModule ，而 DirectivesModule 又包含了现在新创建的这个结构指令，因此这里不需要在 table.module.ts 中导入模块了。&lt;/p&gt;

&lt;p&gt;tables.html 关键代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;自定义结构指令&amp;lt;/p&amp;gt;
  &amp;lt;h1 *sxyunless=&amp;quot;false&amp;quot;&amp;gt; 测试自定义结构指令  &amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果如下
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-4e6b37405383b6c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果将 *sxyunless=&amp;ldquo;false&amp;rdquo;  改成  *sxyunless=&amp;ldquo;true&amp;rdquo;，即&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;自定义结构指令&amp;lt;/p&amp;gt;
  &amp;lt;h1 *sxyunless=&amp;quot;true&amp;quot;&amp;gt; 测试自定义结构指令  &amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则测试效果如下，该dom没有加载
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-8cb7bb2901dc7672.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，结构指令在使用的时候必须加  *  ，如果不加 * ，会出问题&lt;/strong&gt;
例如将代码成如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;p&amp;gt;自定义结构指令&amp;lt;/p&amp;gt;
  &amp;lt;h1 sxyunless=&amp;quot;false&amp;quot;&amp;gt; 测试自定义结构指令  &amp;lt;/h1&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;会导致以下错误
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-dcadfa8ba2690242.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 高德Web定位</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E9%AB%98%E5%BE%B7web%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Thu, 09 Nov 2017 21:42:09 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E9%AB%98%E5%BE%B7web%E5%AE%9A%E4%BD%8D/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/139.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;高德提供了Web平台定位的JS API，同样需要用到 APP_Key，并且需要注意是使用Web端的Key，如下图所示。必须是Web端的，其它平台的无效。
&lt;a href=&#34;http://lbs.amap.com/dev/key/app&#34;&gt;http://lbs.amap.com/dev/key/app&lt;/a&gt;
&lt;a href=&#34;http://lbs.amap.com/api/javascript-api/example/geocoder/regeocoding&#34;&gt;http://lbs.amap.com/api/javascript-api/example/geocoder/regeocoding&lt;/a&gt;
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ca23e9429c3bcc7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;在 index.html 中引入以下脚本，注意版本是 1.4.1， 这个版本和其它版本在使用上有区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;http://webapi.amap.com/maps?v=1.4.1&amp;amp;key=你的key&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在对应的ts 文件中 写以下代码测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;///在文件中全局声明 AMap
declare let AMap ;

  goLocation() {
    let that = this;
    let mapObj = new AMap.Map(&#39;iCenter&#39;);
    mapObj.plugin(&#39;AMap.Geolocation&#39;, function () {
      let geolocation = new AMap.Geolocation({
        enableHighAccuracy: true,//是否使用高精度定位，默认:true
        timeout: 10000,          //超过10秒后停止定位，默认：无穷大
        maximumAge: 0,           //定位结果缓存0毫秒，默认：0
        convert: true,           //自动偏移坐标，偏移后的坐标为高德坐标，默认：true
        showButton: true,        //显示定位按钮，默认：true
        buttonPosition: &#39;LB&#39;,    //定位按钮停靠位置，默认：&#39;LB&#39;，左下角
        buttonOffset: new AMap.Pixel(10, 20),//定位按钮与设置的停靠位置的偏移量，默认：Pixel(10, 20)
        showMarker: true,        //定位成功后在定位到的位置显示点标记，默认：true
        showCircle: true,        //定位成功后用圆圈表示定位精度范围，默认：true
        panToLocation: true,     //定位成功后将定位到的位置作为地图中心点，默认：true
        zoomToAccuracy:true      //定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false
      });
      mapObj.addControl(geolocation);
      geolocation.getCurrentPosition();
      AMap.event.addListener(geolocation, &#39;complete&#39;, that.onComplete.bind(that));//返回定位信息
      AMap.event.addListener(geolocation, &#39;error&#39;, (data)=&amp;gt;{ console.log(&#39;定位失败&#39; + data);});      //返回定位出错信息
    });
  }

  //解析定位结果
  onComplete(data) {
    console.log(data);
    console.log(data.position.toString());
    console.log(data.formattedAddress);
    var str=[&#39;定位成功&#39;];
    str.push(&#39;经度：&#39; + data.position.getLng());
    str.push(&#39;纬度：&#39; + data.position.getLat());
    if(data.accuracy){
      str.push(&#39;精度：&#39; + data.accuracy + &#39; 米&#39;);
    }//如为IP精确定位结果则没有精度信息
    str.push(&#39;是否经过偏移：&#39; + (data.isConverted ? &#39;是&#39; : &#39;否&#39;));
    // document.getElementById(&#39;tip&#39;).innerHTML = str.join(&#39;&amp;lt;br&amp;gt;&#39;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;goLocation() 是测试函数，当点击某个按钮的时候，调用这个函数。&lt;/p&gt;

&lt;p&gt;对应的 html代码很简单，就一个测试按钮&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;button (click)=&amp;quot;goLocation()&amp;quot;&amp;gt;定位&amp;lt;/button&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;测试结果
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d01e005da66905e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;以上是在 浏览器上测试的结果，如果是Ionic应用，在连接wifi的情况下，也可以进行定位，但是在不开wifi的情况下，无法定位。要想在android或者ios上实现定位，要借助大神写的cordova插件&lt;/strong&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 导航分析</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E5%AF%BC%E8%88%AA%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 08 Nov 2017 14:02:12 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E5%AF%BC%E8%88%AA%E5%88%86%E6%9E%90/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/235.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在刚接触ionic的时候，我觉得导航不太好理解，主要是ionic的导航方式和我们之前接触的路由导航方式不太一样。之前接触的路由，基本上都是根据不同的url加载不同的内容，比如最基本的，根据url的不同加载不同的html文件；或者像React中根据不同的url加载不同的组件，这种导航方式很直接，也非常方便理解。但ionic的导航系统使用起来感觉不是这样的，或许原理是类似的吧，但这里只讨论ionic中导航的使用。本文将通过一个例子，讲解ionic中导航的使用。
基本流程如下：登录  》 tabs 》退出重新到登录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;效果图
首次登录
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-3a57e0b1b6caabd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
登录之后进入到tabs界面
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-1d3989dcae912f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
点击退出功能重新回到登录界面
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-21f9a3baf0180c33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;uirouter&#34;&gt;uiRouter&lt;/h2&gt;

&lt;p&gt;路由是前端构建单页面应用(SPA)必不可少的一部分，AngularJS1.x中有两种路由实现，一个是内置的ngRouter，还有一个是基于 ngRoute 开发的第三方路由模块uiRouter。这里为什么要提uiRouter？因为就自我感觉而言uiRouter 和 ionic导航在使用方式上有点像，特别是从它们提供的指令这一层来考虑。如果你没有了解过Angular4中的路由，其实也可以简单看看uiRouter的使用，不需要了解的多详细，仅仅理解它的那个指令的使用方式就可以了。
&amp;gt;&lt;a href=&#34;https://ui-router.github.io/ng1/&#34;&gt;ui-router官网&lt;/a&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-acf83fefb28daaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
有关于uiRouter更详细的介绍，可以看看这篇文章 [Angular导航]()
点击对应链接，触发 $state.go(&amp;lsquo;x&amp;rsquo;x&amp;rsquo;x&amp;rsquo;)  方法，uiRouter根据state找到对应的视图并&lt;strong&gt;加载在ui-view容器中&lt;/strong&gt;，实现界面的变化。一定要注意，是将视图模板加载到 ui-view容器中，没有ui-view容器，是不能够显示对应的模板内容的。&lt;/p&gt;

&lt;h2 id=&#34;navcontroller&#34;&gt;NavController&lt;/h2&gt;

&lt;p&gt;ionic中的导航也是类似的，至少从指令这一层次来讲基本上类似的。在uiRouter中，通过&lt;ui-view&gt;这个指令来展示内容，也就可以将&lt;ui-view&gt;看作是一个容器，好了这个容器，uiRouter没办法将内容展示到界面。而ionic中也有一个类似的指令&lt;ion-nav&gt;。&lt;ion-nav&gt; 在ionic中就是一个内容的容器，没有这个容器什么也看不到，&lt;ion-nav&gt; 可以 覆盖在 &lt;ion-nav&gt; 上面， 可以通过给 &lt;ion-nav&gt; 添加唯一标识来区别多个&lt;ion-nav&gt;。 而对于界面的跳转，Ionic提供了一套自己的API，最常用的就是&lt;strong&gt;NavController&lt;/strong&gt;，这个类中几乎包含了与导航有关的所有方法，通过这个接口可以满足绝大部分需求。总的来说就是：&lt;ion-nav&gt; 是界面的容器，然后通过NavController提供的API实现界面的跳转，从而实现导航效果。
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-13abada434223b1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;实现过程&#34;&gt;实现过程&lt;/h2&gt;

&lt;p&gt;从整体上来看，有两个界面：登录界面、Tab界面。其中登录界面作为一个独立的 界面，tab界面中的某个tab上有退出当前用户功能，退出之后重新跳回到登录界面，很常见的一个流程。
&amp;gt;登录界面
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-35ed75c1a263a7ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
Tab界面，其中在Person这个tab页面有退出登录功能
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-8e39ac74978481ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;app.html 。可以把这里当作是整个应用的起点，也就是说在 app.html中必须要有一个&lt;ion-nav&gt; ，并且是作为整个应用的 根 &lt;ion-nav&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-nav [root]=&amp;quot;rootPage&amp;quot; &amp;gt;&amp;lt;/ion-nav&amp;gt;
//代码只有一行，其中 root 是 &amp;lt;ion-nav&amp;gt;中的一个属性指令，它的值是对应的一个 组件，但是 ionic3中支持懒加载，所以可以是一个字符串(有关于懒加载具体的可以看Angular和ionic的文档)

//root 表示的是默认加载的界面，也就是应用一启动就加载哪个界面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app.component.ts 。只结束一些主要的逻辑，我们希望实现这样的功能：当用户已经登录了，点开应用的 时候跳到tab界面，没有登录的时候，点开应用跳到登录界面。!this.nativeService.isLogin(false) 是我自己实现的一个函数，用于判断用户是否登录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 加载tabs页面之前先判断是否登录（就是进入系统时展示登录界面）
if (!this.nativeService.isLogin(false)) {
  this.rootPage = &#39;LoginPage&#39;;
} else {
  this.rootPage = &#39;TabsPage&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;login.html。主要就是一些布局，这个文件没什么特殊之处。&lt;/p&gt;

&lt;p&gt;login.ts。登录功能的逻辑代码，包括点击登录之后界面需要进行跳转，涉及到导航。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  //在构造函数中注入了 NavController
  constructor(private navCtrl: NavController,
              private navParams: NavParams,
              private formBuilder: FormBuilder,
              private viewCtrl: ViewController,
              private events: Events,
              private httpService: HttpService,
              private storageService: StorageService,
              private nativeService: NativeService) {
  }

  login(value) {
    this.nativeService.showLoading(&#39;loading...&#39;);

    this.httpService.login(&#39;/oauth/token&#39;, value).then(result =&amp;gt; {
      if (!result || !result.access_token) {
        this.nativeService.alert(result.message, &#39;登录失败&#39;);
        this.storageService.remove(ACCESS_TOKEN);
        return;
      }

      this.storageService.write(ACCESS_TOKEN, result.access_token);

      this.navCtrl.setRoot(&#39;TabsPage&#39;);
    }).catch(error =&amp;gt; {
      DEBUG &amp;amp;&amp;amp; console.log(&#39;访问错误：&#39; + error);
      this.nativeService.hideLoading();
      this.nativeService.showToast(&#39;用户名或密码错误&#39;);
    });
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;仅仅点击登录这部分功能。登陆成功后，先将ACCESS_TOKEN(可用于判断用户是否登录)存到localstorage中，然后执行界面跳转。界面跳转的实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.navCtrl.setRoot(&#39;TabsPage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表示将 TabsPage 设置为整个应用的跟界面，也就是说将 TabsPage  代表的界面放到 app.html中的&lt;ion-nav&gt;容器中。&lt;/p&gt;

&lt;p&gt;tabs.html。这个界面中用到了ionic提供的 &lt;ion-tabs&gt;组件，这是ionic封装好的，直接用就可以了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-tabs #mainTabs&amp;gt;
  &amp;lt;ion-tab [root]=&amp;quot;HomePage&amp;quot; tabTitle=&amp;quot;Home&amp;quot; tabIcon=&amp;quot;home&amp;quot;&amp;gt;&amp;lt;/ion-tab&amp;gt;
  &amp;lt;ion-tab root=&amp;quot;ExamplePage&amp;quot; tabTitle=&amp;quot;Example&amp;quot; tabIcon=&amp;quot;information-circle&amp;quot;&amp;gt;&amp;lt;/ion-tab&amp;gt;
  &amp;lt;ion-tab [root]=&amp;quot;PersonalPage&amp;quot; tabTitle=&amp;quot;Personal&amp;quot; tabIcon=&amp;quot;contacts&amp;quot;&amp;gt;&amp;lt;/ion-tab&amp;gt;
  &amp;lt;ion-tab [root]=&amp;quot;SegmentsPage&amp;quot; tabTitle=&amp;quot;Segments&amp;quot; tabIcon=&amp;quot;contacts&amp;quot;&amp;gt;&amp;lt;/ion-tab&amp;gt;
&amp;lt;/ion-tabs&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在&lt;ion-tabs&gt;下面有4个tab，表示我们在上面图片中看到的4个tab界面。&lt;/p&gt;

&lt;p&gt;接下来重点看看退出登录那个Tab界面
personal.html。只有一个按钮，点击退出当前账号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-header&amp;gt;
  &amp;lt;ion-navbar&amp;gt;
    &amp;lt;ion-title&amp;gt;personal&amp;lt;/ion-title&amp;gt;
  &amp;lt;/ion-navbar&amp;gt;
&amp;lt;/ion-header&amp;gt;

&amp;lt;ion-content padding&amp;gt;
  &amp;lt;button ion-item (click)=&amp;quot;exitSoftware()&amp;quot; hideWhen=&amp;quot;ios&amp;quot; detail-none&amp;gt;
    &amp;lt;ion-icon name=&amp;quot;log-out&amp;quot; item-left color=&amp;quot;danger&amp;quot;&amp;gt;&amp;lt;/ion-icon&amp;gt;
    退出当前账号
  &amp;lt;/button&amp;gt;
&amp;lt;/ion-content&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;personal.ts。对应的退函数如下，点击退出的时候，先弹出一个提示框，当用户确定退出的时候，清除localStorage里面的信息，然后跳转到登录界面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  exitSoftware() {
    this.alertCtrl.create({
      title: &#39;确认退出？&#39;,
      buttons: [{text: &#39;取消&#39;},
        {
          text: &#39;确定&#39;,
          handler: () =&amp;gt; {
            localStorage.clear();
            this.navCtrl.parent.parent.setRoot(&#39;LoginPage&#39;);
            // this.platform.exitApp(); 杀死app进程
          }
        }
      ]
    }).present();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一行代码需要注意&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; this.navCtrl.parent.parent.setRoot(&#39;LoginPage&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码代表什么意思呢？this.navCtrl.parent 代表当前&lt;ion-nav&gt;的父级&lt;ion-nav&gt;，this.navCtrl.parent.parent就代表父级的父级。含义已经知道了，但是为什么要这样写呢？
刚刚在前面已经说过，一个 &lt;ion-nav&gt; 可以 覆盖在 另外一个 &lt;ion-nav&gt; 上面，被覆盖方作为父级，覆盖方作为子级。有人可能会说，这里并没有用到&lt;ion-nav&gt; ，是的，可是这里用到了&lt;ion-tabs&gt;，这两者的功能是类似的，从代码中也可以看出来，都有一个root属性。并且&lt;ion-tabs&gt;就相当于是&lt;ion-tab&gt;的父级。
所以，根据以上的特性就可以分析出来，在 personal.ts 中，this.navCtrl 代表就是当前的那个Tab，叶就是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-tab [root]=&amp;quot;PersonalPage&amp;quot; tabTitle=&amp;quot;Personal&amp;quot; tabIcon=&amp;quot;contacts&amp;quot;&amp;gt;&amp;lt;/ion-tab&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说 this.navCtrl.parent 代表的是  &lt;ion-tabs&gt;。然后，&lt;ion-tabs&gt; 依附在 app.html中的 &lt;ion-nav&gt;上，所以 this.navCtrl.parent .parent代表的就是 app.html中的 &lt;ion-nav&gt;，也就是整个应用的根 &lt;ion-nav&gt;。this.navCtrl.parent.parent.setRoot(&amp;lsquo;LoginPage&amp;rsquo;)，/就是将该应用的根 &lt;ion-nav&gt;  展示界面设置为 LoginPage。&lt;/p&gt;

&lt;p&gt;如果你不这么做，而是在 personal.ts 中直接setRoot&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  exitSoftware() {
    this.alertCtrl.create({
      title: &#39;确认退出？&#39;,
      buttons: [{text: &#39;取消&#39;},
        {
          text: &#39;确定&#39;,
          handler: () =&amp;gt; {
            localStorage.clear();
            this.navCtrl.setRoot(&#39;LoginPage&#39;);
            // this.platform.exitApp(); 杀死app进程
          }
        }
      ]
    }).present();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你会看到这样的结果：登录界面依附在 tabs 上，这显然不是我们需要的结果
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-48c7073c8de35187.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 表单处理</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 07 Nov 2017 21:52:00 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/235.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在项目中，可以使用angular中的 @angular/forms模块处理表单，但是并不需要在app.module中引用@angular/forms模块，因为在app.module中已经引入了@angular/platform-browser模块，而在@angular/platform-browser模块中又导出了 @angular/forms 。也就是说，引入@angular/platform-browser模块之后就可以直接使用@angular/forms模块中提供的组件等内容。&lt;/p&gt;

&lt;h2 id=&#34;使用过程&#34;&gt;使用过程&lt;/h2&gt;

&lt;p&gt;从@angular/forms中引入需要用到的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {FormBuilder, Validators, FormGroup} from &#39;@angular/forms&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的表单初始化如下：formBuilder.group中的字段就是form表单中对应的字段，Validators 用于校验，规则根据实际情况配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  constructor(private navCtrl: NavController,
              private navParams: NavParams,
              private formBuilder: FormBuilder,
              private viewCtrl: ViewController,
              private events: Events,
              private httpService: HttpService,
              private storageService: StorageService,
              private nativeService: NativeService) {

    this.loginForm = formBuilder.group({
      username: [&#39;&#39;, Validators.compose([Validators.minLength(0), Validators.maxLength(16), Validators.required,])],
      password: [&#39;&#39;, Validators.compose([Validators.required, Validators.minLength(0)])]
    });
    this.username = this.loginForm.controls[&#39;username&#39;];
    this.password = this.loginForm.controls[&#39;password&#39;];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，表单初始化完成，下面是对应的 模板代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ion-row&amp;gt;
      &amp;lt;ion-col&amp;gt;
        &amp;lt;form [formGroup]=&amp;quot;loginForm&amp;quot; (ngSubmit)=&amp;quot;login(loginForm.value)&amp;quot; novalidate&amp;gt;
          &amp;lt;ion-row&amp;gt;
            &amp;lt;ion-col&amp;gt;
              &amp;lt;ion-list inset class=&amp;quot;no-border&amp;quot;&amp;gt;
                &amp;lt;ion-item  [class.error]=&amp;quot;!username.valid &amp;amp;&amp;amp; username.touched&amp;quot;&amp;gt;
                  &amp;lt;ion-label fixed&amp;gt;请输入账号&amp;lt;/ion-label&amp;gt;
                  &amp;lt;ion-input type=&amp;quot;text&amp;quot; [formControl]=&amp;quot;username&amp;quot; clearInput=true&amp;gt;&amp;lt;/ion-input&amp;gt;
                &amp;lt;/ion-item&amp;gt;
                &amp;lt;!--&amp;lt;div *ngIf=&amp;quot;username.hasError(&#39;required&#39;) &amp;amp;&amp;amp; username.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;*请输入用户名&amp;lt;/div&amp;gt;--&amp;gt;
                &amp;lt;!--&amp;lt;div *ngIf=&amp;quot;(username.hasError(&#39;minlength&#39;)||username.hasError(&#39;maxlength&#39;)||username.hasError(&#39;pattern&#39;)) &amp;amp;&amp;amp; username.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;*请输入正确的电话号码&amp;lt;/div&amp;gt;--&amp;gt;

                &amp;lt;ion-item&amp;gt;
                  &amp;lt;ion-label fixed&amp;gt;请输入密码&amp;lt;/ion-label&amp;gt;
                  &amp;lt;ion-input type=&amp;quot;password&amp;quot; [formControl]=&amp;quot;password&amp;quot; clearInput=true&amp;gt;&amp;lt;/ion-input&amp;gt;
                &amp;lt;/ion-item&amp;gt;
                &amp;lt;!--&amp;lt;div *ngIf=&amp;quot;password.hasError(&#39;required&#39;) &amp;amp;&amp;amp; password.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;*请输入密码&amp;lt;/div&amp;gt;--&amp;gt;
                &amp;lt;!--&amp;lt;div *ngIf=&amp;quot;(password.hasError(&#39;minlength&#39;)) &amp;amp;&amp;amp; password.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;*密码长度最少为六位&amp;lt;/div&amp;gt;--&amp;gt;

              &amp;lt;/ion-list&amp;gt;
            &amp;lt;/ion-col&amp;gt;
          &amp;lt;/ion-row&amp;gt;

          &amp;lt;ion-row&amp;gt;
            &amp;lt;ion-col&amp;gt;
              &amp;lt;div style=&amp;quot;text-align: center&amp;quot;&amp;gt;
                &amp;lt;button ion-button round type=&amp;quot;submit&amp;quot; class=&amp;quot;login-button&amp;quot; [disabled]=&amp;quot;!loginForm.valid&amp;quot;&amp;gt;测&amp;amp;nbsp;&amp;amp;nbsp;试&amp;lt;/button&amp;gt;
              &amp;lt;/div&amp;gt;
            &amp;lt;/ion-col&amp;gt;
          &amp;lt;/ion-row&amp;gt;
        &amp;lt;/form&amp;gt;

      &amp;lt;/ion-col&amp;gt;
    &amp;lt;/ion-row&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对应的 表单提交函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;login(value) {
    this.nativeService.showLoading(&#39;loading...&#39;);
    let password = Md5.hashStr(this.password).toString(),
      params = {
        username: value.username,
        password: value.password,
      };
    this.httpService.login(&#39;/oauth/token&#39;, params).then(result =&amp;gt; {
    //xxx
    }).catch(error =&amp;gt; {
    //xxx
    });
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngSubmit 是一个@output属性，将表单的值以键值对的方式组装成一个对象返回。&lt;/p&gt;

&lt;h2 id=&#34;自定义检验函数&#34;&gt;自定义检验函数&lt;/h2&gt;

&lt;p&gt;对以上代码稍做修改 login.ts&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  constructor(private navCtrl: NavController,
              private navParams: NavParams,
              private formBuilder: FormBuilder,
              private viewCtrl: ViewController,
              private events: Events,
              private httpService: HttpService,
              private storageService: StorageService,
              private nativeService: NativeService) {

    this.loginForm = formBuilder.group({
      username: [&#39;&#39;, Validators.compose([Validators.minLength(0), Validators.maxLength(16), Validators.required, ])],
      password: [&#39;&#39;, Validators.compose([Validators.required, Validators.minLength(0), this.passValidator])]
    });
    this.username = this.loginForm.controls[&#39;username&#39;];
    this.password = this.loginForm.controls[&#39;password&#39;];
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意上面用到了一个自定义校验函数  this.passValidator ，该函数内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  /**
   * 自定义检验函数
   * @param {FormControl} control
   * @returns {{username: {info: string}}}
   */
  passValidator(control: FormControl){
    const value = control.value;
    return value? null : {password: {info: &#39;这是自定义校验函数检查出来的错误&#39;}};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了查看测试结果，需要修改一下模板文件 login.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;ion-row&amp;gt;
      &amp;lt;ion-col&amp;gt;
        &amp;lt;form [formGroup]=&amp;quot;loginForm&amp;quot; (ngSubmit)=&amp;quot;login(loginForm.value)&amp;quot; novalidate&amp;gt;
          &amp;lt;ion-row&amp;gt;
            &amp;lt;ion-col&amp;gt;
              &amp;lt;ion-list inset class=&amp;quot;no-border&amp;quot;&amp;gt;
                &amp;lt;ion-item  [class.error]=&amp;quot;!username.valid &amp;amp;&amp;amp; username.touched&amp;quot;&amp;gt;
                  &amp;lt;ion-label fixed&amp;gt;请输入账号&amp;lt;/ion-label&amp;gt;
                  &amp;lt;ion-input type=&amp;quot;text&amp;quot; [formControl]=&amp;quot;username&amp;quot; clearInput=true&amp;gt;&amp;lt;/ion-input&amp;gt;
                &amp;lt;/ion-item&amp;gt;

                &amp;lt;ion-item&amp;gt;
                  &amp;lt;ion-label fixed&amp;gt;请输入密码&amp;lt;/ion-label&amp;gt;
                  &amp;lt;ion-input type=&amp;quot;password&amp;quot; [formControl]=&amp;quot;password&amp;quot; clearInput=true&amp;gt;&amp;lt;/ion-input&amp;gt;
                &amp;lt;/ion-item&amp;gt;
                &amp;lt;div *ngIf=&amp;quot;password.hasError(&#39;required&#39;) &amp;amp;&amp;amp; password.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;{{loginForm.getError(&#39;password&#39;, &#39;password&#39;)?.info}}&amp;lt;/div&amp;gt;

              &amp;lt;/ion-list&amp;gt;
            &amp;lt;/ion-col&amp;gt;
          &amp;lt;/ion-row&amp;gt;

          &amp;lt;ion-row&amp;gt;
            &amp;lt;ion-col&amp;gt;
              &amp;lt;div style=&amp;quot;text-align: center&amp;quot;&amp;gt;
                &amp;lt;button ion-button round type=&amp;quot;submit&amp;quot; class=&amp;quot;login-button&amp;quot; [disabled]=&amp;quot;!loginForm.valid&amp;quot;&amp;gt;测&amp;amp;nbsp;&amp;amp;nbsp;试&amp;lt;/button&amp;gt;
              &amp;lt;/div&amp;gt;
            &amp;lt;/ion-col&amp;gt;
          &amp;lt;/ion-row&amp;gt;
        &amp;lt;/form&amp;gt;

      &amp;lt;/ion-col&amp;gt;
    &amp;lt;/ion-row&amp;gt;

仅仅是加了 &amp;lt;div *ngIf=&amp;quot;password.hasError(&#39;required&#39;) &amp;amp;&amp;amp; password.touched&amp;quot; class=&amp;quot;error-message&amp;quot;&amp;gt;{{loginForm.getError(&#39;password&#39;, &#39;password&#39;)?.info}}&amp;lt;/div&amp;gt; 
当校验不通过的时候，就会在这个div上显示 在 login.ts 中定义的 提示信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;以下是测试结果，仔细看
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-9ad46babacce2e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
    </item>
    
    <item>
      <title>Ioonic3 开发流程</title>
      <link>https://www.spilledyear.cn/post/ioonic3-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Thu, 02 Nov 2017 15:44:27 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ioonic3-%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/275.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单介绍自己使用Ionic3开发的过程，涉及到的知识点如下：
Angular
Ionic
Cordova
ES6
TypeScript
Scss
环境搭建
引用插件
调试
Android打包
Android签名
IOS打包&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;angular&#34;&gt;Angular&lt;/h2&gt;

&lt;p&gt;Angular4，资源整理：&lt;a href=&#34;https://angular.cn/&#34;&gt;https://angular.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模块&lt;/strong&gt;
使用 @NgModule 注解声明一个模块，模块中可以包含一些组件、指令、管道，当需要在当前模块中引用其它模块的内容时（比如某些指令），只需要引入那个模块。
@NgModule的主要属性如下：&lt;a href=&#34;http://www.cnblogs.com/dojo-lzz/p/5878073.html&#34;&gt;http://www.cnblogs.com/dojo-lzz/p/5878073.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt;
在 Angular 中有三种类型的指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;组件 — 拥有模板的指令
&amp;lt;appHightlight&amp;gt;&amp;lt;appHightlight&amp;gt;

结构型指令 — 通过添加和移除 DOM 元素改变 DOM 布局的指令
比如：*ngIf 、*ngFo

属性型指令 — 改变元素、组件或其它指令的外观和行为的指令。
&amp;lt;p appHightlight&amp;gt;Highlight me!&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;
管道把数据作为输入，然后转换它，给出期望的输出。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;例如：&amp;lt;p&amp;gt;The hero&#39;s birthday is {{ birthday | date }}&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中， date 就是一个管道&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;路由&lt;/strong&gt;
Ionic对路由进行了封装，所以基本上看不出Angular路由的影子，API就看Ionic的API即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NavController、NavParams、&amp;lt;ion-nav&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;
和你想象中的依赖注入一样。&lt;/p&gt;

&lt;h2 id=&#34;ionic&#34;&gt;Ionic&lt;/h2&gt;

&lt;p&gt;ionic3基于Angular4。我们知道Angular可以创建自己的模块、组件、管道、服务等等，Ionic就是干了这么一件事情。Ionic提供了一系列的组件给我们使用，使用&lt;grid&gt;（基于flex）实现响应式布局。
资源整理：&lt;a href=&#34;https://ionicframework.com/docs/&#34;&gt;https://ionicframework.com/docs/&lt;/a&gt;
API太多了，直接看文档就好了。&lt;/p&gt;

&lt;h2 id=&#34;cordova&#34;&gt;Cordova&lt;/h2&gt;

&lt;p&gt;Cordova提供JS访问原生设备的一种手段。Ionic Nativa 对cordova插件做了一层轻度封装，不过提供的文档资料不够详细，所以主要文档还是在 cordova官网上。
资源整理：&lt;a href=&#34;http://cordova.axuer.com/&#34;&gt;http://cordova.axuer.com/&lt;/a&gt;
在实际开发中，也就是在需要 使用到摸个插件的时候才去看一下该插件对应的api。&lt;/p&gt;

&lt;h2 id=&#34;es6&#34;&gt;ES6&lt;/h2&gt;

&lt;p&gt;表面上是在写TypeeScript，实际上还是在写JS。所以，还是很有必要学习一下ES6的一些基本用法。
资源整理：&lt;a href=&#34;http://es6.ruanyifeng.com/&#34;&gt;http://es6.ruanyifeng.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;typescript&#34;&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;TypeScript是JavaScript的超集（superset），“任何合法的JavaScript都是合法的TypeScript。”
自我感觉：表面上是在写TypeeScript，实际上还是在写JS。
基本使用：Class、强类型。
资源整理：&lt;a href=&#34;http://www.tslang.cn/docs/home.html&#34;&gt;http://www.tslang.cn/docs/home.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;scss&#34;&gt;Scss&lt;/h2&gt;

&lt;p&gt;花几分钟简单了解一下基本用法。其实主要就是css，不过这里推荐学医一下 flex 布局。
Flex：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&#34;&gt;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&lt;/a&gt;
Scss：&lt;a href=&#34;http://sass.bootcss.com/docs/sass-reference/&#34;&gt;http://sass.bootcss.com/docs/sass-reference/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境搭建&#34;&gt;环境搭建&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;安装Node
全局安装 ionic cordova
配置SDK
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;引用插件&#34;&gt;引用插件&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;安装Ionic Nativa 插件
直接在Ionic官网看，上面会给安装的命令，拿过来用就好了
ionic cordova plugin add cordova-plugin-camera
npm install --save @ionic-native/camera

安装大神写的插件
Cordova允许我们自定义插件，这种插件一般都放在 github，需要自己去找。
ionic cordova plugin add https://github.com/yanxiaojun617/com.kit.cordova.amaplocation --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;

&lt;p&gt;样式问题：直接在浏览器上调试
需要调用原生设备：真机+chrome调试，这样可以看到日志，要不然你是没办法看到日志的。&lt;/p&gt;

&lt;h2 id=&#34;android打包&#34;&gt;Android打包&lt;/h2&gt;

&lt;p&gt;使用ionic cli 打包，打包分两种，开发包 和发布包。发布包需要对app进行签名。
资源整理：&lt;a href=&#34;http://www.jianshu.com/p/a7791341709e&#34;&gt;http://www.jianshu.com/p/a7791341709e&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;android签名&#34;&gt;Android签名&lt;/h2&gt;

&lt;p&gt;如果需要发布应用到 安卓市场
资源整理：&lt;a href=&#34;http://www.jianshu.com/p/26166279413b&#34;&gt;http://www.jianshu.com/p/26166279413b&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ios打包&#34;&gt;IOS打包&lt;/h2&gt;

&lt;p&gt;比较麻烦，涉及到一系列IOS证书，关键是还要开发者账号，要钱。目前的做法是远程打包，不过目前有一个问题：现在那台机器 上的证书好像失效了/ku。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 自动化发布</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83/</link>
      <pubDate>Sun, 29 Oct 2017 17:40:07 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/246.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍使用Jenkins实现app应用的自动打包发布。每次执行jenkins任务的时候，大概流程如下：打包app应用》将app应用作为邮件附件发送给件给客户。
不管你想体验Jenkins自动化部署带来的便捷，还是学习Jenkins 自动部署 app 这门技巧，这篇文章都适合你。如果恰好你所开发的app是在内部使用的，不需要每次都通过qq还是什么方式发送给客户，Jenkins帮你一键搞定。&lt;/p&gt;

&lt;h2 id=&#34;jenkins安装&#34;&gt;Jenkins安装&lt;/h2&gt;

&lt;p&gt;推荐使用简单的安装方法
&amp;gt;下载地址：&lt;a href=&#34;https://jenkins.io/download/&#34;&gt;https://jenkins.io/download/&lt;/a&gt;   选择下载war包
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-4f5af0c20c018a3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image01.png&#34; /&gt;
下载之后，准备好一个tomcat，然后将下载的war包放到 tomcat的webapps目录下，然后启动tomcat，这时候tomcat会自动解压这个war包。
在启动的过程中，会提示输入密码，这个密码我暂时不知道干嘛的，参照提示输入就好了:
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-b74a6e71822c6eb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image02.png&#34; /&gt;
这时候在浏览器中输入： localhost:8081/jenkins，会提示你输入密码，将命令行中的密码拷贝进去就好了。输入密码之后，进入到选择安装插件的界面，有两种方式，一种是建议安装，一种是自定义安装，直接选择建议安装。然后就是等待安装插件：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-95ceded256470e3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image03.png&#34; /&gt;
安装插件之后，提示创建用户：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-50d2eeaf5188a2df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image04.png&#34; /&gt;
创建用户之后：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d40d4d9881ceb9a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-6ca2ecfe6eb9d84b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
至此Jenkins安装完成。&lt;/p&gt;

&lt;h2 id=&#34;创建jenkins任务&#34;&gt;创建Jenkins任务&lt;/h2&gt;

&lt;p&gt;进入jenkins首页后，点击创建一个新任务。
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-f509e840f4127e5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
接下来进入到详细配置界面。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;补充描述信息
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e6590e45e6bf622d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;配置代码仓库，这里选择git
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-5338cd9740e00b47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;省略这两个步骤
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-04246b188900930e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;构建
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-27f9e51f98ab4b79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-76b7717beeb91f11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存之后跳转到enkins首页，运行我们刚刚创建的任务：
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-0a736be2d2b21aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
同时，可以查看日志：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e730ad3d6d26e988.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e82855f85bd7c62c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;按理来说，我们是希望可以正常的打包出一个apk文件了，但是很不巧，失败了。下面来分析一下原因。
&amp;gt;我们知道我们的ionic项目是利用npm进行包管理的，npm是根据package.json文件安装依赖的。我们利用jenkins进行打包的时候，仅仅是从git上拉下了代码，下载需要的哪些jar包，这是一个原因。还有另外一个原因，我们打包apk文件的时候，是需要依赖SDk和安卓平台的，安卓平台我们一般是通过执行 ionic cordova platform add android 命令来添加，但是我们不可能把这个提交到git上，要不然这个项目太大了。这个时候，我们可以在 jenkins 构建的时候 执行这两个命令：
npm install 和 ionic cordova platform add android
这样确实可以，但是太慢了，每次执行 jenkins命令的时候执行上面两个命令，会浪费好多时间，得不偿失，那就找一个这折中的办法。在使用这种方法之前，先分析一下Jenkins执行 命令的 流程，这个过程可以通过日志分析出来，以下是在执行jenkins命令时候的日志：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-c77796cac2852ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
有这个日志就足够了，通过日志发现，jenkins有一个工作目录，在执行命令的时候创建的（第一次执行的时候创建，执行之后不会自动删除），目录的路径就是 当前用户/jenkins/任务名称。Jenkins在执行命令之前，会先从git上下载代码到这个目录，然后再执行命令。既然知道这个 那就 很简单那了 。我们可以第一次手动再这个目录下执行 npm install 和 ionic cordova pllatform add android 这两个命令，这样再打包的时候 就不会报错了。在执行这 两个 命令之后，再执行jenkins命令，通过日志可以发现，打包成功了，生成了apk文件。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ead2db4fcad2cfb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-20d2703625f86d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时，在 jenkins工作目录下，可以找到刚刚打包的apk文件。
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-961cb56cf8d91b82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;发送邮件设置&#34;&gt;发送邮件设置&lt;/h2&gt;

&lt;p&gt;在 成功打包apk文件之后，希望可以将apk文件通过邮件的形式发送给客户 ，客户在邮件中直接下载附件 即可。
首先需要先配置好jenkins的邮件 发送功能。进入首页，点击系统管理：
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-7bc676a833dabb77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
然后再点击 系统设置
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-e2e6211944c9daa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
需要发送邮件，有这么几个选项需要配置：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-c9d63ec3ae855e39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
系统管理员地址其实就是发送方的邮件地址
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-b04b4014bb4b51bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
而且上面哪些参数一定要注意，写错一个可能就发送 失败了
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-f73629a3817d9c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到邮件发送成功，说明基本的邮件发送设置完成。&lt;/p&gt;

&lt;h2 id=&#34;项目发送邮件&#34;&gt;项目发送邮件&lt;/h2&gt;

&lt;p&gt;邮件通知的全局设置配好以后就可以在具体的项目中应用发送邮件通知了。首先需要安装插件，在系统管理→插件管理→可选插件 搜索找到 Email Extension Plugin  安装好后，点开要配置的项目配置。
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ee84e6069ec75ac1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-9a712b995c87ab0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
配置收件人地址列表
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-f51e2340888a45d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
如上，在任务构建 异常的时候就会发送邮件，为了看到效果，可以故意将上面的两个 命令写错，这样在构建的时候就会报错。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d1bde3ad06b4eab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
然后执行构建任务并 查看日志
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ec89cfc37d9227e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
然后去 收件箱查收邮件
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-6adc326e29b544f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此，项目发送发送邮件完成。&lt;/p&gt;

&lt;h2 id=&#34;邮件全局配置&#34;&gt;邮件全局配置&lt;/h2&gt;

&lt;p&gt;可以利用Email Extension Plugin插件全局配置发送邮件的基本配置。如果是在第一次打开jenkins主页的时候，选择安装了它建议安装的插件，那么这个插件已经有了，其它情况 不太清楚，如果没有就自己安装一下插件。配置方法如下：
首页：系统管理 》系统设置
找到Email Extension Plugin 设置
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-4954d6b4e195a0b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
这是基本配置，还有个高级设置，点击 “ 高级”
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d727cd2181031fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d6c874b1d6da75dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
这个 和 “邮件通知” 中配置保持一致就好了
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-0b39563d37a06144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
这个地方有个Default Triggers. 用来设置发送 邮件的出发条件。我的 配置 如下：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ef7845a0f2dcdd15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;项目引用全局配置&#34;&gt;项目引用全局配置&lt;/h2&gt;

&lt;p&gt;在项目发送邮件的时候使用刚刚的 全局配置。先打开项目配置界面：
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-0f693ffe46d54744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
点击构建后操作并且选择Email Extension Plugin，如下所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-5d825ff7b9a4306e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-c8c5777f62de518d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-ae1fd03620f7ba7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
如图所示，这时候还的默认使用了 全局的一些配置。点击保存，再次测试，构建任务。当任务执行成功之后，可以在收件箱查收邮件。因此在全局配置中设置了出发条件，always、success、fail。按理来说可以收到两封邮件。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-7a42e1aa628849ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-b5ea4372e63b97e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;发现收件箱收到两封邮件，测试成功。&lt;/p&gt;

&lt;h2 id=&#34;项目自定义配置&#34;&gt;项目自定义配置&lt;/h2&gt;

&lt;p&gt;如果该任务不想引用全局配置，需要自己定义配置怎么办？这里也有个项目自定义功能，如图：
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-31b72a01e0fbab3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
点击Advanced setting 即可自定义配置。而且这里的自定义配置，是根据触发条件分别设置的：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-662a3c74367c0fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
针对不同的触发条件，点击高级即可自定义配置了
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-657c8987328c4245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
下面对 “success” 进行设置，每次利用jenkins打包成功后，将apk文件作为邮件的附件发送给客户
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-fe36d69c6597a5b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
路径的选择请参照下面的提示
保存之后执行构建任务，查看发件箱
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-df60ea37ecb5ed15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;邮件发送成功，附件发送成功。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 拍照上传</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0/</link>
      <pubDate>Sun, 29 Oct 2017 17:38:59 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/238.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍使用cordova实现拍照上传，走通 “拍照 》预览 》上传 》 下载 ”这个流程。为了方便查看测试结果，需要了解Ionic应用调试的基本方法，有关于Ionic项目Android 调试的详细教程，请参考以下文章：&lt;a href=&#34;http://www.jianshu.com/p/d873b831e207&#34;&gt;Ionic3 Android调试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/spilledyear/igStart&#34;&gt;源码地址&lt;/a&gt;
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-f8e307232af1f7a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;
&lt;a href=&#34;https://ionicframework.com/docs/native/file/&#34;&gt;ionicAPI&lt;/a&gt;
&lt;a href=&#34;https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html&#34;&gt;cordovaAPI&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;界面预览&#34;&gt;界面预览&lt;/h2&gt;

&lt;p&gt;项目是基于ionic 提供的 tabs模板创建的，除了添加一个 camera page，在camera里面做测试，其它地方基本没有修改过。主要涉及到的demo：拍照 》 预览 》 上传 》 下载
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-6ebb5254016f26eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;安装 cordova-plugin-camera 插件&lt;/strong&gt;
该插件用于调用设备摄像，cordova-plugin-camera  这是比较新版本的插件，老版本的插件是这个：‘org.apache.cordova.camera’，不过官方已经不推荐使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova plugin add cordova-plugin-camera
npm install --save @ionic-native/camera
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装File插件&lt;/strong&gt;
File 插件基于HTML5 File API规范，提供了一些列的方法用于用于操作文件、目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic cordova plugin add cordova-plugin-file
npm install --save @ionic-native/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装File Transfer插件&lt;/strong&gt;
File Transfer 插件提供上传和下载文件的方法，使用上很便利&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic cordova plugin add cordova-plugin-file-transfer
npm install --save @ionic-native/file-transfer
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;主要代码&#34;&gt;主要代码&lt;/h2&gt;

&lt;p&gt;app.module.ts，需要引入这几个插件的provider&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { NgModule, ErrorHandler } from &#39;@angular/core&#39;;
import { BrowserModule } from &#39;@angular/platform-browser&#39;;
import { IonicApp, IonicModule, IonicErrorHandler } from &#39;ionic-angular&#39;;
import { HttpModule } from &#39;@angular/http&#39;;

import { StatusBar } from &#39;@ionic-native/status-bar&#39;;
import { SplashScreen } from &#39;@ionic-native/splash-screen&#39;;
import { Dialogs } from &amp;quot;@ionic-native/dialogs&amp;quot;;
import { Camera } from &#39;@ionic-native/camera&#39;;
import {File} from &#39;@ionic-native/file&#39;;
import { FileTransfer } from &#39;@ionic-native/file-transfer&#39;;


import { AppComponent } from &#39;./app.component&#39;;
import { StorageService } from &amp;quot;../providers/StorageService&amp;quot;;
import { HttpService } from &amp;quot;../providers/HttpService&amp;quot;;



@NgModule({
  declarations: [
    AppComponent,
  ],
  imports: [
    BrowserModule,
    HttpModule,
    IonicModule.forRoot(AppComponent,{
      mode: &#39;md&#39;,         //ios是&#39;ios&#39;
      backButtonText: &#39;&#39;,
    }),
  ],
  bootstrap: [IonicApp],
  entryComponents: [
    AppComponent,
  ],
  providers: [
    StatusBar,
    SplashScreen,
    StorageService,
    HttpService,
    Dialogs,
    Camera,
    File,
    FileTransfer,
    {provide: ErrorHandler, useClass: IonicErrorHandler}
  ]
})
export class AppModule {}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d06c5885556d8639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;camera.html，界面布局，这里主要就是三个测试button，分别对应 拍照、上传、下载功能。还有一个 &lt;img&gt;标签，用于将拍照的照片显示在界面上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-header&amp;gt;

  &amp;lt;ion-navbar&amp;gt;
    &amp;lt;ion-title&amp;gt;camera&amp;lt;/ion-title&amp;gt;
  &amp;lt;/ion-navbar&amp;gt;

&amp;lt;/ion-header&amp;gt;


&amp;lt;ion-content padding&amp;gt;

  &amp;lt;button ion-button (click)=&amp;quot;openCamera()&amp;quot;&amp;gt;打开摄像头&amp;lt;/button&amp;gt;
  &amp;lt;button ion-button (click)=&amp;quot;upload()&amp;quot;&amp;gt;文件上传&amp;lt;/button&amp;gt;
  &amp;lt;button ion-button (click)=&amp;quot;download()&amp;quot;&amp;gt;文件下载&amp;lt;/button&amp;gt;

  &amp;lt;div&amp;gt;
    &amp;lt;img [src]=&amp;quot;path&amp;quot; /&amp;gt;
  &amp;lt;/div&amp;gt;

&amp;lt;/ion-content&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;camera.ts，逻辑代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import {Component} from &#39;@angular/core&#39;;
import {IonicPage, NavController, NavParams} from &#39;ionic-angular&#39;;
import {Camera, CameraOptions} from &#39;@ionic-native/camera&#39;;
import {FileTransfer, FileUploadOptions, FileTransferObject} from &#39;@ionic-native/file-transfer&#39;;
import {File} from &#39;@ionic-native/file&#39;;
import {stringify} from &#39;qs&#39;;

@IonicPage()
@Component({
  selector: &#39;page-camera&#39;,
  templateUrl: &#39;camera.html&#39;,
})
export class CameraPage {

  path: string;
  access_token: string = &#39;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsiYXBpLXJlc291cmNlIl0sInVzZXJfbmFtZSI6ImFkbWluIiwic2NvcGUiOlsicmVhZCIsIndyaXRlIiwidHJ1c3QiXSwiZXhwIjoxNTA5MTk2OTcyLCJhdXRob3JpdGllcyI6WyJST0xFX1VTRVIiXSwianRpIjoiOWFmYmIyYWItMzdiYi00MTIyLTg2NDAtY2FmMDc1OTRmOGZkIiwiY2xpZW50X2lkIjoiY2xpZW50MiJ9.bJOpK0UjCI1ym32uerR_jKp4pv8aLaOxnTeK_DBjYZU&#39;;
  fileTransfer: FileTransferObject = this.transfer.create();

  constructor(public navCtrl: NavController,
              public navParams: NavParams,
              private camera: Camera,
              private transfer: FileTransfer, private file: File,) {
  }


  /**
   * 打开摄像头
   */
  openCamera() {
    const options: CameraOptions = {
      quality: 90,                                                   //相片质量 0 -100
      destinationType: this.camera.DestinationType.DATA_URL,        //DATA_URL 是 base64   FILE_URL 是文件路径
      encodingType: this.camera.EncodingType.JPEG,
      mediaType: this.camera.MediaType.PICTURE,
      saveToPhotoAlbum: true,                                       //是否保存到相册
      // sourceType: this.camera.PictureSourceType.CAMERA ,         //是打开相机拍照还是打开相册选择  PHOTOLIBRARY : 相册选择, CAMERA : 拍照,
    }

    this.camera.getPicture(options).then((imageData) =&amp;gt; {
      console.log(&amp;quot;got file: &amp;quot; + imageData);

      // If it&#39;s base64:
      let base64Image = &#39;data:image/jpeg;base64,&#39; + imageData;
      this.path = base64Image;

      //If it&#39;s file URI
      // this.path = imageData;

      this.upload();

    }, (err) =&amp;gt; {
      // Handle error
    });
  }


  /**
   * 文件上传
   */
  upload() {
    const apiPath = &amp;quot;http://192.168.0.104:9090/api/commons/attach?&amp;quot; + stringify({access_token: this.access_token});
    let options: FileUploadOptions = {
      fileKey: &#39;file&#39;,
      fileName: &#39;name.jpg&#39;,   //文件名称
      headers: {},
      // 如果要传参数，写这里
      params: {
        maxSize: 5000000,
        modularName: &#39;CNL&#39;,
        allowType: &#39;jpg;png;pdf;doc;xls;xlsx;docx&#39;,
      }
    };

    this.fileTransfer.upload(this.path, apiPath, options)
      .then((data) =&amp;gt; {
        console.log(data);

      }, (err) =&amp;gt; {
        console.log(err);
      });
  }


  /**
   * 文件下载
   */
  download() {
    const url = &amp;quot;http://192.168.0.104:9090/api/fms/sys/attach/file/detail?&amp;quot; + stringify({
      fileId: 17161,
      access_token: this.access_token
    });
    this.fileTransfer.download(url, this.file.externalApplicationStorageDirectory + &#39;Mac.png&#39;).then((entry) =&amp;gt; {
      console.log(&#39;download complete: &#39; + entry.toURL());
    }, (error) =&amp;gt; {
      console.log(error);
    });
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;代码分析&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;文件上传调用 File Transfer 插件的 upload方法
文件下载调用 File Transfer 的 download方法
通过调用 Camera 插件的getPicture方法获取照片
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;filePath = this.file.externalApplicationStorageDirectory + &#39;Mac.png&#39;;
这里为了测试方便写死了的路径，代表设备下的一个文件，这个文件名字叫做Mac.png。
this.file.externalApplicationStorageDirectory 代表了设备上的一个路径。
以安卓设备为例，我的项目app_id是 com.xxx.aaa，那么this.file.externalApplicationStorageDirectory最终代表的就是这个路径
 “file:///storage/emulated/0/Android/data/com.xxx.aaa/ ”

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;const access_token = xxx;
为了测试了方便，这里直接将用户登录通过验证之后返回的access_token 写到代码里面。在测试中，以实际情况为准，可以没有这个验证，一切看你的后台。
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;params: {
    maxSize: 5000000,
    modularName: &#39;CNL&#39;,
    allowType: &#39;jpg;png;pdf;doc;xls;xlsx;docx&#39;,
}
这也是后台接口需要的参数，具体需要什么参数，要不要传参数，都是以你的后台接口为依据，在测试过程中如果不太如意，看看是不是后台接口的问题。
之后会写一篇文章专门介绍一个简单的后台接口。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试文件上传功能，因为在测试文件上传的时候，需要访问设备的原生功能，比如读取文件，因此需要在真机上调试。可是在真机上调试会又一个问题：无法查看日志。这对调试而言是非常不方便的。不过强大的chrom为我们提供了方法，具体方法请参上面给出的链接。&lt;/p&gt;

&lt;p&gt;在上面的代码中， 在拍照完成的回调的函数中，直接调用了 this.upload() 方法，该方法负责上传文件，所以在拍照完成后，就会直接将图片上传到服务器，同时图片展示在界面。在本例中，图片是以 base64 的形式上传的，也可以用File URL的形式上传文件。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 Android签名</title>
      <link>https://www.spilledyear.cn/post/ionic3-android%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Sun, 29 Oct 2017 17:37:44 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-android%E7%AD%BE%E5%90%8D/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/235.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;app签名，相当于是app在Anndroid系统上的一个认证，Android系统要求每一个Android应用程序必须要经过数字签名才能够安装到系统中，也就是说如果一个Android应用程序没有经过数字签名，是没有办法安装到系统中的！Android通过数字签名来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字签名由应用程序的作者完成，并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。应用市场上APP签名不允许相同，也不会相同，但允许有相同的包名，相同签名的APP高版本可以覆盖低版本。&lt;/p&gt;

&lt;p&gt;在开发过程中，如果没有手动给app添加签名，ADT会自动的使用debug密钥为应用程序签，debug密钥是一个名为debug.keystore的文件，它的位置在：C:/${user}/.android/debug.keystore 。也就是说，如果想拥有自己的签名，而不是让ADT使用自动生成的debug.keystore签名的话，需要有一个属于自己的密钥文件（*.keystore）。
&amp;gt;默认的 debug.keystore 位置如下：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-8e5a04cf11ddd80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以下是在命令行下，ionic 安卓app签名步骤&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;keytool：该工具位于jdk安装路径的bin目录下；&lt;/li&gt;
&lt;li&gt;jarsigner：该工具位于jdk安装路径的bin目录下；&lt;/li&gt;
&lt;li&gt;zipalign：该工具位于Android-sdk-windows/tools/目录下；&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;keytool和jarsigner两个工具是jdk自带的，也就意味着生成数字证书和文件签名不是Android的专利，jarsigner主要是用来给jar文件签名的。配置了JAVA环境变量，keytool和jarsigner可以直接在命令行下使用。zipalign 可能新老版本不太相同，可以在ANDROID_HOME下全局搜索zipalign.exe文件，以下是我电脑上的文件路径：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-1d7cbd51cdf0936e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;生成未经签名的apk文件&#34;&gt;生成未经签名的apk文件&lt;/h2&gt;

&lt;p&gt;Android app 的打包分为 debug 和 release 两种，后者是用来发布到应用商店的版本。在开发ionix项目是，使用默认命令(ionic cordova build android)打包出来的是debug apk文件。要打包 release 版本的apk文件，只需要在后面加一个 &amp;ndash;release 参数即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic cordova build android --release
执行该命令后，会在   ionic项目根目录\platforms\android\build\outputs\apk    目录 
下生成一个 “android-release-unsigned.apk” 文件，这个apk文件就是 没有使用默认签名的 文件。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;签名&#34;&gt;签名&lt;/h2&gt;

&lt;h6 id=&#34;使用keytool-生成数字证书&#34;&gt;使用keytool 生成数字证书&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore spilledyear.keystore -alias spilledyear.keystore -keyalg RSA -validity 36500

keytool是工具名称  
-genkey意味着执行的是生成数字证书操作 
-v表示将生成证书的详细信息打印出来，显示在dos窗口中  
-keystore spilledyear.keystore 表示生成的数字证书的文件名为“ spilledyear.keystore”(spilledyear可以取自己的名字) 
-alias spilledyear.keystore 表示证书的别名为“spilledyear.keystore”，当然可以不和上面的文件名一样 
-keyalg RSA 表示生成密钥文件所采用的算法为RSA 
-validity 36500 表示该数字证书的有效期为36500天，意味着36500天之后该证书将失效 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;在执行上面的命令生成数字证书文件时，会提示你输入一些信息，包括证书的密码，如图所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-5d03f02c8142ceb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;keystore.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;使用jarsigner为app签名&#34;&gt;使用jarsigner为app签名&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;jarsigner -verbose -keystore spilledyear.keystore -signedjar zmjj.apk android-release-unsigned.apk spilledyear.keystore

jarsigner是工具名称 
-verbose表示将签名过程中的详细信息打印出来，显示在dos窗口中
-keystore spilledyear.keystore 表示签名所使用的数字证书所在位置，没有写路径表示在当前目录下
-signedjar zmjj.apk android-release-unsigned.apk 表示给android-release-unsigned.apk文件签名，签名后的文件名称为zmjj.apk 
spilledyear.keystore 表示证书的别名，对应于生成数字证书时-alias参数后面的名称
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;运行该命令，结果如下图所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-45a64f2a548092d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;jarsigner01.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-0bac020e0b048c93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;jarsigner02.png&#34; /&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-bf63f028b8d68bdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;jarsigner03.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&#34;使用zipalign优化已签名的apk&#34;&gt;使用zipalign优化已签名的apk&lt;/h6&gt;

&lt;p&gt;此步骤时非必需操作，但是建议这么做。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zipalign -v 4 zmjj.apk zmjj_aligned.apk
zipalign是工具名称 
-v表示在DOS窗口打印出详细的优化信息 
zmjj.apk zmjj_aligned.apk 表示对已签名文件 zmjj.apk进行优化，优化后的文件名为zmjj_aligned.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;执行以上命令，结果如下图所示：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-10f161f94796c754.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
此时在目录下又多生成了一个文件，zmjj_aligned.apk  ，也就是被压缩优化过的apk文件：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-db8892797e3f88a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果以前的程序是采用默认签名的方式(即debug签名)，一旦换了新的签名，应用将不能覆盖安装，必须将原先的程序卸载掉，才能安装上。因为程序覆盖安装主要检查两点：
- 两个程序的入口Activity是否相同。两个程序如果包名不一样，即使其它所有代码完全一样，也不会被视为同一个程序的不同版本；
- 两个程序所采用的签名是否相同。如果两个程序所采用的签名不同，即使包名相同，也不会被视为同一个程序的不同版本，不能覆盖安装。&lt;/p&gt;

&lt;p&gt;另外，可能有人可能会认为反正debug签名的应用程序也能安装使用，那也没有必要自己签名了。千万不要这样想，debug签名的应用程序有这样两个限制，或者说风险：
- debug签名的应用程序不能在Android 应用商店上架销售，它会强制你使用自己的签名。
- debug.keystore在不同的机器上所生成的可能都不一样，就意味着如果换了机器对app打包升级，那么将会出现上面那种程序不能覆盖安装的问题。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 调摄像头</title>
      <link>https://www.spilledyear.cn/post/ionic3-%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/</link>
      <pubDate>Sun, 29 Oct 2017 02:16:38 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-%E8%B0%83%E6%91%84%E5%83%8F%E5%A4%B4/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/265.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍cordova插件调用设备摄像头流程，为了方便查看测试结果，需要了解Ionic应用调试的基本方法，有关于Ionic项目Android 调试的详细教程，请参考以下文章：
&lt;a href=&#34;http://www.jianshu.com/p/d873b831e207&#34;&gt;Ionic3 Android调试&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##环境准备
######安装 cordova-plugin-camera 插件
cordova-plugin-camera  这是比较新版本的插件，老版本的插件是这个：‘org.apache.cordova.camera’，不过官方已经不推荐使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova plugin add cordova-plugin-camera
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装插件之后，在ionic项目的根目录下执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install --save @ionic-native/camera
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成安装之后，就可以利用插件调用原生设备的API了。&lt;/p&gt;

&lt;p&gt;##将插件添加到app.module.ts 中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Camera } from &#39;@ionic-native/camera&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-6af6ddc807bad41c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;全局添加到Providers中。&lt;/p&gt;

&lt;p&gt;##实现过程
新建一个page 用作测试，使用 ionic cli 创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ionic g page camera
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行以上命令会在 pages 目录下新建一个 camera目录，打开camera目录下的camera.html文件，为其添加一个 button&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ion-header&amp;gt;

  &amp;lt;ion-navbar&amp;gt;
    &amp;lt;ion-title&amp;gt;camera&amp;lt;/ion-title&amp;gt;
  &amp;lt;/ion-navbar&amp;gt;

&amp;lt;/ion-header&amp;gt;


&amp;lt;ion-content padding&amp;gt;

  &amp;lt;button ion-button (click)=&amp;quot;openCamera()&amp;quot;&amp;gt;打开摄像头&amp;lt;/button&amp;gt;

&amp;lt;/ion-content&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打开camera.ts 文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import { Component } from &#39;@angular/core&#39;;
import { IonicPage, NavController, NavParams } from &#39;ionic-angular&#39;;
import { Camera, CameraOptions } from &#39;@ionic-native/camera&#39;;

@IonicPage()
@Component({
  selector: &#39;page-camera&#39;,
  templateUrl: &#39;camera.html&#39;,
})
export class CameraPage {

  constructor(
    public navCtrl: NavController,
    public navParams: NavParams,
    private camera: Camera) {
  }

  ionViewDidLoad() {
    console.log(&#39;ionViewDidLoad CameraPage&#39;);
  }


  /**
   * 打开摄像头
   */
  openCamera(){
    const options: CameraOptions = {
      quality: 100,
      destinationType: this.camera.DestinationType.DATA_URL,
      encodingType: this.camera.EncodingType.JPEG,
      mediaType: this.camera.MediaType.PICTURE,
      // sourceType: this.camera.PictureSourceType.PHOTOLIBRARY,
      saveToPhotoAlbum: true,//是否保存到相册
    }

    this.camera.getPicture(options).then((imageData) =&amp;gt; {
      
      console.log(&amp;quot;got file: &amp;quot; + imageData.fullPath);
      console.log(imageData);

      // imageData is either a base64 encoded string or a file URI
      // If it&#39;s base64:
      let base64Image = &#39;data:image/jpeg;base64,&#39; + imageData;

    }, (err) =&amp;gt; {
      // Handle error
    });
  }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑 app 目录下的app.component.ts文件，设置 CameraPage 为首页(便于测试)。&lt;/p&gt;

&lt;p&gt;##测试
用usb数据线将手机和电脑向连接，打开手机的开发者模式，在ionic项目跟目录执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova run android 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后便可以在手机上看到该应用，点击 “打开相机” 按钮，即可条用手机的摄像头进行拍照。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Ionic3 Android调试</title>
      <link>https://www.spilledyear.cn/post/ionic3-android%E8%B0%83%E8%AF%95/</link>
      <pubDate>Sun, 29 Oct 2017 02:16:17 +0000</pubDate>
      
      <guid>https://www.spilledyear.cn/post/ionic3-android%E8%B0%83%E8%AF%95/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://www.spilledyear.cn/pictures/home/235.jpg&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要介绍将Ionic项目打包成安卓应用之后的调试过程，调试方式分两种：模拟器调试、真机调试。不过在此之前，必须要将ionic项目成功打包成Android应用，有关 ionic打包成Android应用的具体教程，请参考以下文章：
&lt;a href=&#34;http://www.jianshu.com/p/a7791341709e&#34;&gt;Ionic3 Android打包&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;模拟器调试&#34;&gt;模拟器调试&lt;/h2&gt;

&lt;p&gt;模拟器调试也就是启动android模拟器，然后在模拟器上看效果。在使用android模拟器之前，需要先下载对应体系的模拟器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在命令行下运行：android sdk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现如下界面。找到你需要的android版本，比如我的是android6。然后看图中重点标记的三个选项，分别是：
- ARM EABI v7a System Image
- Intel x86 Atom System Image
- Intel x86 Atom_64 System Image
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-bab12d80407f0932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
Intel x86 Atom System Image是支持X86的Android模拟器，ARM EABI v7aSystem Image是模拟ARM体系，而Intel x86 Atom_64 System Image 也就是64位的意思。创建模拟器时模拟的CPU不同，ARM运行速度较慢，所以Intel推出了支持x86的Android模拟器，这将大大提高启动速度和程序的运行速度，允许Android模拟器以原始速度（真机运行速度）运行在使用Intel x86处理器的电脑中。但是，要使用X86模拟器的话，需要安装 英特尔硬件加速执行管理器。安装这个加速器的方法可能由两种。不过可能我系统比较新，第一种已经不支持了。
&lt;strong&gt;第一种方法就是在 SDK中直接安装&lt;/strong&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-894cf0d8c6e1a87d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
不过从图上也可以看到，这种方法不行的： not compatible with windeows。提示与windows不兼容，所以这里使用这种方法安装是不行的。
另一种方法就是直接去官网下载安装包，然后安装即可。&lt;a href=&#34;https://software.intel.com/en-us/articles/intel-hardware-accelerated-execution-manager-intel-haxm&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装之后，就可以启动模拟器进行测试了。可以通过 cordova emulate android 调出模拟器。不过在此之前，我们需要先通过 avd 工具创建一个模拟器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;运行命令： android avd
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这时候会打开创建模拟器的可视化界面，如图：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-cb1e8d773a796eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
通过这个界面，可以创建和修改android模拟器。上图中已经有了一个我创建好的模拟器了。可以编辑，大概就是这个样子：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-be0872b980dac9c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;01.png&#34; /&gt;
以上的参数可以根据自己的实际情况来测试，也可以按照上图来创建一个模拟器。Ok，接下来启动模拟器看看效果：
&lt;strong&gt;点击start&lt;/strong&gt;
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-025eb6588bfe82a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;02.png&#34; /&gt;
如果不出意外，是可以启动成功的，启动成功之后，可以看到以下界面：
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-a94d77a233f260a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;03.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;至此，模拟器创建并启动成功，接下来将应用放到模拟器上运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;运行命令：cordova emulate android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到如下界面。注意，这里看到的界面就是你的app界面，以实际情况为准
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-d8bd0b6767d9c044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;04.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;不得不说，使用x86模拟器真的方便太多了,相对RAM模拟器来讲快太多！可能是因为直接使用电脑上的cpu，然后这个和电脑的配置也有关系吧。&lt;/p&gt;

&lt;h2 id=&#34;真机调试&#34;&gt;真机调试&lt;/h2&gt;

&lt;p&gt;除了使用模拟器调试，还可以使用真机调试。使用真机调试也特别简单：
在手机上开机USB调试 》将手机和电脑用USB数据线连接 》执行命令。
每部手机开启usb调试功能 的方法可能都不一样，我的手机系统是 emui5，应该华为手机开启usb调试功能方法都是相同的。
设置——》关于手机
找到版本号那个选项，然后连续点击多次(好像5次或者7次，可能不同型号不一样)，点击完之后会提示手机已经是开发者模式了。然后返回，可以看到有个开发者选项，点进去，打开USB调试即可。
准备工作完毕，接下来直接执行以下命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cordova run android 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-2bb51306cde72068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果不出意外，手机上会打开那个app的界面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;真机调试日志&lt;/strong&gt;
真机调试可以看到应用的真实运行效果，这是检测bug的最好方法。但是这种方法也有一个问题，比如在代码中输出的日志该怎么查看？日志是开发过程中非常重要的一个功能，有时候很多不懂的东西，打印出来一看可能就明白，以下是真机调试中查看日志的方法：&lt;a href=&#34;https://jingyan.baidu.com/article/db55b609fde96d4ba30a2fa9.html?qq-pf-to=pcqq.c2c&#34;&gt;https://jingyan.baidu.com/article/db55b609fde96d4ba30a2fa9.html?qq-pf-to=pcqq.c2c&lt;/a&gt;
参照以上的链接，这里就以新版本的chrome来介绍。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cheome：版本 61.0.3163.100（正式版本） （64 位）
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;推荐大家也升级，升级肯定有升级的道理，挑最新的用
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-2ba5eac2fe96b89e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;步骤如下
- 手机开启usb调试功能
- usb数据线将手机与电脑相连接
- 用chrome最新版本打开以下链接：chrome://inspect/#devices
&amp;gt;如图所示，保持选项和图上的一致就可以了
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-220e17ab59b98458.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image01.png&#34; /&gt;
- ionic 项目根目录下执行 cordova run android
- 刷新 chrome://inspect/#devices 界面，查看界面效果
&amp;gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-c1831325bd60551a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image02.png&#34; /&gt;
如果能看到上图中的效果，说明你成功了一半。如果这时候还是无法看到你的设备，就把数据线断开再重新连接一次，然后再执行 cordova run android 。这样一般就可以了，我百试百灵。
- 点击该界面的 inspect 连接
&amp;gt;注意，第一次打开可能是一片空白，可能好久都打不开，可能需要翻墙，遇到这种情况就耐心点，翻翻墙试试。只要过了第一次，之后打开就很方便了。
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-c2972e06fc9dfd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;
打开之后，弹出一个浏览器调试窗口，下面是一张效果图
&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/3744244-43f323e8b574da21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;image.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正常情况都可以成功的，有了这个调试就方便多了。&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
