<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Dubbo源码之SPI机制 - spilledyear</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="spilledyear" />
  <meta name="description" content="" />

  <meta name="keywords" content="Hugo, theme, spilledyear" />






<meta name="generator" content="Hugo 0.55.6" />


<link rel="canonical" href="https://www.spilledyear.cn/post/dubbo%E6%BA%90%E7%A0%81%E4%B9%8Bspi%E6%9C%BA%E5%88%B6/" />



<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.31c4b7729c8d71cc152f8de4203d90bfd8a04f7eab69372de7234ebf55b7701b.css" integrity="sha256-McS3cpyNccwVL43kID2Qv9igT36raTct5yNOv1W3cBs=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/custom.css">


<meta property="og:title" content="Dubbo源码之SPI机制" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.spilledyear.cn/post/dubbo%E6%BA%90%E7%A0%81%E4%B9%8Bspi%E6%9C%BA%E5%88%B6/" />
<meta property="article:published_time" content="2019-07-20T18:49:01&#43;00:00"/>
<meta property="article:modified_time" content="2019-07-20T18:49:01&#43;00:00"/>

<meta itemprop="name" content="Dubbo源码之SPI机制">
<meta itemprop="description" content="">


<meta itemprop="datePublished" content="2019-07-20T18:49:01&#43;00:00" />
<meta itemprop="dateModified" content="2019-07-20T18:49:01&#43;00:00" />
<meta itemprop="wordCount" content="6561">



<meta itemprop="keywords" content="DUBBO," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dubbo源码之SPI机制"/>
<meta name="twitter:description" content=""/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">spilledyear</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/post/">文章</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/spilledyear" rel="noopener" target="_blank">
              外部链接
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      spilledyear
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/post/">文章</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://www.spilledyear.cn/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/spilledyear" rel="noopener" target="_blank">
              外部链接
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Dubbo源码之SPI机制</h1>
      
      <div class="post-meta">
        <time datetime="2019-07-20" class="post-time">
          2019-07-20
        </time>
        <div class="post-category">
            <a href="https://www.spilledyear.cn/categories/java/"> Java </a>
            
          </div>
        

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#serviceloader">ServiceLoader</a>
<ul>
<li>
<ul>
<li><a href="#测试案例">测试案例</a></li>
<li><a href="#实现原理">实现原理</a></li>
</ul></li>
</ul></li>
<li><a href="#extensionloader">ExtensionLoader</a>
<ul>
<li>
<ul>
<li><a href="#测试案例-1">测试案例</a></li>
<li><a href="#实现原理-1">实现原理</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#快速预览">快速预览</a></li>
<li><a href="#getextensionloader">getExtensionLoader</a></li>
<li><a href="#getextension">getExtension</a></li>
<li><a href="#createextension">createExtension</a></li>
<li><a href="#getextensionclasses">getExtensionClasses</a></li>
<li><a href="#依赖注入">依赖注入</a></li>
<li><a href="#extensionfactory">ExtensionFactory</a></li>
<li><a href="#getadaptiveextension">getAdaptiveExtension</a></li>
<li><a href="#wrapper处理">Wrapper处理</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p><img src="/pictures/home/049.jpg" alt="index" /></p>

<p>SPI(Service Provider Interface)是一种服务提供发现机制,一个服务通常指的是已知的接口，服务提供方就是这个接口的实现类，然后按照SPI标准存放到资源路径META-INF/services目录下，文件的命名为该服务接口的全限定名。</p>

<p>这里会介绍两种SPI机制：JDK默认提供的SPI机制 ServiceLoader；Dubbo的SPI机制  ExtensionLoader。ServiceLoader功能比较单一，不能依赖注入、不能根据扩展实现类标识符获取特定的扩展实现类实例；</p>

<h1 id="serviceloader">ServiceLoader</h1>

<h3 id="测试案例">测试案例</h3>

<p>有一个服务</p>

<pre><code>package com.zto.sxy.helloworld;

public interface ISPI {
    void say();
}
</code></pre>

<p>实现类SPITestA</p>

<pre><code>package com.zto.sxy.helloworld;

public class SPITestA implements ISPI{
    @Override
    public void say() {
        System.out.println(&quot;SPI with implement testA&quot;);
    }
}
</code></pre>

<p>实现类SPITestB</p>

<pre><code class="language-java">package com.zto.sxy.helloworld;
public class SPITestB implements ISPI{
    @Override
    public void say() {
        System.out.println(&quot;SPI with implement testB&quot;);
    }
}
</code></pre>

<p>然后在resources目录下添加META-INF/services文件夹，同时新建一个名为com.zto.sxy.helloworld.ISPI的文件，内容如下：</p>

<pre><code>com.zto.sxy.helloworld.SPITestA
com.zto.sxy.helloworld.SPITestB
</code></pre>

<p>以下是测试类</p>

<pre><code>public class TestSPI {
    @Test
    public void testWithNoSPI(){
        ISPI testA = new SPITestA();
        testA.say();

        ISPI testB = new SPITestB();
        testB.say();
    }
    
    @Test
    public void testWithSPI(){
        ServiceLoader services = ServiceLoader.load(ISPI.class);
        for (Iterator&lt;ISPI&gt; iterator = services.iterator(); iterator.hasNext(); ) {
            ISPI spi = iterator.next();
            spi.say();
        }
    }
}
</code></pre>

<p>执行测试函数，发现两个输出结果一样，说明SPI生效了，输出结果如下：</p>

<pre><code>SPI with implement testA
SPI with implement testB
</code></pre>

<h3 id="实现原理">实现原理</h3>

<p>先看load方法</p>

<pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
    // 获取当前线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    return ServiceLoader.load(service, cl);
}

public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service,ClassLoader loader){
    return new ServiceLoader&lt;&gt;(service, loader);
}

private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {
    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);
    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;

    // 清空缓存，确保会重新加载
    reload();
}
</code></pre>

<p>在调用的的时候，先通过调用iterator方法返回一个Iterator对象，然后遍历该Iterator对象</p>

<pre><code>public Iterator&lt;S&gt; iterator() {
    return new Iterator&lt;S&gt;() {
        //     private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();
        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders
            = providers.entrySet().iterator();

        public boolean hasNext() {
            if (knownProviders.hasNext())
                return true;
            return lookupIterator.hasNext();
        }

        public S next() {
            if (knownProviders.hasNext())
                return knownProviders.next().getValue();
            return lookupIterator.next();
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    };
}
</code></pre>

<p>调用hasNext方法的时候，会调用lookupIterator.hasNext()</p>

<pre><code>private boolean hasNextService() {
    if (nextName != null) {
        return true;
    }
    if (configs == null) {
        try {
            String fullName = PREFIX + service.getName();
            if (loader == null)
                configs = ClassLoader.getSystemResources(fullName);
            else
                configs = loader.getResources(fullName);
        } catch (IOException x) {
            fail(service, &quot;Error locating configuration files&quot;, x);
        }
    }
    while ((pending == null) || !pending.hasNext()) {
        if (!configs.hasMoreElements()) {
            return false;
        }

        // 获取所有类的全类名
        pending = parse(service, configs.nextElement());
    }
  
    nextName = pending.next();
    return true;
}
</code></pre>

<p>当调用next方法的时候</p>

<pre><code>private S nextService() {
    if (!hasNextService())
        throw new NoSuchElementException();
    String cn = nextName;
    nextName = null;
    Class&lt;?&gt; c = null;
    try {
        c = Class.forName(cn, false, loader);
    } catch (ClassNotFoundException x) {
        fail(service,
                &quot;Provider &quot; + cn + &quot; not found&quot;);
    }
    if (!service.isAssignableFrom(c)) {
        fail(service,
                &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
    }
    try {
        // 实例化
        S p = service.cast(c.newInstance());
        providers.put(cn, p);
        return p;
    } catch (Throwable x) {
        fail(service,
                &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,
                x);
    }
    throw new Error();          // This cannot happen
}
</code></pre>

<p>ServiceLoader不是一实例化以后立马就去读配置文件中的服务实现者并实例化，而是等其Iterator实现获取对应的服务提供者时才会加载对应的配置文件进行解析，在调用Iterator的hasNext方法时会去加载配置文件进行解析，在调用next方法时会将对应的服务提供者进行实例化并进行缓存。</p>

<h1 id="extensionloader">ExtensionLoader</h1>

<p><a href="https://shuaijunlan.github.io/2018/08/09/dubbo-spi-analysis/">大佬博客</a></p>

<h3 id="测试案例-1">测试案例</h3>

<pre><code>@Test
public void test() {
    ExtensionLoader loader = ExtensionLoader.getExtensionLoader(Protocol.class);

    Protocol protocol = (Protocol) loader.getExtension(&quot;dubbo&quot;);
}


/**
 * 1.  ExtensionLoader loder = ExtensionLoader.getExtensionLoader(Protocol.class); 返回 loader1
 *        1.1 创建一个ExtensionLoader实例(loader1)，此时 loader1 的 type=Protocol.class，在为 loader1 的 objectFactory 属性赋值的时候，触发 ExtensionFactory 对应的ExtensionLoader实例化；
 *
 *        1.2 创建一个ExtensionLoader实例(loader2)，此时 loader2 的 type=ExtensionFactory.class，objectFactory = null;
 *
 *        1.3 执行 loader2 的 getAdaptiveExtension() 方法， 生成一个 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive)，赋值给 loader1 的 objectFactory 属性；
 *                  1.3.1 先从缓存中找到，中不到就执行 loadExtensionClasses() 方法，该方法会从配置文件中加载 ExtensionFactory 所有实现类的class对象，同事可以将 adaptive 和 wrapper 类型的是实现类缓存起来
 *                  1.3.2 找到 ExtensionFactory 对应的 adaptive实现类是 AdaptiveExtensionFactory，然后通过反射创建 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive)；
 *                              1.3.2.1 在 AdaptiveExtensionFactory 构造函数中，通过 loader2.getSupportedExtensions() 方法找到 spi(1.2.1中缓存起来的), 然后调用 loader2.getExtension(&quot;spi&quot;);
 *                              1.3.2.2 在 loader2.getExtension(&quot;spi&quot;) 方法中通过反射生成一个 SpiExtensionFactory 实例(spiExtensionFactory);
 *                              1.3.2.3 将 1.2.2.2 中生成的 SpiExtensionFactory 实例(spiExtensionFactory)  保存到 extensionFactoryAdaptive的factories属性中；
 *
 *        1.4 将 1.3 中生成的 AdaptiveExtensionFactory 实例(extensionFactoryAdaptive) 赋值给loader2的 objectFactory 属性，即 loader.objectFactory = extensionFactoryAdaptive;
 *
 *
 * 2. Protocol protocol = (Protocol) loder.getExtension(&quot;dubbo&quot;); 这里的 loader 对应上面的 loader1
 *        2.1  先从缓存中获取，如果缓存中没有，就获取dubbo对应实现类的class对象，然后通过通过反射创建实例并放入缓存；
 *
 *        2.2 执行 injectExtension 方法，这是依赖注入相关的方法，可以注入 spring里面的bean对象 和 SPI对象；
 *                  2.2.1 找到实例的 setter 方法；
 *                  2.2.2 执行 objectFactory.getExtension 方法，这里的 objectFactory 就是指 extensionFactoryAdaptive；
 *                  2.2.3 执行 extensionFactoryAdaptive.getExtension 方法，然后在 该方法内部调用 spiExtensionFactory.getExtension 方法；
 *                  2.2.4 在 spiExtensionFactory.getExtension 方法内部找到对应的adaptive实例；
 *                  
 *        2.3 执行 wrapper 操作，即给实例 一层一层的包装，类似于多层代理；
 *        
 *        2.4 返回最终的实例；
 */
</code></pre>

<h3 id="实现原理-1">实现原理</h3>

<p>在此之前，先看看ExtensionLoader中一些属性的含义</p>

<h6 id="快速预览">快速预览</h6>

<pre><code>private static final Logger logger = LoggerFactory.getLogger(ExtensionLoader.class);

private static final String SERVICES_DIRECTORY = &quot;META-INF/services/&quot;;

private static final String DUBBO_DIRECTORY = &quot;META-INF/dubbo/&quot;;

private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + &quot;internal/&quot;;

private static final Pattern NAME_SEPARATOR = Pattern.compile(&quot;\\s*[,]+\\s*&quot;);

// 所有ExtensionLoader实例共享，缓存 对应扩展接口：ExtensionLoader实例
private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;&gt;();

// 所有ExtensionLoader实例共享，缓存 对应实现类class对象：对应的实现类实例
private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;&gt;();

// 扩展接口Class对象
private final Class&lt;?&gt; type;

private final ExtensionFactory objectFactory;

// 缓存 实现类Class对象：实现类标识
private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;&gt;();

// 缓存当前扩展下所有实现类的 Class对象
private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;&gt;();

// 缓存带有@Active注解的实现类，实现类标识：实现类Class对象，@Active注解表示该扩展实现类的激活条件和时机
private final Map&lt;String, Object&gt; cachedActivates = new ConcurrentHashMap&lt;&gt;();

// 缓存 实现类标识：Holder，因为种扩展都对应一个ExtensionLoader实例，所以通过实现类标识可以区分实现类
private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;&gt;();

// 缓存 带有@Adaptive注解的实现类的实例，因为每种扩展只能有一个实现类带有@Adaptive注解
private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;&gt;();

// 缓存 带有@Adaptive注解的实现类Class对象，因为每种扩展只能有一个实现类带有@Adaptive注解
private volatile Class&lt;?&gt; cachedAdaptiveClass = null;

private String cachedDefaultName;
private volatile Throwable createAdaptiveInstanceError;

// 缓存 包装类 实现类里参数是接口类型的(如 com.alibaba.dubbo.rpc.Protocol类型，并且只有1个参数)的构造函数，表示它是个接口包装类
private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;

private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;&gt;();
</code></pre>

<h6 id="getextensionloader">getExtensionLoader</h6>

<p>getExtensionLoader是一个静态方法，用于获取一个ExtensionLoader实例，每种扩展对应一个ExtensionLoader实例，缓存在一个静态ConcurrentMap中</p>

<pre><code>public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {
    if (type == null)
        throw new IllegalArgumentException(&quot;Extension type == null&quot;);
    if (!type.isInterface()) {
        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);
    }

    // 检查是否有@SPI注解
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException(&quot;Extension type(&quot; + type +
                &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);
    }

    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));
        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    }
    return loader;
}

private ExtensionLoader(Class&lt;?&gt; type) {
    this.type = type;
    // 在创建ExtensionLoader实例的过程中，涉及到和ExtensionFactory扩展相关的操作，这个在下面会有详细介绍
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}
</code></pre>

<h6 id="getextension">getExtension</h6>

<p>每种扩展对应一个ExtensionLoader实例，每个ExtensionLoader实例中缓存了很多和当前扩展相关的信息，例如：该扩展的实现类、带有@Adaptive注解的扩展实现类、Wrapper实现类等等。getExtension主要是根据扩展实现类标识符获取对应的扩展实现类实例：</p>

<pre><code>public T getExtension(String name) {
    if (name == null || name.length() == 0)
        throw new IllegalArgumentException(&quot;Extension name == null&quot;);
    if (&quot;true&quot;.equals(name)) {
        return getDefaultExtension();
    }
    Holder&lt;Object&gt; holder = cachedInstances.get(name);
    if (holder == null) {
        cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;());
        holder = cachedInstances.get(name);
    }
    Object instance = holder.get();
    // 双重校验
    if (instance == null) {
        synchronized (holder) {
            instance = holder.get();
            if (instance == null) {
                // 根据扩展名，获取具体扩展实例
                instance = createExtension(name);
                holder.set(instance);
            }
        }
    }
    return (T) instance;
}
</code></pre>

<h6 id="createextension">createExtension</h6>

<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
private T createExtension(String name) {
    // 先从当前ExtensionLoader实例中的缓存中获取Class对象，如果没有就加载SPI相关文件
    Class&lt;?&gt; clazz = getExtensionClasses().get(name);
    if (clazz == null) {
        throw findException(name);
    }
    try {
        // 同步到静态缓存
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        if (instance == null) {
            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
            instance = (T) EXTENSION_INSTANCES.get(clazz);
        }

        // 完成接口实现类依赖注入，依赖组件先从SPI机制构造查找，再从Spring容器查找（完成第2步）
        injectExtension(instance);

        // 如果这些实现类有wrapper类，当前实例instance，注入到包装类，包装类有多个，依次层层，循环构造注入；最后返回的是，最后一个包装类实例，这也是dubbo的aop实现机制
        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;
        if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {
            for (Class&lt;?&gt; wrapperClass : wrapperClasses) {
                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
            }
        }
        return instance;
    } catch (Throwable t) {
        throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot; +
                type + &quot;)  could not be instantiated: &quot; + t.getMessage(), t);
    }
}
</code></pre>

<h6 id="getextensionclasses">getExtensionClasses</h6>

<p>获取实现类的Class对象，在加载文件的过程中，会将相应的信息放入缓存中</p>

<pre><code>private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() {
    // 从缓存中获取
    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
    if (classes == null) {
        synchronized (cachedClasses) {
            classes = cachedClasses.get();
            if (classes == null) {
                // 加载SPI相关文件
                classes = loadExtensionClasses();
                cachedClasses.set(classes);
            }
        }
    }
    return classes;
}

// synchronized in getExtensionClasses
private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {
    final SPI defaultAnnotation = type.getAnnotation(SPI.class);
    // 判断是否有@SPI注解
    if (defaultAnnotation != null) {
        String value = defaultAnnotation.value();
        if ((value = value.trim()).length() &gt; 0) {
            String[] names = NAME_SEPARATOR.split(value);
            // 只能有一个默认值：SPI(value=&quot;xxx&quot;)，默认实现xxx
            if (names.length &gt; 1) {
                throw new IllegalStateException(&quot;more than 1 default extension name on extension &quot; + type.getName()
                        + &quot;: &quot; + Arrays.toString(names));
            }
            if (names.length == 1) cachedDefaultName = names[0];
        }
    }

    // 读取三个目录下的spi 配置文件;/META-INF/dubbo/internal, /META-INF/dubbo, /META-INF/services
    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;&gt;();
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());
    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;));
    return extensionClasses;
}
</code></pre>

<h6 id="依赖注入">依赖注入</h6>

<p>在实例化扩展实现类的时候，该实现类可能会依赖一些其他的对象，主要有两种：一种是Spring容易中的Bean对象；另一种是其它的扩展实现类对象。</p>

<pre><code>private T injectExtension(T instance) {
    try {
        if (objectFactory != null) {
            for (Method method : instance.getClass().getMethods()) {
                if (method.getName().startsWith(&quot;set&quot;)
                        &amp;&amp; method.getParameterTypes().length == 1
                        &amp;&amp; Modifier.isPublic(method.getModifiers())) {
                    // 获取所有public类型，并且只有一个参数的以set开头的方法

                    Class&lt;?&gt; pt = method.getParameterTypes()[0];
                    try {
                        // 构造驼峰命名法，得到该set方法的参数的类型，即：要注入的对应类型
                        String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;

                        // 获取要注入对应的实例
                        Object object = objectFactory.getExtension(pt, property);

                        if (object != null) {
                            // 执行set方法，完成注入
                            method.invoke(instance, object);
                        }
                    } catch (Exception e) {
                        logger.error(&quot;fail to inject via method &quot; + method.getName()
                                + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);
                    }
                }
            }
        }
    } catch (Exception e) {
        logger.error(e.getMessage(), e);
    }
    return instance;
}
</code></pre>

<h6 id="extensionfactory">ExtensionFactory</h6>

<p>有关于objectFactory对象，这里涉及到的内容比较多，在文章的开头已经提到过，这里详细解释一下</p>

<pre><code>private ExtensionLoader(Class&lt;?&gt; type) {
    this.type = type;
    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
}

public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {
    if (type == null)
        throw new IllegalArgumentException(&quot;Extension type == null&quot;);
    if (!type.isInterface()) {
        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);
    }
    if (!withExtensionAnnotation(type)) {
        throw new IllegalArgumentException(&quot;Extension type(&quot; + type +
                &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);
    }

    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    if (loader == null) {
        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));
        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);
    }
    return loader;
}
</code></pre>

<pre><code>Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).
</code></pre>

<p>当执行以上语句的时候：
1. 先创建Protocol对应的ExtensionLoader实例对象
2. 在执行1的过程中，涉及到ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()操作，所以会先创建ExtensionFactory对应的ExtensionLoader实例对象，然后返回一个ExtensionFactory对象，赋值给Protocol对应的ExtensionLoader实例对象。</p>

<p>ExtensionFactory其实也是一个扩展，并且它有一个带有@Adaptive注解的扩展实现类：AdaptiveExtensionFactory</p>

<pre><code>@SPI
public interface ExtensionFactory {

    /**
     * Get extension.
     *
     * @param type object type.
     * @param name object name.
     * @return object instance.
     */
    &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name);

}
</code></pre>

<blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/11/16b469a1c885405d?w=1240&amp;h=496&amp;f=png&amp;s=56774" alt="" /></p>
</blockquote>

<p>而根据getAdaptiveExtension()方法的名字也可以猜测出，这里应该是创建了一个AdaptiveExtensionFactory对象</p>

<pre><code>public T getAdaptiveExtension() {
    // 加载完SPI文件之后，如果有，就会放入缓存中
    Object instance = cachedAdaptiveInstance.get();
    if (instance == null) {
        if (createAdaptiveInstanceError == null) {
            synchronized (cachedAdaptiveInstance) {
                instance = cachedAdaptiveInstance.get();
                if (instance == null) {
                    try {
                        instance = createAdaptiveExtension();
                        cachedAdaptiveInstance.set(instance);
                    } catch (Throwable t) {
                        createAdaptiveInstanceError = t;
                        throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + t.toString(), t);
                    }
                }
            }
        } else {
            throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);
        }
    }

    return (T) instance;
}

private T createAdaptiveExtension() {
    try {
        // 也需要处理依赖注入
        return injectExtension((T) getAdaptiveExtensionClass().newInstance());
    } catch (Exception e) {
        throw new IllegalStateException(&quot;Can not create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);
    }
}

private Class&lt;?&gt; getAdaptiveExtensionClass() {
    // 这个方法有可能性触发SPI文件加载，当缓存中没有值得时候，就会加载SPI文件
    getExtensionClasses();
    if (cachedAdaptiveClass != null) {
        return cachedAdaptiveClass;
    }

    // 代表 @Adaptive注解添加在了方法上
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}
</code></pre>

<p>以下是AdaptiveExtensionFactory对应的源码</p>

<pre><code>@Adaptive
public class AdaptiveExtensionFactory implements ExtensionFactory {

    private final List&lt;ExtensionFactory&gt; factories;

    public AdaptiveExtensionFactory() {
        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);
        List&lt;ExtensionFactory&gt; list = new ArrayList&lt;&gt;();
        // getSupportedExtensions()返回的是 非包装类扩展，非Adaptive扩展，防止无限循环
        for (String name : loader.getSupportedExtensions()) {
            list.add(loader.getExtension(name));
        }
        factories = Collections.unmodifiableList(list);
    }

    @Override
    public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) {
        // 除AdaptiveExtensionFactory外，依次调用所有ExtensionFactory实现类的getExtension方法，如果找到了，就直接退出
        for (ExtensionFactory factory : factories) {
            T extension = factory.getExtension(type, name);
            if (extension != null) {
                return extension;
            }
        }
        return null;
    }
}
</code></pre>

<p>SpiExtensionFactory 用于注入扩展实现类(非包装类扩展，非Adaptive扩展)，SpringExtensionFactory用于注入Spring容器中的Bean。</p>

<h6 id="getadaptiveextension">getAdaptiveExtension</h6>

<p>上面已经提到了getAdaptiveExtension方法，这个方法用于获取自适应的扩展实现类，这方法真的非常非常重要，在dubbo到处用到了这个特性。有关于@Adaptive注解，这里再详细说明一下：
<code>@Adaptive用法有两种方式，一种在就配置在扩展实现类上，用于扩展实现类上时只能有一个；还有一种直接配置在方法上，这两种方式第一种优先，没有第一种，dubbo自动完成第二种Adaptive类的生成</code>
1. 在扩展实现类上加上@Adaptive注解，是最为明确的创建对应类型Adaptive类，优先级最高；
2. @SPI注解中的value是默认值，如果通过URL获取不到关于取哪个类作为Adaptive类的话，就使用这个默认值，当然如果URL中可以获取到，就用URL中的；
3. 可以在方法上增加@Adaptive注解，注解中的value与链接中的参数的key一致，链接中的key对应的value就是SPI中的name，获取相应的实现类；</p>

<p>其实主要代码都在这里</p>

<pre><code>private Class&lt;?&gt; getAdaptiveExtensionClass() {
    // 这个方法有可能性触发SPI文件加载，当缓存中没有值得时候，就会加载SPI文件
    getExtensionClasses();
    if (cachedAdaptiveClass != null) {
        return cachedAdaptiveClass;
    }

    // 动态生成
    return cachedAdaptiveClass = createAdaptiveExtensionClass();
}

// 动态生成源码，然后编译返回Class对象
private Class&lt;?&gt; createAdaptiveExtensionClass() {
    // 创建代码的字符串形式
    String code = createAdaptiveExtensionClassCode();
    ClassLoader classLoader = findClassLoader();
    // 通过SPI获取java 编译器
    org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();

    // 编译源码返回Class对象
    return compiler.compile(code, classLoader);
}
</code></pre>

<p>以下以Protocol为例进行讲解，因为Protocol对应的扩展实现类上都没有加@Adaptive注解，所以这里主要涉及到Protocol$Adaptive类的动态生成</p>

<pre><code>@SPI(&quot;dubbo&quot;)
public interface Protocol {
    @Adaptive
    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;

    @Adaptive
    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;
}
</code></pre>

<p>使用的场景可能是这样的</p>

<pre><code>private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();
Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);
</code></pre>

<p>其动态生成的Protocol$Adaptive源码如下</p>

<pre><code>package org.apache.dubbo.rpc;
import org.apache.dubbo.common.extension.ExtensionLoader;

public class Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol {
    private static final org.apache.dubbo.common.logger.Logger logger = org.apache.dubbo.common.logger.LoggerFactory.getLogger(ExtensionLoader.class);
    private java.util.concurrent.atomic.AtomicInteger count = new java.util.concurrent.atomic.AtomicInteger(0);

    public void destroy() {
        throw new UnsupportedOperationException(&quot;method public abstract void org.apache.dubbo.rpc.Protocol.destroy() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
    }

    public int getDefaultPort() {
        throw new UnsupportedOperationException(&quot;method public abstract int org.apache.dubbo.rpc.Protocol.getDefaultPort() of interface org.apache.dubbo.rpc.Protocol is not adaptive method!&quot;);
    }

    public org.apache.dubbo.rpc.Invoker refer(java.lang.Class arg0, org.apache.dubbo.common.URL arg1) throws org.apache.dubbo.rpc.RpcException {
        if (arg1 == null) throw new IllegalArgumentException(&quot;url == null&quot;);
        org.apache.dubbo.common.URL url = arg1;
        String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
        if (extName == null)
            throw new IllegalStateException(&quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
        org.apache.dubbo.rpc.Protocol extension = null;
        try {
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
        } catch (Exception e) {
            if (count.incrementAndGet() == 1) {
                logger.warn(&quot;Failed to find extension named &quot; + extName + &quot; for type org.apache.dubbo.rpc.Protocol, will use default extension dubbo instead.&quot;, e);
            }
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(&quot;dubbo&quot;);
        }
        return extension.refer(arg0, arg1);
    }

    public org.apache.dubbo.rpc.Exporter export(org.apache.dubbo.rpc.Invoker arg0) throws org.apache.dubbo.rpc.RpcException {
        if (arg0 == null) throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument == null&quot;);
        if (arg0.getUrl() == null)
            throw new IllegalArgumentException(&quot;org.apache.dubbo.rpc.Invoker argument getUrl() == null&quot;);
        org.apache.dubbo.common.URL url = arg0.getUrl();
        String extName = (url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol());
        if (extName == null)
            throw new IllegalStateException(&quot;Fail to get extension(org.apache.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);
        org.apache.dubbo.rpc.Protocol extension = null;
        try {
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(extName);
        } catch (Exception e) {
            if (count.incrementAndGet() == 1) {
                logger.warn(&quot;Failed to find extension named &quot; + extName + &quot; for type org.apache.dubbo.rpc.Protocol, will use default extension dubbo instead.&quot;, e);
            }
            extension = (org.apache.dubbo.rpc.Protocol) ExtensionLoader.getExtensionLoader(org.apache.dubbo.rpc.Protocol.class).getExtension(&quot;dubbo&quot;);
        }
        return extension.export(arg0);
    }
}
</code></pre>

<p>以export方法为例，从方法参数中Invoker获取信息， 如果没有，就取@SPI注解中的默认值：dubbo，如果都没有值，就抛出IllegalStateException异常</p>

<h6 id="wrapper处理">Wrapper处理</h6>

<p>在处理完一个扩展实现类的依赖注入问题之后，接下来需要处理的便是该扩展实现类的Wrapper问题。在dubbo中，扩展实现类里参数是接口类型的(如 com.alibaba.dubbo.rpc.Protocol类型，并且只有1个参数)的构造函数，表示它是个Wrapper类。为什么需要它的构造函数需要有一个接口类型的参数？主要是用于接收上层对应的扩展实现类，然后Wrapper类实现类接口，所以可以在方法中插入一些自己的逻辑，类似于代理模式。
以ProtocolFilterWrapper为例，主要在于给非Wrapper扩展实现类加强功能</p>

<pre><code>public class ProtocolFilterWrapper implements Protocol {

    private final Protocol protocol;

    public ProtocolFilterWrapper(Protocol protocol) {
        if (protocol == null) {
            throw new IllegalArgumentException(&quot;protocol == null&quot;);
        }
        this.protocol = protocol;
    }

    @Override
    public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {
        if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {
            return protocol.export(invoker);
        }
        return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));
    }

    @Override
    public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException {
        if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) {
            return protocol.refer(type, url);
        }
        return buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);
    }
}
</code></pre>

<p>而有关于通过Wrappe类加强的逻辑</p>

<pre><code>Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;
if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {
    for (Class&lt;?&gt; wrapperClass : wrapperClasses) {
        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
    }
}
</code></pre>

<p>就是将所有的Wrapper类包装在原始的扩展实现类上，在调用的时候，就会先执行所有Wrapper中对应的逻辑，然后再执行真正扩展实现类的逻辑。</p>
    </div>

    
    

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/weixin.jpg">
        <span>微信打赏</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/alipay.jpg">
        <span>支付宝打赏</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://www.spilledyear.cn/tags/dubbo/">DUBBO</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/mybatis/">
            <span class="next-text nav-default">Mybatis</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  

  

  

  

    

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      

<div class="copyright">
  

  <span class="copyright-year">
    &copy;
    2019
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        spilledyear
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.dee43230127a73d039a734510fa896c89c3c7ce0cf0be0c7a7433f8fd69b76dc.js" crossorigin="anonymous"></script>






  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
